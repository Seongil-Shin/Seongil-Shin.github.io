---
title: 브라우저 동작원리
author: 신성일
date: 2021-07-07 21:10:44 +0900
categories: [면접질문, front end]
tags: [브라우저, 면접, front end]
---

## 기본 구조

1. 사용자 인터페이스
2. 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
3. 렌더링 엔진 : 요청한 콘텐츠를 표시. HTML 을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
4. 통신
5. UI 백엔드 : 콤보박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서 OS 사용자 인터페이스 체계를 사용함.
6. 자바스크립트 해석기
7. 자료저장소 : 쿠키 등

- 크롬은 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지함. 즉, 각 탭은 독립된 프로세스로 처리됨.

## 렌더링 엔진

- HTML 및 XML 문서와 이미지를 표시할 수 있음
  - 플러그인이나 브라주어 확장 기능을 통해 PDF 와 같은 유형도 가능하다.
- 엔진 종류
  - 게코 : 파이어폭스
  - 웹킷 : 사파리, 크롬
- 동작과정
  1. DOM 트리 구축을 위한 html 파싱
     - HTML을 파싱하고, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환함.
     - 그 다음 외부 css 파일과 함께 스타일 요소도 파싱함.
     - 스타일 정보와 HTML 표시 규칙은 렌더 트리라고 부르는 또 다른 트리를 생성한다.
  2. 렌더 트리(게코에서는 frame tree) 구축
     - 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고, 정해진 순서대로 화면에 표시한다.
  3. 렌더 트리 배치
     - 각 노드가 화면의 정확한 위치에 표시되는 것을 의미함.
  4. 렌더 트리 그리기
     - ui 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어냄.

## 파싱과 DOM 트리 구축

- 파싱 : 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것

  - 결과 : 보통 문서 구조를 나타내는 노드트리가 나옴. 파싱트리, Syntax tree 라고도 불림

- 파서-어휘 분석기 조합

  - 어휘분석 : 자료를 토큰으로 분해하는 과정.

    - 토큰 : 유효하게 구성된 단위의 집합체로 용어집이라고도 함.

  - 구문분석 : 언어의 구문 규칙을 적용하는 과정

  - 파서 : 문서 -> 어휘분석 -> 구문분석 -> 파싱트리로 만듬.

    - 자료를 유효한 토큰으로 분해하는 어휘 분석기와 언어 구문 규칙에 따라 문서 구조를 분석함으로써 파싱트리를 생성하는 파서가 있음.
    - 어휘 분석기는 공백과 줄바꿈 같은 의미없는 문자를 제거

  - 파싱과정은 반복됨.

    - 파서는 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인함.
    - 규칙에 맞으면 토큰에 해당되는 노드가 파싱트리에 추가되고, 파서는 또 다른 토큰을 요청함.
    - 규칙에 안맞으면 파서는 토큰을 내부적으로 저장하고 토큰과 일치하는 규칙이 발견될 때까ㅏ지 요청함. 맞는 규칙이 없으면 구문 오류가 있다는 것.

- 변환 : 파싱과정을 통해 나온 파싱트리를 기계코드로 변환시키는 과정

- 어휘화 구문에 대한 공식적인 정의

  - 어휘는 보통 정규표현식으로 표현된다.
  - 구문은 보통 BNF라고 부르는 형식에 따라 정의된다.
  - 문법이 문맥 자유 문법이라면 언어는 정규 파서로 파싱할 수 있음.
    - 문맥 자유문법 === 완전히 BNF로 표현가능한 문법

- 파서의 종류

  - 하향식 파서 : 구문의 상위 구조로부터 일치하는 부분을 찾음.

    - 가장 높은 수준의 규칙을 먼저 찾음.

  - 상향식 파서 : 하위 구조로부터 일치하는 부분을 찾음.

    - 입력 값이 규칙에 맞을 때까지 찾아서 맞는 입력값을 규칙으로 바꿈.

    부준적으로 일치하는 표현식은 파서 스택에 쌓이며, 오른쪽으로 갈수록 남는 것이 점차 감소하기때문에 이동-감소 파서라고 부름.

- 파서 자동생성

  - 파서 생성기 : 파서를 생성해 줄 수 있는 도구

  - 웹킷

    - 플렉스(Flex) : 어휘 생성. 토큰의 정규 표현식 정의를 포함하는 파일을 입력 받음.

    - 바이슨(Bison) : 파서 생성. BNF 형식의 언어구문규칙을 입력받음.

## HTML 파서

- Html 마크업을 파싱 트리로 변환함.

- 문법 정의 : W3C 에서 명세로 정의되어있음.

- 문맥 자유문법이 아니다. 따라서 BNF로 표현불가능.

- HTML vs XML

  - HTML : 더 너그로운편. 암묵적으로 태그에 대한 생략이 가능함. 가끔 시작 또는 종료 태그 등을 생략함.
  - 따라서 HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기때문에 문맥 자유 문법이 아님.

- HTML DTD

  - HTML의 정의는 DTD 형식 안에 있는데 SGML 계열 언어의 정의를 이용한 것이다.
  - DTD 형식은 허용되는 모든 요소와 그들의 속성 그리고 중첩구조에 대한 정의를 포함한다.

- DOM : 문서 객체 모델(Document Object Model)

  - 파싱트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. 트리의 최상위 객체는 문서이다ㅏ.
  - DOM은 HTML 문서의 객체 표현이고, 외부로 향하는 자바스크립트와 같은 HTML 요소의 연결지점이 된다.

- 파싱 알고리즘

  - 일반적인 하향식, 상향식 파서로 파싱이 안됨. 그 이유는

    - 언어의 너그러운 속성
    - HTML 오류에 대한 브라우저의 관용
    - 변경에 의한 재파싱. document.write를 포함하고 있는 스크립트 태그는 토큰을 추가할 수 있기 때문에 실제로는 입력과정에서 파싱이 수정됨.

  - 파싱 알고리즘은 HTML 문서에 자세히 설명되어있다.

  - 알고리즘은 토큰화와 트리 구축으로 나누어져있음

  - 토큰화 : 어휘 분석으로서 입력값을 토큰으로 파싱함.

    - HTML 에서 토큰은 시작태그, 종료태그, 속성이름과 속성 값이다.

- 토큰화 알고리즘

  - State Machine으로 볼 수 있음.
  - 각 상태는 하나 이상의 연속된 문자를 입력받아 이문자에 따라 다음 상태를 갱신함.
  - 결과는 현재의 토큰화 상태와 트리 구축 상태의 영향을 받음.

- 트리구축 알고리즘

  - 트리 구축이 진행되는 동안 문서 최상단에서는 DOM 트리가 수정되고, 요소가 추가됨.
  - 토큰화에 의해 발행된 각 노드는 트리 생성자에 의해 처리됨.
  - 각 토큰을 위한 DOM 요소의 명세는 정의되어있다.
  - DOM 트리에 요소를 추가하는 것이 아니라면 열린 요소는 스택에 추가됨.
    - 부정확한 중첩과 종료되지 않은 태그를 교정함.
  - 알고리즘은 상태 기계라고 설명할 수 있고, 상태는 '삽입모드'라고 부른다.

- 파싱이 끝난 이후의 동작

  - 브라우저는 문서와 상호작용할 수 있게 됨.
  - '지연' 모드 스크립트를 파싱하기 시작함
  - 문서 상태는 '완료'가 되고, '로드' 이벤트가 발생한다.

- 브라우저의 오류처리

  - 브라우저는 HTML 의 모든 오류구문을 교정해준다.

  - 파서는 적어도 ㄷ음과 같은 오류를 처리해야함

    - 어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때, 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.
    - 파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다. HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.
    - 인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.
    - 이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.

  - ex)

    - \<br\> 대신 \</br\>
    - 어긋난 표
    - 중첩된 폼요소
    - 태그 중첩이 너무 깊을 때
    - 잘못 닫힌 html 또는 body 태그

- CSS 파싱

  - CSS는 문맥 자유 문법. 즉 위에서 설명한 파서로 파싱 가능하다.
  - 웹킷 CSS 파서 : 플렉스와 바이슨 파서 생성기 사용
  - 게코 : 하향식 파서 사용

- 스크립트와 스타일 시트 진행 순서
  - 스크립트
    - 웹은 파싱과 실행이 동시에 수행되는 동기화 모델임.
    - 제작자는 파서가 script 태그를 만나면 즉시 파싱하고 실행하기를 기대한다.
    - 스크립트가 실행되는 동안 문서의 파싱은 중단됨
    - 제작자가 스크립트를 '지연(defer)'로 표시하면 문서파싱은 중단되지 않고 문서 파싱이 완료된 이후에 스크립트가 실행된다.
    - HTML5는 스크립트는 비동기로 처리하는 속성을 추가했기 때문에 별도의 맥락에 의해 파싱되고 실행됨.
  - 예측 파싱
    - 스크립트를 실행하는 동안 다른 스레드는 네트워크로부터 다른 자원을 찾아 내려받고 문서의 나머지 부분을 파싱한다.
    - 예측 파서는 DOM 트리를 수정하지 않고 메인파서의 일로 넘긴다.
  - 스타일 시트
    - 이론적으로 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서파싱을 기다리거나 중단할 이유가 없음
    - 그러나 스크립트가 문서를 파싱하는 동안 스타일 정보를 요청하는 경우라면 문제가 됨.
    - 파이어폭스는 로드 중이거나 파싱 중인 스타일 시트가 있는 경우 모든 스크립트의 실행을 중단함.
    - 웹킷은 로드되지 않은 스타일 시트 가운데 문제가 될만한 속성이 있을 때에만 스크립트를 중단함.

## 렌더 트리 구축

- DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축함.

  - 표시해야 할 순서와 문서의 시각적인 구성요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적
  - 파이어폭스에선 "형상(Frame)"이라 부르고, 웹킷은 "렌더러" 또는 "렌더 객체"라고 부른다.

- 렌더러

  - 렌더러는 자신과 자식 요소를 어떻게 배치하고 그려내야하는지 알고 있음.

  - 웹킷 렌더러 기본 객체 : RenderObject 클래스

    ```java
    class RenderObject { virtual  
        void layout(); virtual
        void paint(PaintInfo); virtual
        void rect repaintRect();
        Node * node; //the DOM node
        RenderStyle * style; // the computed style
        RenderLayer * containgLayer; //the containing z-index layer
    }
    ```

    - 각 렌더러는 CSS2 명세에 따라 노드의 CSS 박스에 부합하는 사각형을 표시함.
    - 렌더러는 너비, 높이와 같은 기하학적 정보를 포함함.
    - 박스유형은 노드와 관련된 display 스타일 속성의 영향을 받는다.
    - 요소 유형도 고려해야함. 
      - ex) 폼 컨트롤과 표는 특별한 구조이다.
      - 요소가 특별한 렌더러를 만들어야 한다면 웹킷은 createRenderer 메서드를 무시하고 비기하학 정보를 포함하는 스타일 객체를 표시함.

- 

- 

