---
title: 데이터베이스 개요
author: 신성일
date: 2022-02-04 11:40:00 +0900
categories: [study, database]
tags: [db]
---

## **데이터베이스**

**파일시스템의 문제점**

- 앱과 상호 연동되어있기 때문에 다음과 같은 문제가 발생함.
  - 데이터 종속성
  - 데이터 중복성
  - 데이터 무결성

<br />

**데이터베이스 특징**

1. 데이터 독립성
   - 물리적 독립성 : 데이터베이스를 수정하더라도, 응용 프로그램을 수정할 필요는 없음
   - 논리적 독립성 : 하나의 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있음.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 것을 방지하기 위해, 데이터 유효성 검사를 통해 데이터 무결성을 구현함
3. 데이터 보안성
   - 인가된 사용자들만 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 보안을 구현할 수 있음.
4. 데이터 일관성
   - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터 불일치성을 배제할 수 있음.
5. 데이터 중복 최소화
   - 데이터를 통합하여 관리함으로써, 중복된 데이터를 최소화할 수 있다.

<br />

**데이터베이스 성능**

데이터베이스 성능 이슈는 디스크 I/O를 줄이는 것에서 시작함.

디스크 I/O는 디스크 헤더의 이동을 최소화해야 빨라짐. 따라서 순차 I/O가 랜덤 I/O보다 빠름.

따라서 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적

<br />

<br/>

## **정규화**

### **정규화를 하는 이유**

다음과 같은 이상현상을 해결하기 위해

- 삽입이상
- 삭제이상
- 수정이상

<br/>

### **정규화란?**

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 나쁜 릴레이션을 좋은 작은 릴레이션으로 분해하는 작업이다.

**정규화 조건**

- 분해되는 집합 D는 무손실 조인을 보장해야한다.
- 분해 집합 D는 함수적 종속성을 보존해야하낟.

<br/>

**제 1 정규형**

각 속성이 오직 `원자값`만을 포함하도록 하는 것.

**제 2 정규형**

모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 **완전 함수적 종속이면** 제 2 정규형을 만족한다고 볼 수 있다. 완전 함수적 종속이란 `X -> Y` 라고 가정했을 때, X 의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.

**제 3 정규형**

어떠한 비주요 속성도 기본키에 대해서 `이행 종속되지 않으면` 만족한다.

**BCNF 정규형**

여러 후보키가 존재하는 릴레이션에 해당하는 정규화 내용. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있음. 비주요 속성이 후보키의 일부를 결정하는 것을 분해하는 것.

<br/>

### **정규화의 장점**

1. 데이터의 이상현상을 제거할 수 있음
2. 데이터베이스 구조 확장 시 재디자인 최소화 정규화된 데이터베이스 구조에서는, 새로운 데이터형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용프로그램에 최소한의 영향만을 미친다.
3. 사용자에게 데이터 모델을 더욱 의미있게 제공.

<br/>

### **단점**

- 릴레이션이 분해되었으므로, 릴레이션간의 Join 연산이 많아진다. 이로인해 질의 응답이간이 느려질 수 있다.
- 하지만 데이터의 중복속성이 제거되고, 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있음.
- 따라서 정규화된 테이블은 데이터를 처리할때 속도가 빨라질 수도 있고, 느려질 수도 있는 특성이 있다.

<br/>

### **단점 대응책**

조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로인한 성능저하가 나타나는 경우에 반정규화를 적용해야한다.

**반정규화(비정규화)**

- `반정규화`는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다.
- 디스크 I/O 량이 많거나, 테이블끼리의 경로가 너무 멀어서 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.
- 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.

**반정규화의 대상**

1. 액세스 하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 테이블
2. 대량 데이터가 있고, 대량의 범위를 자주 처리하는데 성능상 이슈가 있는 테이블
3. 지나치게 많은 조인을 하여 데이터를 조회하는 것이 기술적으로 어려울 때

**반정규화의 주의점**

반정규화를 과도하게하면, 데이터의 무결성이 깨질수있음. 또한 입력, 수정, 삭제의 질의문에 대한 응답시간이 느려질 수 있음.

<br/>

<br/>

## **Transaction**

### **트랜잭션이란?**

하나의 논리적인 작업을 수행하는 쿼리문들을 묶은 것. 트랜잭션에 속한 쿼리문들은 모두 완벽히 수행되거나, 그렇지 않으면 원상복구해야한다.

<br/>

### **Lock**

트랜잭션을 동시에 수행할때, 동시성을 제어해주기 위한 기능. 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할

<br/>

### **트랜잭션의 특성**

**원자성** : 트랜잭션 수행중 문제가 발생하면, 트랜잭션의 어떠한 작업도 데이터베이스에 반영되면 안됨.

**일관성** : 트랜잭션이 완료된 다음의 상태에서도, 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야함.

**고립성** : 각 트랜잭션은 서로 간섭없이 독립적으로 수행되어야함.

**지속성** : 트랜잭션이 정상적으로 종료된 다음에는, 영구적으로 데이터베이스에 작업의 결과가 반영되어야함.

<br/>

### **트랜잭션의 상태**

![트랜잭션 상태 다이어그램](/assets/img/2022-02-04-database 개요/transaction-status.png)

- active
  - 트랜잭션이 실행중인상태
- failed
- partially committed
  - 트랜잭션의 commit 명령이 도착한 상태
  - 트랜잭션의 sql문은 다 수행되고 commit만 남은 상태
- committed
  - 트랜잭션 완료상태
- aborted
  - 트랜잭션 취소상태.
  - 데이터베이스는 트랜잭션이전으로 돌아간다.

<br/>

### **트랜잭션 사용 시 주의점**

트랜잭션의 범위는 최소화해야한다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이고, 따라서 각 트랜잭션이 커넥션을 소유하는 시간이 길어지면, 다른 트랜잭션은 커넥션을 가져가기 위해 기다려야하는 상황이 발생할 수 있기 때문이다.

<br/>

### **deadlock**

두 개 이상의 트랜잭션이 특정 사원의 잠금을 획득한 채, 다른 트랜잭션이 소유하고 있는 잠금을 요구하는 상황이 원형으로 이루어지고 있는 상태. 아무리 기다려도 잠금이 풀리는 일이 없는 상태이다.

**예시**

![classic deadlock](/assets/img/2022-02-04-database 개요/deadlock.png)

**교착상태의 빈도를 낮추는 방법**

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다.
- 읽기 잠금 획득의 사용을 피한다.
- 한 테이블의 복수행을 복수의 연결에서 순서없이 갱신하면 데드락이 발생하기 쉬움. 이때는 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지지만 데드락은 피할 수 있다.

<br/>

<br/>

## **NoSQL**

### **정의**

관계형 데이터 모델을 지양함. 대량의 분산된 데이터를 저장하고 조회하는데 특화되어있으며 스키마없이 사용가능하거나 느슨한 스키마를 제공하는 저장소.

종류마다 쓰기/읽기 특화, 2차인덱스 지원, 오토샤딩 지원 같은 고유한 특성을 가짐. 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시저장하고 응답하는 등의 방법을 사용함. 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터복제 등의 방법으로 RDBMS가 제공하지 못하는 성능과 특징을 제공한다.

<br/>

### **CAP이론**

어떠한 분산시스템도 아래 세가지를 모두 만족할 수 없다는 이론.

![image-20220206005652242](/assets/img/2022-02-04-database 개요/image-20220206005652242.png)

- RDBMS는 가용성과 일관성을 만족하고, 나머지를 만족할 수 없음
- NoSQL은 제품에 따라 다름.

<br/>

**1. 일관성(Consistency)**

다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미. RDBMS에서는 기본적으로 제공하나, 일관성을 지원하지 않는 NoSQL을 사용하면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있음.

느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 것을 의미한다.

NoSQL에서 분산 노드 간의 데이터 동기화를 위해 두가지 방법을 사용함.

1. 데이터의 저장결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법
   - 응답시간은 느리지만, 데이터의 정합성을 보여줌
2. 메모리나 임시파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법
   - 응답시간은 빠르지만, 쓰기 노드에 장애가 발생했을때 데이터가 손실될 수 있음.

**2. 가용성(Availability)**

모든 클라이언트의 읽기와 쓰기 요청에 대해 항상 응답이 가능해야함을 보증하는 것. 가용성을 가진 NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도, 정상적인 서비스가 가능함.

몇몇 NoSQL은 가용성을 보장하기 위해 데이터 복제를 사용함. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대가 고장나도 데이터가 유실되지 않도록 하는 것. 데이터 중복 저장 방법에는 동일한 데이터를 가진 저장소를 하나 더 생성하는 Master-slave와 데이터 단위로 중복저장하는 peer-to-peer 방법이 있다.

**3. 네트워크 분할 허용성(partition tolerance)**

지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서, 두 지역간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역내의 시스템은 정상적으로 동작해야함을 의히함.

<br/>

### **저장 방식에 따른 NoSQL 분류**

**Key-value model**

키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 가짐. 단순한 저장구조이며, 복잡한 조회연산을 지원하지 않는다. 따라서 고속읽기와 쓰기에 최적화되어있다.

사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션정보, 장바구니 정보, URL 단축 정보저장 등에 사용된다.

하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 있음

Redis 등이 있음

**Document model**

key-value의 확장. 하나의 키에 구조화된 문서를 저장하고 조회하는 방식. 논리적인 데이터 저장과 조회 방법이 RDBMS와 유사함.

키는 문서에 대한 id로 표현됨. 또한 저장된 문서를 컬렉션으로 관리하여 문서 저장과 동시에 문서id에 대한 인덱스를 생성한다. 문서 id에 대한 인덱스를 사용하여 O(1) 시간안에 문서를 조회할 수 있다.

대부분의 문서모델 NoSQL은 B트리 인덱스를 사용하여 2차인덱스를 생성한다. B트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일때 가장 좋은 성능을 보인다.

중앙 집중식 로그 저장, 타임라인 저장, 통계정보저장 등에 사용된다.

MongoDB 등이 있음

**Column model**

하나의 키에 여러개의 컬럼이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회하낟. 모든 컬럼은 항상 타음스탬프 값과 함께 저장된다.

구글의 빅테이블이 대표적인 예로, 차후 컬럼형 NoSQL은 빅테이블의 영향을 받았다. Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집합이 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

컬럼모델 NoSQL은 쓰기에 더 특화되어있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다.

채팅 내용저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.

## 출처

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4
