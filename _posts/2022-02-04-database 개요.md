---
title : 데이터베이스 개요
author : 신성일
date : 2022-02-04 11:40:00 +0900
categories : [cs, database]
tags: [데이터베이스]
---



## **데이터베이스**

**파일시스템의 문제점**

- 앱과 상호 연동되어있기 때문에 다음과 같은 문제가 발생함.
  - 데이터 종속성
  - 데이터 중복성
  - 데이터 무결성

<br />

**데이터베이스 특징**

1. 데이터 독립성
   - 물리적 독립성 : 데이터베이스를 수정하더라도, 응용 프로그램을 수정할 필요는 없음
   - 논리적 독립성 : 하나의 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있음.
2. 데이터의 무결성
   - 여러 경로를 통해 잘못된 데이터가 발생하는 것을 방지하기 위해, 데이터 유효성 검사를 통해 데이터 무결성을 구현함
3. 데이터 보안성
   - 인가된 사용자들만 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 보안을 구현할 수 있음.
4. 데이터 일관성
   - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터 불일치성을 배제할 수 있음.
5. 데이터 중복 최소화
   - 데이터를 통합하여 관리함으로써, 중복된 데이터를 최소화할 수 있다.

<br />

**데이터베이스 성능**

데이터베이스 성능 이슈는 디스크 I/O를 줄이는 것에서 시작함.

디스크 I/O는 디스크 헤더의 이동을 최소화해야 빨라짐. 따라서 순차 I/O가 랜덤 I/O보다 빠름.

따라서 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적



<br />

<br />

## Index

### **인덱스란?**

DBMS에서 데이터베이스 테이블의 모든 데이터를 검색하여 데이터를 찾기에는 시간이 오래 걸리기에, 데이터의 칼럼의 값과 그 데이터가 저장된 레코드의 주소를 키와 값의 쌍으로 만든 것.

DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에, 원하는 값을 탐색하는데는 빠르지만, 추가/삭제/수정에는 쿼리문 실행 속도가 느려진다.(작업 후 다시 정렬해야하기에)

결과적으로 DBMS의 인덱스는 데이터 저장 성능을 희생하고, 읽기 성능을 높이는 기능이다. 따라서 모든 컬럼을 대상으로 인덱스를 생성하면 데이터 저장 성능이 떨어지고, 인덱스의 크기가 비대해지기에 역효과가 난다.

<br />

### **Index 자료구조**

**B +- Tree 인덱스 알고리즘** 

일반적으로 사용되는 알고리즘. 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.

**Hash 인덱스 알고리즘**

컬럼의 값으로 해시 값을 계산하여 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원함. 하지만 값을 변경하여 인덱싱하므로, 값의 일부만으로 검색하고자 할때는 해시 인덱스를 사용할 수 없음.

주로 메모리 기반의 데이터베이스에서 많이 사용함.

**B 트리를 자주 사용하는 이유**

SELECT 질의의 조건에는 부등호 (<>) 연산도 포함됨. 해시 인덱스를 사용하면 이러한 부등호 연산에 문제가 생긴다. 왜냐하면 해시는 동등(=) 연산에 특화되어있기 때문이다.

<br />



### **클러스터드 인덱스**

물리적으로 인접한 장소에 있는 데이터들을 동시에 조회하는 경우가 많으므로(spatial locality), 인접한 것들을 묶어 저장하는 방식의 인덱스

이때 클러스터드 인덱스는 테이블의 primary key에 대해서만 적용된다. 즉 primary key가 비슷한 레코드끼리 묶어 저장한 것을 클러스터드 인덱스라고 표현함. 클러스터드 인덱스에서는 primary key에 의해 레코드의 저장 위치가 결정되며 primary key가 변경되면 레코드의 물리적인 저장위치 또한 변경되어야한다. 따라서 클러스터드 인덱스에서는 primary key를 신중하게 결정해야한다.

클러스터드 인덱스는 테이블 당 한개만 생성할 수 있음(primary key에 대해 적용되기에). non 클러스터드 인덱스는 테이블당 여러개의 인덱스를 만들 수 있음  



<br />

### **Composite index**

여러개의 필드로 구성하는 인덱스. 이때 인덱스로 설정하는 필드의 속성이 중요하다. 

title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.



<br/>

### **Index 의 성능과 고려해야할 사항**

인덱스가 많아지면 SELECT는 빨라지지만, INSERT/DELETE/UPDATE는 느려진다.

INSERT는 인덱스에 대한 데이터도 추가해야하기에 성능 저하가 발생하고, DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용안한다는 표시로 남게 된다. 즉 row는 그대로인데, 실제 데이터는 줄어든 것이다. 극단적으로 실제 데이터는 10만개인데, 데이터는 100만개가 있을 수 있다. 이때는 인덱스를 사용하는 이유가 없어진다. UPDATE는 INSERT와 DELETE의 문제가 동시에 발생한다.

또한 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재한다. 예를들어, `이름`, `나이`, `성별` 세 가지의 필드가 있을때, 이름에 대해서는 인덱스가 효율적이고 나이,성별에 대해서는 그렇지 않다. 왜냐하면, 데이터의 범위가 작기때문에 겹치는 인덱스가 많아지고 되고, 따라서 추가적으로 원하는 데이터를 다시 검색해야하기 때문이다.

<br/>

<br/>

## **정규화**



## 출처

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4