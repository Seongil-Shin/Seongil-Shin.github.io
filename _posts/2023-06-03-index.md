---
title: DB index
author: 신성일
date: 2023-06-03 16:00:00 +0900
categories: [study, database]
tags: [db]
---

## 

### **인덱스란?**

DBMS에서 데이터베이스 테이블의 모든 데이터를 검색하여 데이터를 찾기에는 시간이 오래 걸리기에, **데이터의 칼럼의 값과 그 데이터가 저장된 레코드의 주소를 키와 값의 쌍**으로 만든 것.

DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에, 원하는 값을 탐색하는데는 빠르지만, 추가/삭제/수정에는 쿼리문 실행 속도가 느려진다.(작업 후 다시 정렬해야하기에)

결과적으로 DBMS의 인덱스는 데이터 저장 성능을 희생하고, 읽기 성능을 높이는 기능이다. 따라서 모든 컬럼을 대상으로 인덱스를 생성하면 데이터 저장 성능이 떨어지고, 인덱스의 크기가 비대해지기에 역효과가 난다.

<br/>

### **Index 의 성능과 고려해야할 사항**

인덱스가 많아지면 SELECT는 빨라지지만, INSERT/DELETE/UPDATE는 느려진다. 이유는 인덱스에서 mutation 작업시 다음과 같은 일이 발생하기 떄문이다.

- INSERT: 새로운 데이터에 대한 인덱스를 추가함. 이후 다시 데이터 정렬.
- DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 표시를 함
- UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

UPDATE, DELETE 작업에서 기존의 인덱스를 그대로 두기에, mutation 작업이 빈번히 발생하면 테이블 로우는 10개인데 인덱스는 100개인 상황이 발생할 수 있다.

또한 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재한다. 예를들어, `이름`, `나이`, `성별` 세 가지의 필드가 있을때, 이름에 대해서는 인덱스가 효율적이고 나이,성별에 대해서는 그렇지 않다. 왜냐하면, 데이터의 범위가 작기때문에 겹치는 인덱스가 많아지고 되고, 따라서 추가적으로 원하는 데이터를 다시 검색해야하기 때문이다.

<br />

### **Index 자료구조**

**B +- Tree 인덱스 알고리즘**

일반적으로 사용되는 알고리즘. 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘이다.

**Hash 인덱스 알고리즘**

컬럼의 값으로 해시 값을 계산하여 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원함. 하지만 값을 변경하여 인덱싱하므로, 값의 일부만으로 검색하고자 할때는 해시 인덱스를 사용할 수 없음.

주로 메모리 기반의 데이터베이스에서 많이 사용함.

**B 트리를 자주 사용하는 이유**

SELECT 질의의 조건에는 부등호 (<>) 연산도 포함됨. 해시 인덱스를 사용하면 이러한 부등호 연산에 문제가 생긴다. 왜냐하면 해시는 동등(=) 연산에 특화되어있기 때문이다.

<br />

### **클러스터드 인덱스**

물리적으로 인접한 장소에 있는 데이터들을 동시에 조회하는 경우가 많으므로(spatial locality), 인접한 것들을 묶어 저장하는 방식의 인덱스

이때 클러스터드 인덱스는 테이블의 primary key에 대해서만 적용된다. 즉 primary key가 비슷한 레코드끼리 묶어 저장한 것을 클러스터드 인덱스라고 표현함. 클러스터드 인덱스에서는 primary key에 의해 레코드의 저장 위치가 결정되며 primary key가 변경되면 레코드의 물리적인 저장위치 또한 변경되어야한다. 따라서 클러스터드 인덱스에서는 primary key를 신중하게 결정해야한다.

클러스터드 인덱스는 테이블 당 한개만 생성할 수 있음(primary key에 대해 적용되기에). non 클러스터드 인덱스는 테이블당 여러개의 인덱스를 만들 수 있음

<br />

### **Composite index**

여러개의 필드로 구성하는 인덱스. 이때 인덱스로 설정하는 필드의 속성이 중요하다.

title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.

<br/>