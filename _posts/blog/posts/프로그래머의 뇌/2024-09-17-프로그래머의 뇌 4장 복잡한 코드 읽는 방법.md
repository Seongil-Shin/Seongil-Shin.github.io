---
title: 프로그래머의 뇌 4장 복잡한 코드 읽는 방법
author: 신성일
date: 2024-09-17 19:00:00 +0900
categories: study, 프로그래머의 뇌
tags:
  - "#study"
---

코드가 혼란스러운 이유는 다음 세가지다
1. STM에 저장되어 있어야 할 정보가 부족하기에 (2장)
2. LTM에 저장되어 있는 지식이 부족하기에 (3장)
3. 두뇌의 처리 능력부족

1,2번에 대해서는 이미 배웠다. 하지만 코드가 너무 복잡하여 많은 문법 지식과 효율적인 청킹으로도 코드를 이해하기 어려울 때가 있다.

이번 장에서는 두뇌에서 처리하는 능력인 `작업 기억 공간`의 기저에 있는 인지 과정을 알아보자. 


## 4.1 복잡한 코드를 이해하는 것이 왜 어려울까?

작업 기억 공간은 두뇌가 생각하고 새로운 아이디어를 형성하고 문제를 해결하는 능력에 해당한다. (두뇌의 프로세서와 같은 역할)

### 작업 기억 공간과 STM의 차이

이 책에서는 두가지 개념을 구분하여 사용한다. STM은 정보를 기억하고, 작업 기억 공간은 정보를 처리한다
- 전화번호를 기억한다 -> STM
- 두 정수를 더하는 일을 한다 -> 작업 기억 공간

 STM와 같이 작업 기억 공간도 2~6개까지만 기억할 수 있다. 이 용량을 `인지 부하`라고 한다. 너무 많은 요소가 있어 청크로 나뉘지 않는 문제를 풀려고 할 때 작업 기억 공간은 `과부화` 상태가 된다.

### 프로그래밍과 관련된 인지 부하의 종류

존 스웰러는 인지 부하를 세가지로 구별했다
- 내재적 : 문제 자체가 얼마나 복잡한지
- 외재적 : 외부적 요인(문제 표현 방식 등)에 의해 문제에 복잡성이 추가된 것
	- 사람에따라 다르게 다가오며 많이 접할수록 인지 부하는 적어진다
- 본유적 : 생각을 LTM에 저장하는 과정에서 일어나는 인지부하


## 4.2 인지 부하를 줄이기 위한 기법

외재적 인지 부하를 줄이기 위한 기법들

### 리팩터링

대개의 경우 리팩터링은 유지보수성을 높이지만 그렇다고 가독성이 좋아지지는 않는다 (ex : 중복 코드를 하나의 메서드로 합치면, 유지보수에는 좋지만 읽을땐 매번 함수 내부 구현을 찾아봐야함)

따라서 유지보수하기 좋은 코드보다는 장기적으로 가독성이 좋도록 리팩터링을 할 수 있는데 이를 `인지적 리팩터링`이라고 한다. 

이러한 `인지적 리팩터링`은 때때로 역 리팩터링을 수반하여 유지보수성을 낮출수도 있다. 
- 예를들어 메서드를 인라인으로 구현할수도 있는데, 이는 유지보수성을 낮추지만 가독성은 올라간다. 
- 코드 내에서 메서드의 순서를 변경하는 방법도 있다

사람마다 리팩터링하는 내용이 다르기에 인지적 리팩터링은 자신만을 위한 리팩터링이다. **많은 경우 인지적 리팩터링은 일시적이고 자신이 코드를 이해하는 것이 목적이기에 일단 이해하고 나면 코드를 원래 상태로 되돌릴수도 있다.**


### 생소한 언어 구성 요소를 다른 것으로 대치하기

어떤 상황에서는 익숙하지 않은 프로그래밍 언어의 구성 요소를, 그것과는 다르지만 좀 더 익숙한 방식으로 표현할 수 있다
-  ex) 람다와 리스트 컴프리헨션은 간단하고 가독성 높지만, 많은 프로그래머는 익숙하지 않으며 for/while에 더 익숙하다

간단하면 문제가 없지만, 코드가 복잡해지면 이렇게 생소한 언어 구성 요소는 작업 기억 공간에 부하를 발생시킨다. 따라서 이러한 요소를 좀 더 기본적인 문법을 사용하여 구현하면 부하를 줄이는데 도움이 된다.
- 람다
- 리스트 컴프리헨션
- 삼항연산자

람다 등을 풀어서 기본적인 문법으로 구현하는 것은 이상해보일 수 있으나, 가독성을 높인다는 것은 사람의 눈에 읽기 편하다는 것을 의미한다. 무엇이 읽기 편한지는 사람에따라 다르다. 

이 리팩터링도 마찬가지로 잠시 바꿔놨다가 이해하고 나면 원래대로 돌릴 수도 있다


### 플래시카드에 코드 동의어 추가

코드를 이해하기 위해 임시로 코드를 수정할 수 있지만, 그렇게는 한계가 있다. 이럴때는 플래시카드를 이용하여 이해가 잘 가지 않는 요소를 익힐 수 있다.
- 앞면 : "C++에서 0에서 10까지 모든 숫자를 프린트한다"
- 뒷면 : `for (int i = 0; i<=10; i++) { cout << i << "\n"; }`


## 4.3 작업 기억 공간에 부하가 오면 쓸 수 있는 기억 보조 수단

리팩터링만으로는 부족할 수 있다. 복잡한 구조의 코드는 두가지 방식으로 작업 기억 공간에 과부하를 유발한다

- 정확히 코드의 어디를 파악해야할지 모를때 -> 필요이상으로 많은 코드를 읽게 되어 작업 기억 공간의 과부하를 발생시킬 수 있음
- 코드가 서로 밀접하게 연결되어 있는 경우 두뇌는 두가지 작업을 동시에 수행함.

코드를 여러번 연속해서 읽어도 이해되지 않는다면 보조 수단을 사용해보는 것도 좋다

- 의존 그래프 : 변수, 메서드, 클래스의 관계를 그래프처럼 나타낸 것
- 상태표 : 변수의 값이 코드의 각 단계별로 어떻게 변하는지 기록하는 것. 계산 로직이 복잡할 때 사용 가능



## 요약

인지 부하에는 내재적, 외재적, 본유적이 있다.
외재적 인지부하를 줄이기 위해서는 리팩터링, 구성 요소 변경, 보조 수단을 사용하여 코드를 더 잘 이해하게 만들 수 있다.