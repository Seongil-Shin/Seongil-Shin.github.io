[ { "title": "Node.js", "url": "/posts/Node.js/", "categories": "study,, node", "tags": "#study", "date": "2024-12-29 19:00:00 +0900", "snippet": " Javascript를 브라우저 밖에서도 실행할 수 있도록 하는 Javascript의 런타임node.js를 접하다보면 자주 나오는 말은 다음과 같다 이벤트 기반 싱글 쓰레드 논블로킹 모델1. 이벤트 기반node.js는 이벤트 리스너에 등록해둔 콜백함수를 실행하는 방식으로 동작한다.router.get(&quot;/&quot;, (req, res, next) =&amp;gt; {})이러한 이벤트 기반 모델에서는 이벤트에 따라 호출되는 콜백함수를 관리하는 것이 “이벤트 루프”이다. (브라우저의 이벤트 루프와는 다름)이벤트 루프..." }, { "title": "Typescript", "url": "/posts/Typescript/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": " Typescript 속도 개선" }, { "title": "Typescript 속도 개선", "url": "/posts/Typescript-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "https://youtu.be/g9FL8hKoNqE?si=tsCYUjwOX5Z0AqZk분석Typescript 옵션으로 성능 문제 진단 extendedDiagnostics 로 대략적인 컴파일 시간 확인 가능 generateTrace 로 트레이스 파일을 출력할 수 있음. 이 파일을 툴에 넣어 확인 가능 trace.json : 컴파일에 소요된 시간 중 오래 걸리는 부분을 출력. types.json : 컴파일러가 인식한 타입의 목록을 출력. 툴을 사용해서 성능 문제 진단 @typescript/a..." }, { "title": "React", "url": "/posts/React/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "" }, { "title": "React 규칙", "url": "/posts/React-%EA%B7%9C%EC%B9%99/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "https://ko.react.dev/reference/rules관용적인 React 코드를 작성하기 위한 규칙들. 이러한 규칙을 지키면 변화에 더 잘 대처할 수 있고, 다른 라이브러리, 도구, 개발자와의 협업이 원활해진다. 만약 어길 경우 어플리케이션에 버그가 생길 가능성이 높고, 일반적이지 않게 변한다.React 규칙을 따르기 쉽게하기 위해 ESLint 플러그인과 함께 Strict Mode를 사용하는 것이 권장된다.컴포넌트와 Hooks는 순수해야한다 컴포넌트는 멱등해야한다. 사이드 이펙트는 렌더링 외부에서 실행되어야한다...." }, { "title": "React context", "url": "/posts/React-Context/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "상태 업데이트 시 해당 컴포넌트만 업데이트?" }, { "title": "React compiler", "url": "/posts/React-Compiler/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "1. 정의빌드 시 적용되는 도구로, [[React]]를 자동으로 최적화해준다. 관련 eslint 플러그인도 제공하여 코드 품질을 높이는데 사용할 수 있다.1.1 무엇을 하는가?기존에는 useMemo, useCallback, React.memo 와 같은 API 로 직접 메모이제이션하였다. 하지만 개발하다보면 이를 잊어버릴수 있다.리액트 컴파일러는 자동으로 컴포넌트와 Hooks 내의 값 또는 값 그룹을 메모이제이션 한다. 만약 JS나 React 규칙을 위반한 경우에는 해당 컴포넌트 또는 Hooks를 건너뛰고 다른 코드를 컴파일한다..." }, { "title": "Next.js", "url": "/posts/next.js/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "" }, { "title": "Js 알고리즘 팁", "url": "/posts/JS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%81/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": " 첫번째처럼 할 경우 모든 요소에 같은 배열의 참조가 들어감```js// badvar arr = new Array(1000).fill(new Array())// goodvar arr = new Array(1000).fill(0).map(() =&amp;gt; []);- dfs 와 같이 함수를 깊이 탐색해야할때 런타임 오류가 발생하면, 재귀함수가 아닌 반복문으로 dfs 구현해야함- 진수변환```js// 문자열 -&amp;gt; 숫자var num = parseInt(&quot;12341&quot;, 4); // (문자열, 진수)..." }, { "title": "Next.js 최대 connection", "url": "/posts/next.js-%EC%B5%9C%EB%8C%80-Connection/", "categories": "", "tags": "", "date": "2024-12-29 00:00:00 +0900", "snippet": "현상 : https://seongil-shin.github.io/posts/next.js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B3%BC%EC%A0%95/의문 이슈가 발생할떄 정적페이지에도 응답이 안가나? API 요청이 있는 페이지만 안가나? 아니면 이슈 발생하는 페이지만 안가나? 이슈가 발생하는건 외부 API가 느려져서인데 HPA가 의미가 있나?추측 최대 요청 연결 가능 갯수가 있어서 해당 갯수 이상으로 요청이 hang 되면 정적페이지..." }, { "title": "You don&#39;t know JS Yet 2부 - Appendix", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-Appendix/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-12-15 19:00:00 +0900", "snippet": "A.1 암시적 스코프스코프는 가끔 명확하지 않은 위치에 생성된다. 일반적으론 이러한 암시적 스코프가 작동에 영향을 주진않는데, 알고 있으면 유용하다. 매개변수 스코프 함수명 스코프매개변수 스코프함수 매개변수는 함수 스코프에서 지역으로 선언한 변수와 동일하다고 하였지만, 항상 그렇지는 않다.아래와 같이 단순한 매개변수 형태는 함수 스코프와 매개변수 스코프가 같다.function getStudentName(studentId) {}하지만 기본값이 있는 매개변수, …을 사용하는 나머지 매개변수, 비구조화 매개변수의 경우에는 매개변..." }, { "title": "You don&#39;t know JS Yet 2부 - 8장 모듈 패턴", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-8%EC%9E%A5-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-12-11 19:00:00 +0900", "snippet": "8.1 캡슐화와 최소 노출의 원칙(POLE)캡슐화의 목표는 정보(데이터)와 동작(함수)를 한데 묶거나 함께 배치에 공통의 목적을 달성하는 것이다. 이러한 캡슐화는 공통의 목적을 가진 코드 일부분을 별도의 파일로 옮기는 것만으로도 실현할 수 있다.캡슐화의 또 다른 목표는 캡슐화된 데이터와 함수의 특정 측면의 가시성을 제어하는 것이다. 캡슐화의 주요 아이디어는 비슷한 코드를 그룹화하고, 공개하고 싶지 않은 세부사항은 접근을 선택적으로 제한하는 것이다. (private, public 등)이런 노력을 기울이다보면 자연스럽게 코드를 체..." }, { "title": "State of frontend 2024", "url": "/posts/State-of-frontend-2024/", "categories": "study,, article", "tags": "#study", "date": "2024-12-10 19:00:00 +0900", "snippet": "https://tsh.io/state-of-frontend/#dataChapter 3. Teams &amp;amp; Technology02. Frameworks svelte 는 순풍중인거 같고 vue.js 는 생각보다 잘나가는듯 프레임워크는 Astro, Nuxt, Sveltekit, Remix 가 배울만 한거 같고, astro 가 생각보다 잘나가는듯03. Libraries validation : zod 배워보자 date management : date-fns, Day.js, moment 많이 씀. moment는 성능상 ..." }, { "title": "You don&#39;t know JS Yet 2부 - 7장 클로저 사용법", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-7%EC%9E%A5-%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%82%AC%EC%9A%A9%EB%B2%95/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-12-09 19:00:00 +0900", "snippet": "클로저는 최소 노출의 원칙 (POLE)을 기반으로 한다. 변수를 오랫동안 유지해야하는 경우 클로저를 사용하면 변수를 외부 스코프에 두는 대신 더 제한된 스코프로 캡슐화 할 수 있다.함수 내부에서 함수 밖 해당 변수에 계속 접근할 수 있어 변수를 더 넓은 범위에서 사용할 수 있는 이점이 있다.7.1 클로저 관찰하기 클로저는 함수에서만 일어나는 함수의 동작이다 클로저를 관찰하려면 함수를 반드시 호출해야한다 호출한 함수는 해당 함수를 정의한 스코프 체인이 아닌 다른 분기에서 호출되어야한다 클로저는 함수 인스턴스에 따라 다르게..." }, { "title": "빌드 시스템 없이 프런트엔드 자바스크립트 라이브러리 불러오기", "url": "/posts/%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%97%86%EC%9D%B4-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/", "categories": "study,, js", "tags": "#study", "date": "2024-12-05 19:00:00 +0900", "snippet": "번역, 원문세가지 종류의 자바스크립트 파일라이브러리가 제공할 수 있는 3가지 기본 자바스크립트 파일 클래식 유형. &amp;lt;script src&amp;gt;로 추가해 바로 사용할 수 있음 ES 모듈 (다른 파일에 의존할 수 있음) CommonJS. 빌드 시스템 없이는 브라우저에서 사용할 수 없음이때 라이브러리들은 빌드를 생성해 보통 npm 에 업로드한다. 이 업로드된 파일들 중에 위 세가지 유형이 포함되어있다.정리 클래식 JS 파일 식별 방법 가이드에 CDN으로 사용하..." }, { "title": "You don&#39;t know JS Yet 2부 - 6장 스코프 노출 제한", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-6%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84-%EB%85%B8%EC%B6%9C-%EC%A0%9C%ED%95%9C/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-12-02 19:00:00 +0900", "snippet": "어떻게, 왜 함수와 블록을 사용해 프로그램 내 변수를 다양한 스코프로 구성해야하는지6.1 최소 노출의 원칙 (POLE)정보보안분야의 최소 권한의 원칙(POLP)처럼, 변수를 최소한의 블록에만 노출해야한다는 최소 노출의 원칙(POLE)을 적용할 수 있다.만약 모든 변수를 전역 스코프에 등록하게 되면 아래와 같은 문제가 발생한다. 이름 충돌 예기치 않은 동작 : 어떤 변수가 쓰이면 안되는 곳에서 쓰여져 의도치 않게 값을 변경하거나 사용하게 될 수 있음. 개인 정보를 담고 있는 변수나 함수가 제한을 뚫고 사용될 수도 있음. 의..." }, { "title": "You don&#39;t know JS Yet 2부 - 5장 변수의 비밀 생명주기", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-5%EC%9E%A5-%EB%B3%80%EC%88%98%EC%9D%98-%EB%B9%84%EB%B0%80-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/", "categories": "study", "tags": "#study", "date": "2024-11-30 19:00:00 +0900", "snippet": "변수 선언 위치에 따른 작동 방식의 차이와 사용 여부5.1 변수 사용 가능 시점모든 식별자는 컴파일 타임 때 각자의 스코프에 등록된다. 또 모든 식별자는 자신이 속한 스코프가 생성될 때 해당 스코프의 시작 부분에서 생성된다.이렇게 선언은 스코프 아래에 있더라도 스코프 시작부분에서 변수의 가시성이 확보되는 걸 호이스팅이라고 한다.하지만 가시성을 넘어 함수의 경우 실제로 실행이 되기도 하는데, 이는 함수 호이스팅 때문이다. 함수 선언문으로 함수를 선언하면 함수 이름에 해당하는 식별자가 스코프 최상단에 등록되고, 함수 참조로 그 값..." }, { "title": "You don&#39;t know JS Yet 2부 - 4장 전역 스코프", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-4%EC%9E%A5-%EC%A0%84%EC%97%AD%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-30 19:00:00 +0900", "snippet": "JS 프로그램에서 전역스코프는 우리 생각보다 많은 유용한 기능을 제공하며, 여타 스코프와는 다른 미묘한 차이가 있다.이번 장에서는 전역스코프가 어떻게 유용한지, JS 호스트 환경에서 전역 스코프는 어디에 있고 어떻게 접근하는지 알아보자4.1 전역 스코프를 배워야하는 이유JS 엔진은 분리된 여러 개의 파일을 실행 시점에 하나로 연결시킨다. 이때 브라우저에서 실행되는 어플리케이션은 주로 세가지 방법을 사용한다 ES 모듈 : 파일을 하나씩 로딩하여, import 문으로 참조한다. 이때 각 모듈을 서로의 스코프를 공유하지 않고 베타..." }, { "title": "You don&#39;t know JS Yet 2부 - 3장 스코프 체인", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-3%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-29 19:00:00 +0900", "snippet": "스코프 체인 : 스코프와 중첩 스코프 사이에 맺어진 연결. 변수 접근 시 사용할 경로가 스코프 체인을 통해 결정된다. 이때 체인은 변수 탐색 경로가 위 혹은 바깥으로만 향하도록 지시 받는다.3.1 탐색의 진실우리는 어떤 변수가 어느 스코프에 있는지 상위스코프로 탐색해나간다고 생각하지만, 실제 동작방식은 다르다. 실제로는 컴파일 초기에 이미 어떤 스코프에 있는 변수인지 결정된다. 렉시컬 스코프가 컴파일 초기에 확정되기 때문이다.따라서 프로그램 실행시 JS 엔진은 변수를 탐색할 필요가 없고, 이미 저장된 정보를 꺼내어 쓰면 되기에..." }, { "title": "You don&#39;t know JS Yet 2부 - 2장 렉시컬 스코프", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-2%EC%9E%A5-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-28 19:00:00 +0900", "snippet": "컴파일 중 JS 엔진은 스코프의 지도를 완성한다. 이를 렉시컬 스코프라고하며 이때 렉시컬은 컴파일의 첫번째 단계인 렉싱을 의미한다.이번 장에서는 스코프를 더 잘 이해하고, 이를 위해 JS 엔진이 프로그램을 처리하는 방법을 살펴보자2.1 구슬과 양동이변수가 어느 스코프에 들어가는지를 구슬이 어느 양동이에 들어가는지로 비유해서 설명함 스코프는 부모 스코프에 온전히 포함되기에 한 스코프가 두 개의 바깥 스코프에 동시에 포함되는 일은 일어나지 않는다 각 변수는 어디에서 정의되었느냐에 따라 들어갈 곳이 결정되며, 어디서 접근가능한지..." }, { "title": "You don&#39;t know JS Yet 2부 - 1장 스코프", "url": "/posts/You-don't-know-JS-Yet-2%EB%B6%80-1%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-26 19:00:00 +0900", "snippet": "JS에서 함수는 일급값이기에 변수에 할당할 수 있고, 다른 곳에 넘길수도 있다. 그런데 다른 곳으로 넘어간 함수 내에서 외부 변수를 사용하는 경우, 해당 변수는 어딘가에 접근해야하므로 JS 에서는 함수를 프로그램 내 어디에서 실행하든 상관없이 함수 정의시 결정된 스코프를 유지한다. 이를 클로저라고 한다1.2 컴파일 vs 인터프리트컴파일 : 텍스트 형식으로 작성한 코드를 처리해서 컴퓨터가 이해할 수 있는 작업 지시 목록으로 바꾸는 일련의 과정. 이 과정은 전체 소스코드에 걸쳐 한번만 발생한다.인터프린트 : 컴파일처럼 프로그램을 ..." }, { "title": "Blob vs File 차이점 이해하기", "url": "/posts/Blob-vs-File-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/", "categories": "study,, article", "tags": "#study", "date": "2024-11-24 19:00:00 +0900", "snippet": "https://jsdev.space/file-blob-js/BlobBlob는 raw binary data (file, images, videos, non-text data 등)를 다루기 위해 주로 사용되는 자바스크립트 불변 객체이다특징 불변성 : 한번 만들면 수정이 불가능하다. 다른 데이터와 합쳐서 새로운 Blob를 만드는 것은 가능하다 Data Representation : 어떤 타입의 데이터도 다룰수 있다. 보통 웹 어플리케이션에서 이진 데이터를 다루기 위해 사용된다 size, type 이라는 두가지 속성이 존재한다 ..." }, { "title": "You don&#39;t know JS Yet - 1권 부록", "url": "/posts/You-don't-know-JS-Yet-1%EA%B6%8C-%EB%B6%80%EB%A1%9D/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-24 19:00:00 +0900", "snippet": "AppendixA.1 값 vs 참조다른 언어에서는 값 자체를 할당, 전달할지 값의 참조를 할당, 전달할지 선택할 수 있게 하는 경우가 많다. 하지만 JS에서는 이 과정이 오로지 값의 타입으로만 결정된다. 원시타입 : 값이 복사됨 객체 (객체, 배열, 함수 등) : 참조로 처리됨이러한 작동방식을 변경할 수 있는 방법은 없다A.2 다양한 형태의 함수다음과 같은 함수 표현식은 익명 함수 표현식이라고 한다.var someFunction = function() {}console.log(someFunction.name) // &quo..." }, { "title": "You don&#39;t know JS Yet - 4장 더 큰 그림", "url": "/posts/You-don't-know-JS-Yet-4%EC%9E%A5-%EB%8D%94-%ED%81%B0-%EA%B7%B8%EB%A6%BC/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-20 19:00:00 +0900", "snippet": "4.1 첫 번째 기둥: 스코프와 클로저렉시컬 스코프 모델 : 스코프의 기준과 그 경계, 경계 안에서 변수가 어떻게 구성되는지 프로그램을 파싱할때 결정되는 모델. (= 개발자가 스코프를 어디에 배치하냐에 따라 달라지는 모델)JS는 렉시컬 스코프 모델을 채택하고 있지만, 여타 언어와 다른 두 가지 특징을 더 갖는다 호이스팅 var 로 선언한 변수는 블록이 아닌 함수 기준으로 스코프가 만들어진다는 점이 두가지 특징이 있지만 JS는 렉시컬 스코프 모델을 사용한다고 할수 있다. 클로저 또한 JS가 함수를 일급객체로 다루는 렉시컬 스..." }, { "title": "You don&#39;t know JS Yet - 3장 자바스크립트 뿌리 파헤치기", "url": "/posts/You-don't-know-JS-Yet-3%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%BF%8C%EB%A6%AC-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-17 19:00:00 +0900", "snippet": "3.1 이터레이션이터레이터 패턴 : 데이터를 일정 단위로 쪼개고, 이 조각들을 차례로 순회하며 점진적으로 처리하는 표준화된 방법 처리할 데이터를 참조하는 데이터 구조인 이터레이터가 정의되어야함 next() 메서드 : 데이터 조각을 차례로 반환하는 메서드 매 호출마다 value, done 프로퍼티를 제공함. 반복작업이 종료되었을 경우 done 은 true로 세팅됨 이터레이터 소비자 (consumer) next() 메서드 호출 for...of 반복문 : ES6에서 추가된 문법 ... : ..." }, { "title": "You don&#39;t know JS Yet - 2장 자바스크립트 조망하기", "url": "/posts/You-don't-know-JS-Yet-2%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A1%B0%EB%A7%9D%ED%95%98%EA%B8%B0/", "categories": "study,, YDKJSY", "tags": "#study", "date": "2024-11-04 19:00:00 +0900", "snippet": "2.1 파일은 프로그램입니다웹사이트 하나, 애플리케이션 하나를 프로그램 하나로 생각하기 쉽지만, JS에서는 파일 각각이 별도의 프로그램이다. 이러한 관점은 오류 처리와 관련이 깊은데, JS는 파일을 프로그램으로 취급하기에 파일 하나에만 오류가 있어도 다음 파일이 처리되지 않을 수 있다.독립적인 js 파일을 하나의 프로그램으로 작동시키는 방법은 전역 스코프를 사용해 파일간 상태를 공유하고 공통으로 사용하는 기능을 접근할 수 있도록 만드는 방법뿐이다. 이렇게 전역스코프에서 여러 .js 파일이 조합되면 이 파일들은 런타임에서 하나의..." }, { "title": "You don&#39;t know JS Yet - 1장 자바스크립트", "url": "/posts/You-don't-know-JS-Yet-1%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/", "categories": "study,, YDKJSY", "tags": "study", "date": "2024-10-30 19:00:00 +0900", "snippet": "1.2 자바스크립트 이름의 유래 자바스크립트는 마케팅 차원에서 지어진 이름으로, 당시 자바 개발자들에게 어필하기 위한 목적으로 “가벼운 프로그램”이라는 뜻으로 유행한 “스크립트”라는 단어를 합쳐 만들어짐1.3 명세서 TC39 : JS를 관리하는 기술 운영 위원회로 JS의 공식 명세를 관리함 TC39는 정기적인 회의를 통해 명세 변경사항을 합의하고 ECMA에 제출한다 TC39의 제안은 5단계로 나뉘며, 누군가가 새로운 명세를 제안하면 TC39 위원 중 한명이 이를 0단계에 올리면서 시작된다 JS에는 버전이 없고, 표준 ..." }, { "title": "나중에 볼 아티클들", "url": "/posts/%EB%82%98%EC%A4%91%EC%97%90-%EB%B3%BC%EB%A7%8C%ED%95%9C-%EC%95%84%ED%8B%B0%ED%81%B4%EB%93%A4/", "categories": "study", "tags": "#study", "date": "2024-10-27 19:00:00 +0900", "snippet": " https://frontendmasters.com/blog/patterns-for-memory-efficient-dom-manipulation/ dom 조작 시 성능 개선이 필요할때 " }, { "title": "웹 페이지가 로드되기 전에 더 빠르게 만드는 방법", "url": "/posts/%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80-%EB%A1%9C%EB%93%9C%EB%90%98%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%8D%94-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95/", "categories": "study,, article", "tags": "#study", "date": "2024-10-26 19:00:00 +0900", "snippet": "https://ykss.netlify.app/translation/how_to_make_your_web_page_faster_before_it_even_loads/보통 성능 개선을 할때는 FCP, LCP, INP 등 페이지가 로드 되고 난 이후의 성능을 고려한다.이 아티클에서는 페이지가 로드되는 것까지 성능 개선을 어떻게 할 수 있을지에대해 다루었다웹 페이지가 로드되기 전에 하는 일window.performance 를 통해 로드와 관련된 성능 지표를 확인할 수 있다 브라우저 캐시 : HTTP GET 을 통해 리소스를 가져오면..." }, { "title": "next.js 15 RC", "url": "/posts/next.js-15-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD/", "categories": "study,, article", "tags": "#study", "date": "2024-10-22 19:00:00 +0900", "snippet": "https://nextjs.org/blog/next-15next.js 15의 스테이블버전이 나와 작성하였다Async Request APIs (Breaking Change)전통적인 SSR 에서는 서버에서는 요청이 전부 완료될때까지 렌더링을 중지한다. 하지만 모든 컴포넌트가 요청이 필요한건 아니다. 따라서 가능한 많은 컴포넌트를 요청이 종료되기전에 준비하기위해, 몇몇 API를 비동기적으로 변경하였다 cookies, headers, draftMode params in layout.js, page.js, route.js, defa..." }, { "title": "the state of es5 on the web", "url": "/posts/the-state-of-es5-on-the-web/", "categories": "study,, js", "tags": "#study", "date": "2024-10-15 19:00:00 +0900", "snippet": "https://philipwalton.com/articles/the-state-of-es5-on-the-web/ES5의 현재 상태와 웹 성능 및 코드 호환성에 미치는 영향을 다루는 글.ES5 코드를 작성하는 건 문제가 아님. 하지만 ES6+ 코드를 작성했을때 이를 ES5로 트랜스파일하는 것은 많은 Polyfill을 포함하게 함. 대부분의 사이트에서 ES5로 트랜스파일을 시키고 있으므로, 이는 상당한 낭비를 발생시키고 있음.The Data Bundler and build tool’s default cofiguratios ..." }, { "title": "프로그래머의 뇌 13장 - 새로운 개발자 팀원의 적응 지원", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-13%EC%9E%A5-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90-%ED%8C%80%EC%9B%90%EC%9D%98-%EC%A0%81%EC%9D%91-%EC%A7%80%EC%9B%90/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-10-07 19:00:00 +0900", "snippet": "경험 많은 개발자나 초보 개발자가 새로운 팀원으로 들어왔을 때 그들에게 제공하는 적응 지원을 개선하는 방법을 다루자.먼저 전문가와 초보자가 어떻게 다르게 생각하는지 살펴보고, 새로운 팀원을 대상으로 수행할 수 있는 다양한 활동을 살펴보자.13.1 적응 지원의 문제 너무 많은 것을 동시에 교육하여 작업 기억 공간의 용량을 과도하게 늘리는 경우 두뇌가 너무 많은 인지부하를 경험하면 효과적인 사고가 억제되며, 본유적 부하를 위한 여유 공간이 없기에 정보가 저장되지 않는다 이와 같은 상황은 교육자와 피교육자..." }, { "title": "프로그래머의 뇌 12장 대규모 시스템의 설계와 개선", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-12%EC%9E%A5-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%84%A4%EA%B3%84%EC%99%80-%EA%B0%9C%EC%84%A0/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-10-06 19:00:00 +0900", "snippet": "큰 규모의 코드베이스에서 코드의 구조는 다른 사람이 코드와 얼마나 쉽게 상호작용할 수 있을지 영향을 미친다.이 장에서는 코드베이스를 인지적 관점에서 바라보는 CDN 기술에 대해 논한다. CDN은 코드를 사람들이 쉽게 변경할 수 있을지, 쉽게 정보를 찾을 수 있을지란 질문에 답을 찾는데 도움을 준다.이어서 코드베이스의 인지차원이라는 수정된 프레임워크를 사용하여 기존 코드베이스의 설계를 개선하는 방법을 다룬다12.1 코드베이스의 특성 조사코드베이스에 대해 논할때 기술적 측면이 아닌 인지적 측면에서 논해보자인지적 차원토머스 그린 등..." }, { "title": "프로그래머의 뇌 11장 복잡한 문제해결을 더 잘하려면", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-11%EC%9E%A5-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0%EC%9D%84-%EB%8D%94-%EC%9E%98%ED%95%98%EB%A0%A4%EB%A9%B4/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-10-05 19:00:00 +0900", "snippet": "프로그래밍을 할 때 인지 과정이 어떤 역할을 하는지, 업무 중단이 미치는 인지적 영향이 무엇인지에 대해 알아보는 장11.1 프로그래밍 중 이루어지는 다양한 활동프로그래밍 중 발생하는 인지 활동은 토머스 그린 등에 의한 인지적 차원 표기법이라는 프레임워크로 평가할 수 있다. 여기서는 활동을 검색, 이해, 전사, 증가, 탐구라는 다섯 가지 활동으로 기술한다. 검색 : 코드베이스를 살펴보고 특정 정보를 검색하는 작업 검색 대상, 탐색 경로 및 이유, 심층 탐구 사항 등을 기억해야하므로 STM에 무리를 가한다. ..." }, { "title": "프로그래머의 뇌 10장 복잡한 문제해결을 더 잘하려면", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-10%EC%9E%A5-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0%EC%9D%84-%EB%8D%94-%EC%9E%98%ED%95%98%EB%A0%A4%EB%A9%B4/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-10-02 19:00:00 +0900", "snippet": "이 장에서는 문제 해결에 도움이 되는 기술에 대해 LTM을 강화하는데 중점을 두어 살펴본다. 문제 해결능력 향상을 위한 두가지 기술을 알게 될 것이다 자동화 : 사소한 일을 인지부하 없이 처리할 수 있음 다른 사람이 작성한 코드로 문제해결하는 방법10.1 문제 해결이란?문제 해결을 위한 세가지 요소 목표 상태 : ex) 웹 사이트에 검색 상자를 추가 시작 상태 : ex) 현재 코드 베이스 시작 상태에서 목표 상태에 도달하는 방법을 규정하는 규칙 : ex) 코드 제약사항, 테스트 코드 통과 등상태 공간프로그램을 해결할 ..." }, { "title": "프로그래머의 뇌 9장 나쁜 코드와 인지 부하를 방지하는 두가지 프레임워크", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-9%EC%9E%A5-%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C%EC%99%80-%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98%EB%A5%BC-%EB%B0%A9%EC%A7%80%ED%95%98%EB%8A%94-%EB%91%90%EA%B0%80%EC%A7%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-10-02 19:00:00 +0900", "snippet": "어떤 코드가 인지부하를 많이 일으키며, 인지적으로 쉽게 처리하기 위해 코드를 개선할 수 있는 방법을 논의하자. 구조적인 혼란 (코드 스멜) 내용의 혼란 (언어적 안티패턴)9.1 코드 스멜이 인지 부하를 초래하는 이유코드 스멜 : 작동은 하지만 개선의 여지가 있는 코드. 마틴 파울러가 말한 22가지 코드 스멜 (링크) 메서드 수준 코드 스멜 너무 많은 라인, 기능, 매개변수를 가진 메서드 클래스 수준 코드 스멜 기능이 너무 많아 추상화가 안되는 경우 (신의 클래스) 의..." }, { "title": "프로그래머의 뇌 8장 명명을 잘하는 방법", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-8%EC%9E%A5-%EB%AA%85%EB%AA%85%EC%9D%84-%EC%9E%98%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-29 19:00:00 +0900", "snippet": "좋은 이름을 사용하면 LTM을 활성화하여 코드 도메인에 대해 이미 알고 있는 관련 정보를 찾을 수 있다. 나쁜 이름은 코드에 대한 잘못된 추측을 하게 하고 오개념을 유발할 수 있다.이름을 짓는 것은 중요하고 매우 어려운데, 보통 이름은 문제를 해결하는 과정에서 짓기 때문이다. 이 과정은 작업 기억 공간의 부하가 심한 상태이므로, 이 상태에서 좋은 이름을 짓는 것은 부하를 더 가하는 일이기에 우리는 쉬운 이름을 선택하는 경향이 있다8.1 이름이 중요한 이유 이름은 코드베이스의 상당 부분을 차지한다. 코드 리뷰 시 이름의 역할..." }, { "title": "프로그래머의 뇌 - 전체 정리", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-%EC%A0%84%EC%B2%B4-%EC%A0%95%EB%A6%AC/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-25 19:00:00 +0900", "snippet": "요약하는 관점 : 어떤 문제를 인지적으로 어떻게 해결할 수 있을지1장 - 코딩 중 겪는 혼란에 대한 이해인지 과정 LTM : 장기 기억 공간. 내용을 반 영구적으로 저장하는 곳. STM : 단기 기억 공간. 들어오는 정보를 일단 임시로 저장하는 곳. 최대 12개를 이상을 기억하지 못한다는 것이 정설 작업 기억 공간 : 실제 사고 작용이 일어나는 곳으로 컴퓨터의 프로세서에 해당.인지 과정들의 상호작용 코드를 읽을 때 어떤 변수 n 이 정수형이라는 정보 -&amp;gt; STM에 저장됨. 정수형이..." }, { "title": "프로그래머의 뇌 7장 생각의 버그", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-7%EC%9E%A5-%EC%83%9D%EA%B0%81%EC%9D%98-%EB%B2%84%EA%B7%B8/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-23 19:00:00 +0900", "snippet": "이 장에서는 버그에 대해 중점적으로 알아본다. 버그는 생각에 착오가 있을때 발생한다. 코드를 작성할 때 잘못된 가정을 품기에 버그가 발생한다. 이 장에서는 아래 사항을 알아볼 것이다 기존 지식을 활용하여 새로운 프로그래밍 언어를 학습하는 방법과 언어 간의 차이로 인해 발생하는 어려움과 오류를 피하는 방법 프로그래밍과 관련한 다양한 오개념에 대해 다루고 오개념이 발생하는 이유7.1 왜 두 번째 프로그래밍 언어가 첫 번째보다 쉬울까?이미 배운 지식이 새로운 것을 하는데 도움이 되는 것을 전이(transfer)라고 한다. LT..." }, { "title": "프로그래머의 뇌 6장 코딩 문제 해결을 더 잘하려면", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-6%EC%9E%A5-%EC%BD%94%EB%94%A9-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EC%9D%84-%EB%8D%94-%EC%9E%98%ED%95%98%EB%A0%A4%EB%A9%B4/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-18 19:00:00 +0900", "snippet": "이 장에서는 여러 가지 소프트웨어 설계에 관한 결정을 할 때 통찰력을 얻는데 도움이 될 만한 두가지 프레임워크에 대해 다룬다 문제 해결과 프로그래밍 작업 도중 두뇌가 생성하는 심적 표상 문제를 풀 때 어떻게 컴퓨터에 대해 추상화하는지6.1 모델을 사용해서 코드에 대해 생각해보기모델은 실재를 간단히 표현한 것으로, 문제에 대해 생각하고 해결하는 데 도움을 주기 위한 것이다. 모델은 여러 모양과 다양한 수준의 형식을 띌 수 있다문제를 풀 때 코드의 모델을 명시적으로 사용하는 것은 두가지 장점이 있다 프로그램에 대한 정보를 다..." }, { "title": "프로그래머의 뇌 5장 코드를 더 깊이 있게 이해하기", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-5%EC%9E%A5-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8D%94-%EA%B9%8A%EC%9D%B4-%EC%9E%88%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-17 19:00:01 +0900", "snippet": "코드를 이해하였다면 그 다음은 코드에 대해 좀 더 깊이 생각하는 것이다. 코드는 왜/어떻게 작성되었고, 기능은 어디에 추가되어야하며, 어떻게 재설계할 것인가 등을 생각해봐야한다이 장에서는 코드에 대해 깊이 생각하여 코드 작성자의 아이디어, 생각, 결정을 추론할 수 있는 방법과 코드를 깊은 수준에서 생각할 수 있는 세 가지 방법을 살펴보려고 한다.먼저 코드 추론에 도움이 되는 프레임워크를 알아보고, 이해의 여러 수준에 대해 살펴보고 좀 더 깊이 이해하는 방법, 자연어로 된 텍스트를 읽을 때 도움이 되는 방법 중 코드를 읽는데도..." }, { "title": "프로그래머의 뇌 4장 복잡한 코드 읽는 방법", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-4%EC%9E%A5-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%9D%BD%EB%8A%94-%EB%B0%A9%EB%B2%95/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-17 19:00:00 +0900", "snippet": "코드가 혼란스러운 이유는 다음 세가지다 STM에 저장되어 있어야 할 정보가 부족하기에 (2장) LTM에 저장되어 있는 지식이 부족하기에 (3장) 두뇌의 처리 능력부족1,2번에 대해서는 이미 배웠다. 하지만 코드가 너무 복잡하여 많은 문법 지식과 효율적인 청킹으로도 코드를 이해하기 어려울 때가 있다.이번 장에서는 두뇌에서 처리하는 능력인 작업 기억 공간의 기저에 있는 인지 과정을 알아보자.4.1 복잡한 코드를 이해하는 것이 왜 어려울까?작업 기억 공간은 두뇌가 생각하고 새로운 아이디어를 형성하고 문제를 해결하는 능력에 해당..." }, { "title": "프로그래머의 뇌 3장 프로그래밍 문법 빠르게 배우기", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-3%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EB%B2%95-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EA%B8%B0/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-16 19:00:01 +0900", "snippet": "프로그래밍 개념을 더 잘, 쉽게 외우는 방법들.프로그래밍 문법에 대한 지식을 갖는 것은 코드를 효율적으로 이해하는데도 도움이 된다. 프로그래밍 개념에 대한 장기기억을 강화하여 코드를 청크로 나누어 읽는 것들 더 잘할 수 있게 해준다.3.1 문법을 기억하기 위한 팁많은 개발자는 문법을 모르더라도 검색하면 되기에 중요한 지식이 아니라 생각한다. 하지만 관련 내용을 미리 알고 있으면 코드를 더 효율적으로 읽을 수 있기에 중요한 지식이다.업무 중단이 미치는 나쁜 영향또한 두뇌가 작업을 하다 업무 중단이 되면 우리의 생각보다 훨씬 안좋..." }, { "title": "프로그래머의 뇌 2장 신속한 코드 분석", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-2%EC%9E%A5-%EC%8B%A0%EC%86%8D%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B6%84%EC%84%9D/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-15 19:00:00 +0900", "snippet": "코드를 빠르게 읽고 그 작동을 이해하는 방법에 대한 장.코드를 빨리 읽을때 두뇌에서 무슨 일이 일어나는지 알면 코드를 얼마나 잘 이해하고 있는지 스스로 확인해보기 쉽다. 이 장에서는 코드분석이 왜 어려운지, 어떻게 코드를 더 빨리 읽을 수 있는지, 코드 읽기 기술을 향상하기 위한 방법이 무엇인지 알아볼 것이다.2.1 코드를 신속하게 읽기 프로그램은 사람이 읽을 수 있도록 작성해야 한다. 기계가 실행하는 것은 부차적인 일이다. 컴퓨터 프로그램의 구조와 해석 코드를 읽는 목적은 다양하지만 한가지 공통점은, 우리는 ..." }, { "title": "프로그래머의 뇌 1장 코딩 중 겪는 혼란에 대한 이해", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-1%EC%9E%A5-%EC%BD%94%EB%94%A9-%EC%A4%91-%EA%B2%AA%EB%8A%94-%ED%98%BC%EB%9E%80%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4/", "categories": "study,, 프로그래머의, 뇌", "tags": "#study", "date": "2024-09-14 19:00:00 +0900", "snippet": "프로그래밍을 할 때 역할을 하는 세 가지 인지 과정과 각각의 인지 과정이 자신의 혼란 유형과 어떻게 연관되어있는지에 대한 장1.1 코드가 초래하는 세가지 종류의 혼란 지식의 부족 : 프로그래밍 언어나 알고리즘 혹은 업무 영역에 대한 지식이 없는 경우 정보의 부족 : 코드를 이해하기 위한 필요한 정보를 충분히 가지고 있지 않은 경우 (모듈, 라이브러리 등) 처리능력 부족 : 코드가 너무 복잡해서 혼란이 생기는 경우 (처리 능력의 부족. 처리과정을 따라가며 직접 계산해야함)1.2 코딩에 영향을 주는 인지 과정Long-Term..." }, { "title": "TypeScript Branded Types로 런타임 타입 안정성 개선하기", "url": "/posts/TypeScript-Branded-Types%EB%A1%9C-%EB%9F%B0%ED%83%80%EC%9E%84-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%95%EC%84%B1-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0/", "categories": "study,, typescript", "tags": "#study", "date": "2024-09-14 19:00:00 +0900", "snippet": "https://siosio3103.medium.com/typescript-branded-types%EB%A1%9C-%EB%9F%B0%ED%83%80%EC%9E%84-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%95%EC%84%B1-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0-768222c8df0d문제만약 타입이 아래처럼 정의되어있다고 해보자type User = { id: string name: string } type Post = { id: string ownerId..." }, { "title": "Code review anipatterns", "url": "/posts/Code-review-anipatterns/", "categories": "study", "tags": "#study", "date": "2024-09-13 19:45:24 +0900", "snippet": "https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/code-review-antipatt코드리뷰는 리뷰어와 개발자 모두 도움이 되는 측면이 있다. 하지만 리뷰어가 잘못하면 코드 개선에 매우 큰 장애물이 될 수도 있다. 개발자를 짜증나게하고 개선을 포기하게 할수도 있는 것이다.여기서는 이를 예방하기 위해 코드리뷰 안티패턴을 반어적으로 소개한다The Death of a Thousand Round Trips문제점을 발견하자마자 코멘트를 달고 코드를 그만 읽음 -&amp;gt; 개발자는 ..." }, { "title": "common cause of memory leaks in javascript", "url": "/posts/common-cause-of-memory-leaks-in-javascript/", "categories": "study,, article", "tags": "#study", "date": "2024-09-12 00:00:00 +0900", "snippet": "https://www.trevorlasn.com/blog/common-causes-of-memory-leaks-in-javascriptUnderstanding Memory Usage In Node.js (V8)Node.js(V8)에서 사용하는 메모리 타입들 (process.memoryUsage() 을 통해 확인 가능) Memory Type Description RSS (Resident Set Size) Node.js 프로세스에 할당된 모든 메모리(heap, s..." }, { "title": "why-nextjs-sucks", "url": "/posts/why-nextjs-sucks/", "categories": "study,, article", "tags": "#study", "date": "2024-09-08 00:00:00 +0900", "snippet": "https://medium.com/@thecodingteacher_52591/why-nextjs-sucks-0352de93071b저자가 next.js를 사용하면서 느낀 왜 next.js가 복잡한 프로젝트에서는 별로인지 설명한 글이다. 크게 네가지 이유를 들어 설명한다 NodeJS sucks for SSR nodeJS는 싱글 스레드이며 이는 I/O 처리를 하는데 좋지만, 복잡한 SSR을 함께 다루면 취약해질 수 있다. 요청량이 많아지게 되면 페이지 렌더링 작업이 큐에 쌓이게 되고, 이는 점점 겉잡을 수..." }, { "title": "JS bundler, package manager, compiler", "url": "/posts/JS-bundler,-package-manager,-compiler/", "categories": "study,, js", "tags": "#study", "date": "2024-08-31 19:45:24 +0900", "snippet": "프론트엔드 관련 아티클을 읽다보면 다양한 bundler, package manger, compiler 도구에 대한 얘기가 나온다. 그때마다 익숙지않은 도구의 이름(pnpm, swc, vite 등)이 나오는데 뭐가 뭔지 잘 이해가 안간다. 따라서 각각의 역할이 무엇인지, 어떤 종류가 있고 어떤 장단이 있는지 간단히 정리해보려고 한다.Bundler여러개의 파일을 하나의 파일로 묶어주는 도구이다.초기에 브라우저는 모듈 시스템을 지원하지 않았다. &amp;lt;script&amp;gt; 간 모듈을 내보낼 수 없었고, 전역 객체를 통해..." }, { "title": "How I Use &quot;AI&quot;", "url": "/posts/How-I-Use-AI/", "categories": "study,, article", "tags": "#study", "date": "2024-08-31 19:45:24 +0900", "snippet": "원본작성자가 언제 어떻게 LLM 을 활용하는지 공유하는 포스트 애플리케이션을 만드는 초기 단계에서 전체적인 베이스를 만드는데 도움을 받았음 새로운 기술의 튜터로써 코드 단순화를 위해 단조로운 작업을 빠르게 처리하기 위해 불규칙적인 작업이더라도 LLM이 패턴을 파악하여 결과물을 내게할 수 있음 자동화작업에 사용가능 " }, { "title": "Esbuild to reduce build times by 90%", "url": "/posts/Esbuild-to-reduce-build-times-by-90/", "categories": "study,, article", "tags": "#study", "date": "2024-08-31 19:45:24 +0900", "snippet": "원본기존에 빌드가 오래 걸렸던 원인들 웹팩, 롤업 작업 시간이 대부분이었음 작은 의존성들이 하나씩 빌드됨. 이것들은 동시에 진행될 여지가 있음 몇몇 의존성은 필요한 것보다 오래 빌드됨. 변경되지 않은 파일에 대해서 typeshare 를 재실행하지 않기위해 find를 실행했으나, 그냥 typeshare를 실행하는 것보다 find 실행시간이 더 길었음해커톤을 통해 몇몇 시도한 해결책 esbuild를 webpack, rollup의 로더로 사용하여 성능 개선을 이루어냄. rollup 에서는 80%의 성능개선을..." }, { "title": "실용주의프로그래머 - 전체 후기", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EC%A0%84%EC%B2%B4-%ED%9B%84%EA%B8%B0/", "categories": "study,, 실용주의프로그래머", "tags": "#study, #review", "date": "2024-08-11 21:07:38 +0900", "snippet": "이 책은 프로젝트 과정 전반에 거쳐 소프트웨어 전문가답게 진행하는 방법에 대해 서술되어있다. 전반적으로 이해가 잘되도록 쓰여져 있고, 현인의 어록과도 같은 책이라 참고할만한 부분도 많이 있다.하지만 조직문화나 권한의 한계, 물리적인 시간의 한계로 모든 팁을 다 따르기는 어렵다. 또한 이러한 내용은 완전히 습관이 되어야하는데, 긴 책 내용을 전부 기억하기는 현실적으로 어렵다. 따라서 현재 내 상황에서 실천 가능한 팁들을 간단히 정리하였다.이 문서는 1차, 2차, … 로 비정기적으로 업데이트 해나갈 것이다. 다음 업데이트는 이전 ..." }, { "title": "실용주의프로그래머 9장 실용주의 프로젝트", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-9%EC%9E%A5-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-08-11 19:33:56 +0900", "snippet": " Topic 49 : 프로젝트 참여인원이 복수가 되었을때 실용적으로 각 부분을 위임하는 법 Topic 50 : 팀에게 잘 맞는 방법론을 사용하고 있는가 Topic 51 : 안정적인 소프트웨어를 지속적으로 생산해내는 방법 Topic 52 : 사용자를 기쁘게하는 방법 Topic 53 : 자신의 작업에 자부심을 가져라Topic 49 : 실용주의 팀실용주의 팀은 작아야한다. 구성원은 대략 10~12명이고, 구성의 변경이 적어야한다. 서로를 신뢰하고 의존할 수 있어야한다. 작고 안정적인 팀을 유지하라원하는 바를 실현할 수 있..." }, { "title": "실용주의프로그래머 8장 프로젝트 전에", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-8%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A0%84%EC%97%90/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-08-07 17:32:06 +0900", "snippet": "Topic 45 : 요구사항의 구렁텅이 자신이 뭘 원하는지 정확히 아는 사람은 아무도 없다.요구사항 미신무엇을 다루든 정확한 명세란 것은 거의 불가능하다. 이때 프로그래머는 사람들이 자신이 무엇을 원하는지 깨닫도록 도와줄수 있다. 프로그래머는 사람들이 자신이 원하는 바를 꺠닫도록 돕는다.상담 치료로서의 프로그래밍신입 개발자의 실수는 요구사항을 받고 바로 해결책을 구현하는 것이다.어떤 요구사항을 받았을때 여러 경우를 생각하고 되물어 확인하자 (사소하여 짜증날거 같은 질문이라해도) 요구사항: 5만 원 이상인 모든 주문은 배송..." }, { "title": "잘못된 DRY", "url": "/posts/%EC%9E%98%EB%AA%BB%EB%90%9C-DRY/", "categories": "study", "tags": "#study", "date": "2024-08-06 11:17:27 +0900", "snippet": "https://velog.io/@eunbinn/dry-the-common-source-of-bad-abstractions DRY 원칙을 너무 지키다보니 잘못된 추상화를 하는 경우가 있다 바로 서로 성격이 다른 코드이지만, 비슷한 패턴을 가진다는 이유로 같은 코드로 묶는 경우이다. ex) 네비게이션에 Article, Menu, Buy 버튼이 있을때, Article, Menu와 Buy 버튼은 서로 성격이 다르지만 같은 팩터리 메서드로 묶는다면, 추후 Buy 버튼만 변경될 우려가 있다. 따라서 서로 다른 성격의 코드는 다르게..." }, { "title": "실용주의프로그래머 7장 코딩하는 동안", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-7%EC%9E%A5-%EC%BD%94%EB%94%A9%ED%95%98%EB%8A%94-%EB%8F%99%EC%95%88/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-08-05 18:06:46 +0900", "snippet": "코딩은 설계내용을 단순히 코드로 바꾸는 과정이 아니다. 이번 장에서는 프로그램을 정확하게 동작하게 하려면 어떻게 해야하는지 다룬다. 운전할 때와 마찬가지로 코딩도 반복적인 일이지만 정신을 늘 기민하게 유지하여야한다. topic 37 : 본능과 무의식적인 생각을 더 잘 활용할 수 있다 topic 38 : 우연에 맡기는 프로그래밍을 피하는 방법 topic 39 : 알고리즘의 속도 topic 40 : 리팩터링 topic 41 : 테스트로 코딩하기 topic 42 : 속성 기반 테스트를 통해 고정관념에서 벗어난 테스트하기 ..." }, { "title": "실용주의프로그래머 6장 동시성", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-6%EC%9E%A5-%EB%8F%99%EC%8B%9C%EC%84%B1/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-08-04 18:04:36 +0900", "snippet": " 동시성 : 둘 이상의 코드 조작이 실행될 때 동시에 실행 중인 것처럼 행동하는 것. 소프트웨어 동작 코드의 다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야함. ex) 스레드, 프로세스 병렬성 : 실제로 동시에 실행되는 것. 하드웨어 동작 두가지 일을 동시에 할 수 있는 하드웨어가 필요함. ex) CPU내 코어, 네트워크로 연결된 컴퓨터 등 모든 일에 동시성이 있다.시스템이 커지면 동시성은 필수다. 어떤 일을 할 때, 한번에 하나씩 순차적으로 수행 하면 시..." }, { "title": "실용주의프로그래머 5장 구부러지거나 부러지거나", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-5%EC%9E%A5-%EA%B5%AC%EB%B6%80%EB%9F%AC%EC%A7%80%EA%B1%B0%EB%82%98-%EB%B6%80%EB%9F%AC%EC%A7%80%EA%B1%B0%EB%82%98/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-07-28 20:07:50 +0900", "snippet": "이번 장에서는 되돌릴 수 있는 의사결정을 내리는 구체적인 방법을 설명한다. topic 28 : 결합도 줄이기 topic 29 : 실세계를 갖고 저글링하기. 이벤트에 반응하는 네 가지 서로 다른 전략 topic 30 : 변환 프로그래밍. 함수 파이프라인 topic 31 : 상속세. 유연하고 바꾸기 쉬운 코드를 만들 수 있는 대안 topic 32 : 설정. 세부사항을 코드 밖으로 옮기는 방법Topic 28 : 결합도 줄이기코드에서 나타나는 결합의 증상 관계없는 모듈이나 라이브러리 간의 희한한 의존 관계 한 모듈의 간단..." }, { "title": "실용주의프로그래머 4장 실용주의 편집증", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-4%EC%9E%A5-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%8E%B8%EC%A7%91%EC%A6%9D/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-07-27 21:04:15 +0900", "snippet": " 여러분은 완벽한 소프트웨어를 만들 수 없다실용주의 프로그래머는 자신의 실수에 대비한 방어책을 마련한다. Topic 23 : 코드의 공급자와 사용자는 권리와 책임에 대해 동의해야한다 Topic 24 : 버그상황에서 헤어나오는 도중에 어떤 손상도 입히지 않도록 보장해야한다. Topic 25 : 확인을 쉽게하는 방법. 가정(assumption)을 적극적으로 검증하는 코드 작성 Topic 26 : 여러 시스템 리소스를 다룰때 실수 하지 않는 법 Topic 27 : 언제나 작은 단계를 고수해야한다.Topic 23 : 계약에..." }, { "title": "실용주의프로그래머 3장 기본도구", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3%EC%9E%A5-%EA%B8%B0%EB%B3%B8%EB%8F%84%EA%B5%AC/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-07-21 20:49:29 +0900", "snippet": "Topic 16 - 일반 텍스트의 힘일반 텍스트란?인쇄 가능한 문자로 이루어지고, 정보를 전달하기에 적합한 형식을 갖추어야한다. 또한 사람이 이해할 수 있어야한다. 일반 텍스트 우유커피 일반 텍스트가 아님 hlj;uijn bfjxrrctvh jkni’pio6p7gu;vh bjxrdi5rgvhjField19=467abe 형식은 HTML, JSON, YAML 등 다양하다.일반 텍스트는 데이터를 그 자체로만 이해할 수 있다. 이진포맷은 데이터를 읽는데 필요한 문맥과 데이터가 분리되어있어, 데이터를 ..." }, { "title": "실용주의프로그래머 2장 실용주의 접근법", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-2%EC%9E%A5-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EC%A0%91%EA%B7%BC%EB%B2%95/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-07-15 21:15:49 +0900", "snippet": "Topic 8 - 좋은 설계의 핵심 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.ETC(Easy To Change)는 규칙이 아니라 가치가치란 결정을 내릴때 도움을 주는 것이다. ETC는 가치로서 내제화되어야하며, 의식적으로 방금 한 일이 ETC 한지 항상 물어봐야한다.일반적으로 상식선에서 추측이 가능하다. 하지만 결정하기 어려울때가 있는데, 이럴땐 다음 두가지 방법이 있다. 코드가 교체되기 쉬워야한다. (결합도를 낮추고 응집도를 높여라) 직관적으로 선택하고, 그 이유에 대해 기록해둬라. 그리고 추후 변경이 실제로 발생..." }, { "title": "실용주의프로그래머 1장 실용주의 철학", "url": "/posts/%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-1%EC%9E%A5-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EC%B2%A0%ED%95%99/", "categories": "study,, 실용주의프로그래머", "tags": "#study", "date": "2024-07-14 16:13:54 +0900", "snippet": "Topic 1 - 당신의 인생이다변화를 피하지 말고 불만이 있는 것이 있으면 고치기 위해 노력하라 업무환경, 적성이 안맞으면 바꾸되, 너무 오래 노력하지는 말기 뒤쳐지는 기분이 들면 여가 시간에 공부하기기회는 많고 적극적으로 행동해 그 기회를 잡아라Topic 2 - 고양이가 내 소스 코드를 삼켰어요실용주의 철학의 초석 중 하나는 자신과 자신의 행동에 대해 책임을 지는 것이다. 아무리 잘해도 발생하는 문제는 있고, 이를 정직하고 솔직하게 인정하고, 처리하려고 노력해야한다.팀 내 신뢰팀이 나를 믿고 의지할 수 있어야하고, 나도..." }, { "title": "next.js 최적화과정", "url": "/posts/next.js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B3%BC%EC%A0%95/", "categories": "study, next.js", "tags": "next.js", "date": "2023-10-22 16:00:00 +0900", "snippet": "발단서비스를 운영하던 도중 CPU/Memory 사용량은 낮은데 사용자 응답이 매우 느려지는 상황이 발생하였다.서비스는 쿠버네티스로 띄워져있었고, HPA metric으로 CPU와 memory가 걸려있었는데, CPU와 memory가 올라가지 않으니 scale-out도 발생하지 않아 적은 pod으로 계속 서비스 되고 있었다.수동으로 pod을 3~4배 가량 늘려 대응은 하였으나 추후에도 발생할 이슈일 것으로 보여 대응을 하기로 했다.테스트이 이슈는 next.js로 띄워져있는 페이지 중 하나에 페이지에 갑자기 트래픽이 몰려 발생한 이슈..." }, { "title": "next.js caching", "url": "/posts/next-caching/", "categories": "study, next.js", "tags": "next.js, cache", "date": "2023-08-13 22:00:00 +0900", "snippet": "next.js app router의 caching에 관해 공부한 내용입니다.Overviewnext.js 에서 제공하는 caching mechanism에는 다음과 같은 것들이 있다. Mechanism What Where Purpose Duration Request Memoization Return values of functions Server Re-use data in a React Component tree ..." }, { "title": "next.js props drilling", "url": "/posts/next-props-drilling/", "categories": "study, next.js", "tags": "next.js", "date": "2023-08-05 16:00:00 +0900", "snippet": "Data sharing (Solving props drilling)next.js 13.4 이상 App router 기준으로 작성하였습니다.props drilling 예시next.js에서 주로 발생하는 props drilling 형태는 다음과 같습니다. 먼저 필요한 데이터를 서버컴포넌트에서 fetch 합니다. API 노출 방지, 최적화 등 다양한 이유로 서버 컴포넌트(서버 사이드)에서 API를 호출합니다.// Server Component Aimport ServerComponentB from &quot;./ServerCompo..." }, { "title": "React 새로고침/뒤로가기 막기", "url": "/posts/react-%EB%92%A4%EB%A1%9C%EA%B0%80%EA%B8%B0-%EB%A7%89%EA%B8%B0/", "categories": "study, react", "tags": "react", "date": "2023-07-29 22:00:00 +0900", "snippet": "웹페이지에서 사용자가 무언가를 입력하고 뒤로가기를 눌렀을때 다음과 같은 경고창을 띄우는 걸 본적이 있다.이러한 스펙을 개발하기위해서는 다음과 같이 두가지 상황으로 나누어야한다. 새로고침/창닫기/링크이동(외부페이지 이동 or 링크 버튼 클릭) 뒤로가기그렇다면 리액트에서는 구체적으로 어떻게 이 스펙을 구현할 수 있을지 알아보자새로고침/창닫기/링크이동새로고침/창닫기/링크이동의 경우는 간단하다. 해당 이벤트들이 발생할때 window 객체에서 발생시키는 beforeunload 이벤트를 취소시키면 된다.리액트에서 구현하려면 다음과 같..." }, { "title": "IOS 16.5에서 video가 크기 변경이 적용되지 않는 이슈", "url": "/posts/ios-16-5-video/", "categories": "study, js", "tags": "issues", "date": "2023-06-18 18:00:00 +0900", "snippet": "Spec Swiper (ver 4.5.1) 안에 &amp;lt;video&amp;gt; 태그가 slide로 포함되어있음. 현재 가장 가운데 있는 slide 안의 video는 크기를 키우고, slide가 옆으로 이동하면 다시 원래 사이즈로 돌아가도록 함 Issue IOS 16.5 safari에서는 다음과 같이 가운데 slide 안의 video 크기가 정상적으로 확대되지 않음원인 가운데 video 확대를 위한 코드는 다음과 같이 slide-active 상태일때 스타일을 적용하여 크기를 변경..." }, { "title": "es6에서 도입된 문법", "url": "/posts/es6/", "categories": "study, javascript", "tags": "javascript", "date": "2023-06-12 23:00:00 +0900", "snippet": "let, const 키워드를 통한 변수선언기존 자바스크립트에서는 var 키워드로만 변수선언이 가능했다. 하지만, let const 키워드를 추가하여 보다 예측가능한 코드를 작성할 수 있게 됐다.// es6 이전.// var는 재선언 가능var a = &quot;This is string&quot;;var a = 1234;// ES6 이후// let은 재선언 불가능let b = &quot;This is string&quot;;b = 1234;// const는 재할당 불가능const c = &quot;This is string&q..." }, { "title": "영상이 자동재생되지 않는 문제", "url": "/posts/video-notplaying/", "categories": "study, react", "tags": "issues", "date": "2023-06-03 18:00:00 +0900", "snippet": "다음과 같은 요구사항을 가지는 웹페이지를 개발하고 있었다. swiper로 여러 슬라이드를 띄움 슬라이드 내에는 영상이 존재하고, 각 영상은 자동으로 재생되어야함.단순히 swiper를 연동하고 video 태그에 autoplay 속성을 주면 될거라 생각하여 다음과 같이 코드를 작성했었다.&amp;lt;li className=&quot;swiper-slide&quot;&amp;gt; &amp;lt;video poster=&quot;poster 주소&quot; autoPlay m..." }, { "title": "DB index", "url": "/posts/index/", "categories": "study, database", "tags": "db", "date": "2023-06-03 16:00:00 +0900", "snippet": "##인덱스란?DBMS에서 데이터베이스 테이블의 모든 데이터를 검색하여 데이터를 찾기에는 시간이 오래 걸리기에, 데이터의 칼럼의 값과 그 데이터가 저장된 레코드의 주소를 키와 값의 쌍으로 만든 것.DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에, 원하는 값을 탐색하는데는 빠르지만, 추가/삭제/수정에는 쿼리문 실행 속도가 느려진다.(작업 후 다시 정렬해야하기에)결과적으로 DBMS의 인덱스는 데이터 저장 성능을 희생하고, 읽기 성능을 높이는 기능이다. 따라서 모든 컬럼을 대상으로 인덱스를 생성하면 데이터 저장 성능이 떨어지고..." }, { "title": "딥링크", "url": "/posts/deep-link/", "categories": "study, web", "tags": "web, issue", "date": "2023-05-19 22:00:00 +0900", "snippet": "딥링크는 웹사이트에서 사용자 기기에 설치된 앱을 URI로 실행시킬 수 있도록하는 기술이다.딥링크의 세가지 유형이러한 딥링크에는 세가지 유형이 있다. URI Scheme (초기 형태) 보완 Universal Link (IOS) App Link (Android) URI Scheme앱 개발자가 앱 내 특정 페이지마다 고유한 주소를 설정하고, 그 주소를 웹에서 실행시키면 설정한 특정 페이지가 열리는 형태이다. 이때 주소는 다음과 같은 형태이다.myapp://post?version=1여기서 myap..." }, { "title": "bfcache", "url": "/posts/bfcache/", "categories": "study, web", "tags": "browser", "date": "2023-05-12 22:00:00 +0900", "snippet": "BFCache 사용자가 브라우저 내에서 뒤로가기/앞으로가기를 할 때 이전 페이지를 자바스크립트 heap 영역까지 전체 캐싱하여 메모리에 저장하는 것 HTTP 캐시는 리소스만을 캐시하고 JS 작업까지 캐시하지 않기에 BFCache보다 빠르지 않다.BFCache 작동을 판단할 수 있는 APIpageshow, pagehidepageshow 페이지가 처음 로드 될 때, bfcache에서 페이지가 복원될 때마다 load 이벤트 직후 트리거 된다. event.persisted === true이면 BFCache에서 복구된 것이다.p..." }, { "title": "beforeunload vs pagehide", "url": "/posts/pagehide/", "categories": "study, javascript", "tags": "javascript", "date": "2023-05-11 23:00:00 +0900", "snippet": "ios 모바일에서 새로고침시 현재 스크롤 위치를 고정하기 위해 다음과 같은 코드를 사용하였다.if (sessionStorage.scrollPosition) { window.scrollTo(0, sessionStorage.scrollPosition);}window.onbeforeunload = function () { sessionStorage.scrollPosition = document.body.scrollTop || document.documentElement.scrollTop;};하지만 제대로 동작하지 않았는데, 찾아..." }, { "title": "useState 원리", "url": "/posts/react-state/", "categories": "study, react", "tags": "react", "date": "2023-05-06 18:00:00 +0900", "snippet": "State 변경 시 어떤 일이 벌어질까?리액트의 함수형 컴포넌트는 최초에 한번 실행이 되면서 초기값으로 설정해놓은 상태를 기억한다.const [state, setState] = useState(0);이후 setState가 호출되어 상태가 변경된다면 다시 함수형 컴포넌트가 실행되고 virtual DOM을 리턴한다. 그리고 이전에 리턴했던 virtual DOM과 비교해서 state 값이 달라졌다면 달라진 부분에 해당하는 DOM만 업데이트한다.useState와 Closure클래스형 컴포넌트는 render() 메서드를 통해 상태 변경..." }, { "title": "typescript 조건부타입(extends)", "url": "/posts/typescript-extends/", "categories": "study, typescript", "tags": "typescript", "date": "2023-04-24 22:30:00 +0900", "snippet": "타입 스크립트 2.8부터 다음과 같은 조건부 타입을 사용할 수 있다.T extends U ? X : Y뜻은 T가 U의 서브타입이거나 같은 타입이면 X, 아니면 Y 타입을 할당한다는 것이다.T가 유니온 타입일 경우다음과 같이 T가 유니온 타입일 경우가 있다.type T = &quot;A&quot; | &quot;B&quot; | &quot;C&quot;이러한 경우엔 분배법칙이 성립된다.{&quot;A&quot; extends U ? X : Y} | {&quot;B&quot; extends U ? X : Y} | {&quot;C&..." }, { "title": "Javscript 메모리 누수 방지 및 성능 개선", "url": "/posts/js-memory-leak/", "categories": "study, javascript", "tags": "javascript", "date": "2023-04-18 22:00:00 +0900", "snippet": "Javscript 메모리 관리 이해하기Garbage collector자바스크립트 엔진은 더이상 사용하지 않을 메모리를 놓아주기 위해 garbage collector를 사용한다. garbage collector(GC)는 앱에서 더이상 사용하지 않을 객체를 찾아내고 삭제한다. 따라서 GC는 앱의 object와 변수를 계속 모니터링하고 어떤 것이 여전히 referenced 되고 있는지 트랙킹한다. 그러다 Object가 더이상 쓰이지 않으면 마킹하고 삭제하여 메모리를 놓아준다.GC가 사용하는 이 기법은 mark and sweep이다..." }, { "title": "Typescript 5.0", "url": "/posts/typescript5/", "categories": "study, typescript", "tags": "typescript", "date": "2023-04-17 22:30:00 +0900", "snippet": "typescript 5.0이 나왔다고 하여 간단히 어떤 기능들이 추가되었는지 살펴보았다. 자세한 내용은 Typescript 5.0 번역에서 확인 가능하다.데코레이터데코레이터는 재사용 가능한 방식으로 클래스와 그 멤버를 사용자 정의하는 ECMAScript의 기능이다. 데코레이터는 이전부터 지원되었으나 Typescript 5.0부터는 공식 기능으로 지원한다.function loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) { const method..." }, { "title": "next.js appDir", "url": "/posts/appdir/", "categories": "study, next.js", "tags": "next.js", "date": "2023-04-13 17:00:00 +0900", "snippet": "AppDirnext.js에서 layout과 routing 경험을 개선시키고 React 최신 기술을 지원하기위해, next.js 13부터 지원하는 디렉터리 방식. 기존의 pages 디렉터리를 대체한다.23년 04월 기준으로 아직은 베타버전으로 프로덕션에서 사용하는 건 추천하지 않는다고 한다. 하지만, 좋은 기능들이 많기에 학습해봐도 괜찮을 거 같다.file conventionsapp directory에서 파일 컨벤션은 다음과 같다. page.js : 해당 path의 UI를 담당하며, public하게 접근할 수 있도록 함. ..." }, { "title": "성능 최적화를 위한 next.js case study", "url": "/posts/nextjs-case-study/", "categories": "study, next.js", "tags": "", "date": "2023-03-27 23:00:00 +0900", "snippet": "원글에서는 TMDB의 클라이언트 웹 어플리케이션을 만들고, 여러번의 실험을 거쳐 성능 최적화에 달성하는 과정을 서술하였습니다.이 글은 기본적으로 원글을 학습하면서 제가 읽기 편한 방식으로 번역/정리한 글입니다. 정확한 내용을 알고 싶으시면 원글을 보시는 걸 추천드립니다.용어 정의 FCP : First Contentful Paint. 사용자가 화면에서 콘텐츠를 볼 수 있는 페이지 로드 타임라인의 첫 번째 지점. LCP : Largest Contentful Paint. 뷰포트에서 가장 큰 콘텐츠 엘리먼트가 나타날때 까지 걸린 ..." }, { "title": "Vite", "url": "/posts/react-vite/", "categories": "study, react", "tags": "vite", "date": "2023-03-21 23:00:00 +0900", "snippet": "최근 create-react-app 대신에 vite를 공식으로 사용하자는 얘기가 나오고 있다. https://github.com/reactjs/reactjs.org/pull/5487 번역본여기서 지적한 문제점들은 다음과 같다 SSR/SSG 지원의 부족 빈 페이지 로드 -&amp;gt; 리액트 번들 로드 -&amp;gt; 리액트 실행 -&amp;gt; 필요한 데이터 패칭 순으로 이어지는 워터폴 문제 발생 모든 앱 코드가 하나의 번들로 묶임 상품 페이지를 로드할때, 장바구니 코드를..." }, { "title": "Headless CMS", "url": "/posts/web-Headless-CMS/", "categories": "study, web", "tags": "web", "date": "2023-03-10 23:00:00 +0900", "snippet": "Headless CMS 란?웹사이트를 만들 때는 반드시 컨텐츠(데이터)가 필요하다. Headless CMS는 컨텐츠를 보여줄 수단인 Head와 컨텐츠를 분리한 구조로, 컨텐츠가 Head에 독립적으로 동작할 수 있도록 하는 구조이다.![1E3qz8MZ8zR7Y3NRghFOvJQ](https://miro.medium.com/v2/resize:fit:1400/format:webp/1E3qz8MZ8zR7Y3NRghFOvJQ.png)기존의 CMS는 컨텐츠와 Head가 강하게 묶여있었다. Html에 하드코딩된 문자열들을 생각하면 된다.&..." }, { "title": "module federation", "url": "/posts/web-module-federation/", "categories": "study, web", "tags": "webpack", "date": "2023-03-05 23:00:00 +0900", "snippet": "webpack module federation여러 개의 개별 빌드가 단일 어플리케이션을 형성할 수 있도록 해주는 webpack의 기능이다. 개별 빌드는 컨테이너처럼 작동하며, 빌드 간에 코드를 노출하고 소비하여 단일 통합 애플리케이션을 생성할 수 있다.Low-Level concepts로컬 모듈과 원격 모듈을 구별한다. 로컬모듈 : 현재 빌드의 일부인 일반 모듈 원격모듈 : 현재 빌드의 일부가 아니며, 원격 컨테이너에서 런타임에 로드되는 모듈원격 모듈을 로드하는 것은 비동기 작업으로 간주된다. 원격 모듈을 사용할 때 이러한 ..." }, { "title": "SWR", "url": "/posts/react-SWR/", "categories": "study, react", "tags": "", "date": "2023-03-04 18:00:00 +0900", "snippet": "SWR은 vercel에서 제작한 React Hooks로, 먼저 캐시(stale)로부터 데이터를 반환한 후, fetch 요청(revalidate)을 하고, 최종적으로 최신화된 데이터를 가져오는 전략이다. 이름은 HTTP 캐시 무효 전략인 stale-while-revalidate에서 유래되었다. 공식사이트전체적인 기능은 React Query와 비슷하며 React Query 쪽의 커뮤니티가 더 크다. 따라서 사용하기 전에 장단을 잘 비교해보고 둘 중 하나를 선택하는 것이 좋을 것 같다.예시import useSWR from &#39..." }, { "title": "next.js Compiler", "url": "/posts/next.js-Compiler/", "categories": "study, next.js", "tags": "next.js", "date": "2023-02-13 22:00:00 +0900", "snippet": "Next.js의 컴파일러는 바벨 대신에 Rust 기반의 SWC를 JS 번들링에 사용한다. 이는 바벨보다 17배 빠르며, Next.js 12부터 디폴트로 쓰인다. 만약 바벨을 사용하고 싶다면, 다음을 참고하면 된다.Next.js Compiler의 자세한 내용은 공식 가이드에 나와있다. 이 글에서는 주로 사용할만한 요소만 요약하여 정리하였다.Supported Features Styled Components : bebel-plugin-styled-components와 연계하여 styled-components를 위한 바벨 설..." }, { "title": "next.js - Output File Tracing", "url": "/posts/next.js-Output-File-Tracing/", "categories": "study, next.js", "tags": "next.js", "date": "2023-02-12 23:00:00 +0900", "snippet": "next.js는 빌드 시 자동으로 모든 페이지와 그 의존성을 트랙킹하여 배포시 필요한 파일을 알아낸다. 이렇게 함으로써 배포될 파일의 크기를 줄일 수 있다.이전에 도커로 배포할 땐, 모든 의존성을 가져온 후 next start를 실행해야했다. 하지만 next.js 12부터는 Output File Tracing을 통해 .next/ 디렉터리만 있으면 된다. 단, standalone 모드를 켜야한다.동작방식next build가 실행되는 동안, next.js는 @vercel/nft를 사용하여 정적으로 import, require, f..." }, { "title": "next.js - Deployment", "url": "/posts/next.js-Deployment/", "categories": "study, next.js", "tags": "next.js", "date": "2023-02-12 22:00:00 +0900", "snippet": "Next build APInext build를 실행하면, 작성한 소스코드가 최적화된 상태도 빌드된다. 빌드된 결과물 .next 아래에 위치하며 구조는 다음과 같다. .next/static/chunks/pages : 라우트되는 이름 그대로 생성된 js 파일이 위치한다. (/about –&amp;gt; .next/static/chunks/pages/about.js) .next/static/media : next/image를 사용하여 정적으로 삽입된 이미지가 해시되어 위치한다. .next/static/css : 글로벌 CSS ..." }, { "title": "next.js - production 배포 전 체크리스트", "url": "/posts/next.js-production-%EB%B0%B0%ED%8F%AC-%EC%A0%84-%EC%B2%B4%ED%81%AC%EB%A6%AC%EC%8A%A4%ED%8A%B8/", "categories": "study, next.js", "tags": "", "date": "2023-01-31 23:00:01 +0900", "snippet": "next.js로 만든 앱을 배포하기 전 체크리스트 가능한만큼 캐싱을 적용했는가? 데이터베이스와 백엔드가 같은 region에 배포되어있는가? 가능한 최소한의 Javascript를 사용하는 것을 목표로 해라 Javascript 로딩을 가능한 연기하라 logging이 구현되어 있는가? errorHandling이 설정되어있는가? 404 페이지와 500 페이지를 만들었는가? 성능 측정을 해보아라 Lighthouse를 실행해서 테스트해보아라. 브라우저 호환성을 확인하라 성능을 높이기 위해 다음 기능을 사용하라 ..." }, { "title": "next.js - Script 컴포넌트", "url": "/posts/next.js-Script-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/", "categories": "study, next.js", "tags": "next.js", "date": "2023-01-31 23:00:00 +0900", "snippet": "next.js 에서는 페이지 성능 개선을 위해 서드파티 script를 가져올 수 있는 next/script 컴포넌트를 제공한다.사용법importimport Script from &#39;next/script&#39;Page script페이지 컴포넌트에서 사용될 수 있으며, 페이지가 브라우저에 로드되면 script를 fetch하고 실행한다.import Script from &#39;next/script&#39;export default function Dashboard() { return ( &amp;lt;&amp;gt;..." }, { "title": "next.js - Satic HTML Export", "url": "/posts/next.js-Satic-HTML-Export/", "categories": "study, next.js", "tags": "next.js", "date": "2023-01-29 22:00:01 +0900", "snippet": "next export 명령어를 통해 next.js 어플리케이션을 static HTML으로 만들 수 있다. 이렇게 만들어진 Static HTML은 Node.js 서버없이 운영이 가능하다. 다음과 같은 기능이 필요없다면, next export를 사용하는 것이 권장된다. Image Optimization (default loader) Internationalized Routing API Routes Rewrites Redirects Headers Middleware Incremental Static Regenerati..." }, { "title": "next.js - Automatic Static 최적화", "url": "/posts/next.js-Automatic-Static-%EC%B5%9C%EC%A0%81%ED%99%94/", "categories": "study, next.js", "tags": "next.js", "date": "2023-01-29 22:00:00 +0900", "snippet": "next.js에서는 어떤 페이지가 getServerSideProps 또는 getInitialProps를 가지고 있지 않다면, static 페이지로 결정한다. 이렇게 static 페이지로 결정되면, 빌드시 그 페이지는 static 페이지로 빌드된다.static 페이지는 서버사이드에서 렌더되지 않고 바로 유저에게 전달된다. end-user와 서버 사이에 CDN이 있다면 CDN의 적용 또한 받는다.query 객체 처리getServerSideProps 또는 getInitialProps가 없는 페이지는 빌드시 prerender 되어 s..." }, { "title": "next/image 컴포넌트", "url": "/posts/next.js-next-image-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/", "categories": "study, next.js", "tags": "next.js", "date": "2023-01-28 23:00:00 +0900", "snippet": "next.js에서는 next/image로 자체적인 이미지 컴포넌트를 제공한다. 일반적인 img 태그와는 달리 여러 성능 최적화기법이 내장되어있다. 기본적으로 다음과 같은 기능을 제공한다. 성능 향상 : 각 디바이스에 정확히 맞는 이미지를 모던 웹 포맷에 맞게 제공한다. Visual Stability : Cumulative Layout Shift를 자동으로 예방한다. Cumulative Layout Shift : 웹 화면의 레이아웃이 갑자기 바뀌는 것. 사용자가 의도치않은 동작을 실행할 수 있다. ..." }, { "title": "container 안에서 pm2로 next.js 앱 실행하기", "url": "/posts/next.js-container-%EC%95%88%EC%97%90%EC%84%9C-pm2%EB%A1%9C-next.js-%EC%95%B1-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0/", "categories": "study, next.js", "tags": "kubernetes", "date": "2023-01-25 23:00:00 +0900", "snippet": "next.js는 기본적으로 node.js runtime에서 작동된다. 하지만 node.js 는 싱글 스레드 기반이고, 따라서 트래픽이 많은 환경에서 multi-core를 사용하여 node.js 앱을 구동하기 위해선 다음과 같은 방법이 있다. worker thread child process cluster필자는 next.js에서 가장 사용하기 편한 방식인 cluster를 선택하였고, 편리하게 하기위해 pm2의 cluster 모드를 사용하기로 결정하였다. 환경은 kubernetes 환경으로 하나의 pod에 2~3개의 next..." }, { "title": "next.js - data fetching", "url": "/posts/next.js-data-fetching/", "categories": "study, next.js", "tags": "next.js", "date": "2023-01-23 22:00:00 +0900", "snippet": "next.js에서 사용자의 요청을 받고, 페이지를 만들어낼 때 외부 서버로 필요한 데이터를 요청해야할 때 사용하는 기법이다. data fetching은 기본적으로 페이지 컴포넌트에서 사용할 수 있고 경우에 따라 Custom App 컴포넌트에서도 사용할 수 있다.next 13부터는 app/ 구조를 사용한다면 일반 컴포넌트에서도 가능하다고 하지만, 현재(2023.01)는 next 13의 app/ 구조가 베타버전이라 pages/ 구조를 기준으로 작성하였다. Note: Next.js 13 introduces the app/ dire..." }, { "title": "php 기초 강의", "url": "/posts/php-php-%EA%B0%95%EC%9D%98/", "categories": "study, php", "tags": "", "date": "2022-12-25 16:00:00 +0900", "snippet": "PHP 기초PHP의 원리 웹브라우저에서 웹 서버로 index.php을 달라고 요청보냄 웹서버는 index.php을 처리할 수 있는 프로그램인 php에게 위임함 php는 index.php를 찾고, 해석해서 html 파일을 만듬. 웹 서버는 html을 받고 웹브라우저로 보내줌.PHP의 데이터 타입숫자와 산술연산자 int : 정수형 float : 소수형문자열과 문자열 처리 string ’’ ”” 연산자 . : 문자열 붙이기 ex) “hello “.”world” -&a..." }, { "title": "쿠버네티스 Ingress", "url": "/posts/devops-ingress/", "categories": "study, devops", "tags": "kubernetes", "date": "2022-12-15 19:00:00 +0900", "snippet": "쿠버네티스 Ingressingress는 일반적으로 외부로부터 서버 내부로 유입되는 네트워크 트래픽을 뜻한다.쿠버네티스에서는 ingress라는 리소스 오브젝트가 존재한다. 쿠버네티스의 ingress는 외부에서 쿠버네티스 클러스터 내부로 들어오는 http, https 요청을 어떻게 처리할지 정의한다. 즉, 외부에서 쿠버네티스에서 실행 중인 deployment와 service에 접근하기 위한 일종의 gateway 같은 역할을 담당한다.ingress를 사용하지 않으면 NodePort나 LoadBalancer를 사용하여 외부 요청을 받..." }, { "title": "nginx에서 환경변수 사용하는 방법", "url": "/posts/web-nginx%EC%97%90%EC%84%9C-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9/", "categories": "study, web", "tags": "", "date": "2022-12-05 21:00:00 +0900", "snippet": "nginx.conf 에서 환경변수 사용nginx.conf에서 환경변수를 사용하여 동적으로 nginx 설정을 변경하는 방법을 알아보자.envsubst 사용하는 방법envsubst는 인풋으로부터 $VARIABLE 또는 ${VARIABLE}로 되어있는 값을 읽어 환경변수로 바꾸어주는 프로그램이다. envsubst을 활용해서 nginx.template 파일로 환경변수가 사용된 nginx 설정파일을 작성하고, nginx가 실행될 때 envsubst를 사용해 변환해주면 된다.step 1 : nginx.template 파일 작성worker..." }, { "title": "kubernetes 실습", "url": "/posts/devops-kubenetes-%EC%8B%A4%EC%8A%B5/", "categories": "study, devops", "tags": "kubernetes", "date": "2022-11-30 18:29:26 +0900", "snippet": "이 포스트는 subicura 님의 kubenetes 안내서을 읽으며 요약/기록한 게시글입니다.Kubenetes 실습Pod 생성하기YAML로 설정파일 작성하여 생성하기apiVersion: v1kind: Podmetadata: name: echo labels: app: echospec: containers: - name: app image: ghcr.io/subicura/echo:v1 정의 설명 예 apiVersion API 서버..." }, { "title": "kubernetes", "url": "/posts/devops-kubernetes/", "categories": "study, devops", "tags": "kubernetes", "date": "2022-11-30 18:19:26 +0900", "snippet": "이 포스트는 subicura 님의 kubenetes 게시글을 읽으며 요약/기록한 게시글입니다.Kubenetes쿠버네티스(kubenetes, k8s)는 도커 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼이다.단순한 컨테이너 플랫폼이 아닌 마이크로 서비스, 클라우드 플랫폼을 지향하고 컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 한다.쿠버네티스 특징다양한 배포방식쿠버네티스는 다음과 같은 다양한 배포방식을 지원한다. Deployment : 새로운 버전의 매플리케이션을 다양한 전략으로..." }, { "title": "nginx + spring boot+ react로 구성된 앱 dockerfile 작성", "url": "/posts/devops-docker-nginx-+-spring-+-react-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B9%8C%EB%93%9C-%EB%B0%8F-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%8B%A4%ED%96%89/", "categories": "study, devops", "tags": "", "date": "2022-11-29 18:19:26 +0900", "snippet": "nginx + spring boot+ react로 구성된 앱 dockerfile 작성docker flow도커에서 이미지를 빌드하고, 앱이 실행되는 컨테이너를 실행하는 과정은 크게 이미지 빌드, 이미지 푸시, 컨테이너 실행 단계로 나뉜다. nginx + spring boot + react로 구성된 앱을 도커 이미지로 관리하려면 먼저 이미지를 빌드할 dockerfile을 잘 작성해야한다.먼저 이번 글에서 사용될 프로젝트(빌드 컨텍스트)의 디렉터리 구조부터 알아보자프로젝트 구조.├── Dockerfile├── nginx.conf└─..." }, { "title": "SockJS", "url": "/posts/web-SockJS/", "categories": "study, web", "tags": "web", "date": "2022-11-23 21:19:26 +0900", "snippet": "SockJS주로 Spring을 사용할 때, WebSocket Emulation 을 위한 라이브러리이다.WebSocket Emulation 이란 우선 웹 소켓으로 소켓 연결을 시도하고, 실패할 경우 HTTP Streaming, Long-Polling 같은 HTTP 기반의 다른 기술로 전환해 다시 연결을 시도하는 것을 말한다. 따라서 다음과 같은 상황에서 도움이 된다 WebSocket을 지원하지 않는 브라우저 Server/Client 중간에 위치한 Proxy가 Upgrade 헤더를 해석하지 못해 서버에 전달하지 못한 상황 S..." }, { "title": "서블릿 컨테이너", "url": "/posts/spring-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/", "categories": "study, spring", "tags": "spring", "date": "2022-11-21 21:19:26 +0900", "snippet": "서블릿 컨테이너는 서블릿들의 생성, 실행, 파괴를 담당하며 서블릿을 관리해준다. 서블릿 컨테이너는 클라이언트의 요청을 받고 응답할 수 있게, 웹 서버와 소켓을 만들어 통신한다.서블릿 컨테이너의 대표적인 무료 서비스로 톰캣이 있다. 톰캣은 웹 서버와 소켓을 만들어 통신하며 JSP와 서블릿이 작동할 수 있는 환경을 제공한다.서블릿이란?웹 프로그래밍에서 클라이언트의 HTTP 요청을 처리하고 응답을 보내는 자바 프로그래밍 기술. Servlet 클래스의 구현 규칙을 따른다.Servlet 은 javax.servlet 패키지에 정의된 인터..." }, { "title": "ElasticSearch", "url": "/posts/DB-ElasticSearch/", "categories": "study, database", "tags": "db", "date": "2022-11-21 21:18:26 +0900", "snippet": " Elasticsearch는 시간이 갈수록 증가하는 문제를 처리하는 분산형 RESTful 검색 및 분석 엔진입니다. Elastic Stack의 핵심 제품인 Elasticsearch는 데이터를 중앙에 저장하여 손쉽게 확장되는 광속에 가까운 빠른 검색, 정교하게 조정된 정확도, 강력한 분석을 제공합니다. (ElasticSearch 공식 문구)ElasticSearch는 Apache Lucene(아파치 루씬) 기반의 Java 오픈소스 분산 검색엔진이다. ElasticSearch를 통해 루씬 라이브러리를 단독으로 사용할 수 있게 되..." }, { "title": "Apache Kafka", "url": "/posts/design-pattern-Apache-Kafka/", "categories": "study, design pattern", "tags": "kafka", "date": "2022-11-18 23:00:26 +0900", "snippet": "Apache Kafka는 빠르고 확장 가능한 작업을 위해 데이터 피드의 분산 스트리밍, 파이프 라이닝 및 재생을 위한 실시간 스트리밍 데이터를 처리하기 위한 목적으로 설계된 오픈 소스 분산형 게시-구독 메시징 플랫폼이다.Kafka는 서버 클러스터 내에서 데이터 스트림을 레코드로 유지하는 방식으로 작동하는 브로커 기반 솔루션이다. Kafka 서버는 여러 데이터 센터에 분산되어 있을 수 있으며 여러 서버 인스턴스에 걸쳐 레코드 스트림(메시지)을 토픽으로 저장하여 데이터 지속성을 제공할 수 있다.Apache Kafka의 구성요소 ..." }, { "title": "커스텀 Annotation", "url": "/posts/java-%EC%BB%A4%EC%8A%A4%ED%85%80-annotation/", "categories": "study, java", "tags": "java", "date": "2022-11-18 18:19:26 +0900", "snippet": "Annotation애노테이션은 Java 5 부터 등장한 기능으로, 사전적의미는 “주석”이지만, 클래스나 메서드 등 타켓에 라벨을 붙여준다. 비즈니스 로직에는 영향을 주지는 않지만, 해당 타켓의 연결 방법이나 소스 코드의 구조를 변경할 수도 있다. 애노테이션은 소스코드에 메타데이터를 삽입하는 것이기 때문에 잘 이용하면 구독성뿐만 아니라 체계적인 소스코드 구성에도 도움을 준다.// 애노테이션 예시@Servicepublic class ArticleService커스텀 Annotation커스텀 애노테이션은 메타 애노테이션을 사용하여 다..." }, { "title": "STOMP", "url": "/posts/web-STOMP/", "categories": "study, web", "tags": "web", "date": "2022-11-17 18:19:26 +0900", "snippet": "STOMP(Simple Text Oriented Messaging Protocol)란?웹소켓 위에서 동작하는 서브 프로토콜로, 클라이언트와 서버가 서로 통신하는데 있어 메시지의 형식, 유형, 내용 등을 정의해주는 프로토콜이다.웹 소켓 프로토콜은 Text 또는 binary 두가지 유형의 메시지 타입을 정의하지만 메시지의 내용에 대해서는 정의하지 않는다. 즉, 웹 소켓만 사용해서 구현하게 되면 해당 메시지가 어떤 요청인지, 어떤 포맷으로 오는지 정해져있지 않아 일일이 구현해야한다.이때 STOMP라는 프로토콜을 서브 프로토콜로 사용..." }, { "title": "mybatis.type-aliases-package", "url": "/posts/spring-mybatis.type-aliases-package-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC/", "categories": "study, spring", "tags": "", "date": "2022-11-17 16:19:26 +0900", "snippet": "mybatis mapper에서 requestType이나 parameterType으로 클래스를 참조할 때 다음과 같이 패키지명을 다 써줘야하는 불편함이 있다.&amp;lt;mapper namespace=&quot;com.hello.spring.article.mapper.ArticleMapper&quot;&amp;gt; &amp;lt;select id=&quot;selectArticles&quot; resultType=&quot;com.hello.spring.article.dto.ArticleDto&quot;&amp;gt; ..." }, { "title": "좋은 로깅을 위해 알아야할 13가지", "url": "/posts/design-pattern-%EC%A2%8B%EC%9D%80-%EB%A1%9C%EA%B9%85%EC%9D%84-%EC%9C%84%ED%95%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EA%B2%83/", "categories": "study, design pattern", "tags": "design", "date": "2022-11-17 15:23:26 +0900", "snippet": "이 글은 Logging Best Pratices : The 13 You Should Know를 기반으로 요약, 학습한 글입니다.좋은 로깅을 위해 알아야할 13가지Don’t write logs by yourselfprintf을 사용하거나 파일에 직접 입력하지마라. 로깅을 위한 표준 라이브러리를 사용하라.표준 라이브러리를 사용할 때 장점 어플리케이션의 다른 부분과 잘 조화됨을 보장할 수 있음 올바른 곳에 로그를 남길 수 있음.표준 라이브러리 종류 syslog() log4j, logbackLog at the proper le..." }, { "title": "SpEL - Spring Expression Language", "url": "/posts/spring-SpEL/", "categories": "study, spring", "tags": "", "date": "2022-11-14 23:19:26 +0900", "snippet": "이 문서는 개인적인 목적이나 배포하기 위해서 복사할 수 있다. 출력물이든 디지털 문서든 각 복사본에 어떤 비용도 청구할 수 없고 모든 복사본에는 이 카피라이트 문구가 있어야 한다. (출처)SpEL - Spring Expression Language객체를 조회하고 조작하는 기능을 제공하며, 메서드 호출, 물자열 템플릿 기능 등의 여러가지 추가기능을 제공하는 표현식 언어이다. OGNL 등 자바에서 사용가능한 여러 EL이 있지만, SpEL은 Spring 프로젝트 전반에 걸쳐 사용하기 위해 만들어졌으며 스프링 3.0부터 지원한다.Sp..." }, { "title": "빈 스코프", "url": "/posts/spring-%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "study, spring", "tags": "", "date": "2022-11-13 21:19:26 +0900", "snippet": "빈 스코프는 말 그대로 빈이 존재할 수 있는 범위를 뜻한다. 스프링에서는 다음과 같은 스코프를 지원한다 싱글톤 : 기본 스코프. 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다. 웹 관련 스코프 request : 웹 요청이 들어오고 나갈때까지 유지되는 스코프 session : 웹 세션이 생성되고 종료될 때까지 유지되는 스코프 applica..." }, { "title": "ResponseStatus vs ResponseEntity", "url": "/posts/spring-@ResponseStatus-vs-ResponseEntity/", "categories": "study, spring", "tags": "", "date": "2022-11-13 18:23:26 +0900", "snippet": "​@ResponseStatus응답으로 보낼 데이터의 HttpStatus를 명시해주는 방법이다. 컨트롤러에서 Body 데이터만 반환하는 경우 HttpStatus를 명시하기 위해 사용한다.@ResponseStatus(HttpStatus.OK)@GetMapping(&quot;/article&quot;)public ArticleListDto getArticles(SelectArticlesQuery query) { ArticleListDto articleListDto = articleService.getArticleList(query..." }, { "title": "단일책임원칙(SRP)", "url": "/posts/design-pattern-%EB%8B%A8%EC%9D%BC%EC%B1%85%EC%9E%84%EC%9B%90%EC%B9%99/", "categories": "study, design pattern", "tags": "oop", "date": "2022-11-13 18:19:26 +0900", "snippet": "좋은 OOP 설계에서 지켜져야하는 규칙인 SOLID 중 S인 규칙으로, 하나의 모듈은 하나의 책임을 가져야한다는 원칙을 말한다. 클래스는 단 한개의 책임을 가져야한다. 하나의 모듈은 오직 하나의 액터에 대해서만 책임져야한다. 클래스를 변경하는 이유는 단 한개여야 한다.여기서 책임은 액터에 대한 책임을 의미한다. 하나의 액터에 대해 하나의 책임을 지는 객체를 정의하고 사용하라는 것이다. 액터는 시스템과 상호작용하는 시스템 외부의 어떤 존재를 뜻하는 말로, 시스템의 이해관계자로 정의할 수 있다. 쇼핑 앱을 예로 들면, 물건을..." }, { "title": "RestTemplate", "url": "/posts/spring-RestTemplate/", "categories": "study, spring", "tags": "", "date": "2022-11-12 20:19:26 +0900", "snippet": "스프링에서 지원하는 객체로, 간편하게 Rest 방식 API를 호출할 수 있는 스프링 내장 클래스다.스프링 3.0부터 지원하였고, json, xml 응답을 모두 받을 수 있다.특징 Blocking I/O 기반의 동기방식을 사용하는 템플릿 RESTful 형식에 맞추어진 템플릿 Header, Content-Type 등을 설정하여 외부 API 호출 Server to Server 통신에 사용동작원리 애플리케이션 내부에서 REST API에 요청하기 위해 RestTemplate의 메서드를 호출한다. RestTemplate은 Me..." }, { "title": "lombok 사용시 주의점", "url": "/posts/java-lombok-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%A0%90/", "categories": "study, java", "tags": "", "date": "2022-11-12 19:19:26 +0900", "snippet": "lombok은 @Getter, @Setter 같은 애노테이션 기반으로 Getter/Setter 메서드를 자동으로 생성해주는 편리한 라이브러리이다.하지만 편리함에 남용하는 애노테이션들이 있다.lombok 사용 시 주의해야할 애노테이션@AllArgsConstructor클래스에 존재하는 모든 필드에 대한 생성자를 자동으로 생성한다.@AllArgsConstructorpublic class User { private String name; private String userId; // 자동 생성 public User(Stri..." }, { "title": "json 응답 시 특정 필드 빼고 보내기", "url": "/posts/spring-Json-%EC%9D%91%EB%8B%B5-%EC%8B%9C-%ED%8A%B9%EC%A0%95-%ED%95%84%EB%93%9C-%EB%B9%BC%EA%B3%A0-%EB%B3%B4%EB%82%B4%EA%B8%B0/", "categories": "study, spring", "tags": "", "date": "2022-11-12 18:19:26 +0900", "snippet": "스프링에서는 Http 메시지 컨버터를 통해 사용자가 보낸 데이터와 서버에서 내보내는 데이터를 자동으로 변환해준다. 만약 다음과 같은 객체를 응답으로 보낼 경우 Content-Type이 application/json이라면, 스프링은 다음 객체를 자동으로 Json 형식으로 바꾸어 내보낸다.@AllArgsConstructor@Getterpublic class UserDto { private String userId; private String password;}// UserDto user = new UserDto(&quot;..." }, { "title": "junit - spy", "url": "/posts/java-junit-Spy/", "categories": "study, java", "tags": "", "date": "2022-11-12 18:19:26 +0900", "snippet": "Mock 객체와는 달리 객체의 특정 메서드만 stub으로 대체할 수 있는 방법을 제공한다.다음과 같이 만약 테스트 대상 객체의 특정한 메서드를 stub 처리하고 싶을 때 사용한다.@ExtendWith(MockitoExtension.class)public class BoardServiceTest{ @Spy private BoardService boardService; @Test public void 인증_실패시_예외발생() { // boardService의 인증을 담당하는 메서드를 stub 처리함 doR..." }, { "title": "equals(), hashCode()", "url": "/posts/java-equals-hashcode-%EB%8C%80%EC%B2%B4/", "categories": "study, java", "tags": "java", "date": "2022-11-12 15:19:26 +0900", "snippet": "equals()와 hashCode() 메서드는 모든 자바 객체의 부모인 Object 클래스에 정의되어있다. 따라서 모든 자바 객체는 equals()와 hashCode() 메서드를 가지고 있다.equals()현재 객체와 파라미터로 들어온 객체가 같은 지 검사하기 위해 사용한다. 기본적으로는 두 객체의 메모리 주소가 같아야 동일한 객체가 된다.public boolean equals(Objecet obj) { return (this == obj);}이러한 equals 객체를 오버라이드하여 필드값이 같은 객체를 같은 객체라고 판단하..." }, { "title": "Content-Disposition", "url": "/posts/web-Content-Disposition/", "categories": "study, web", "tags": "web", "date": "2022-11-11 18:20:26 +0900", "snippet": "HTTP Response Body에 오는 컨텐츠의 기질/성향을 알려주는 HTTP 헤더 속성이다. inline : 디폴트 값. body에 있는 값이 웹 페이지에 표시되어야한다는 뜻. Content-Disposition : inline 최신 브라우저에서 &amp;lt;a&amp;gt; 태그의 download 속성은 Content-Disposition : inline으로 가져온다. attachment : body에 있는 데이터를 다운 받아야한다는 뜻. filename이 명시되어있다면..." }, { "title": "스프링 캐시", "url": "/posts/spring-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BA%90%EC%8B%9C/", "categories": "study, spring", "tags": "spring", "date": "2022-11-11 18:19:26 +0900", "snippet": "[spring] 스프링 캐시캐시란 반복적으로 데이터를 불러올 때 지속적으로 DBMS 혹은 서버에 요청하는 것이 아닌 메모리에 데이터를 저장하였다가 데이터를 불러다가 쓰는 것을 말한다. 서버나 DBMS의 부담을 줄여주고, 메모리에 저장되어있기 때문에 많은 시스템에서 사용할수 있다.캐시는 Long Tail 법칙에 따라 시스템 리소스 사용의 대부분을 차지하는 20%의 요청을 캐싱하면 시스템 전체가 매우 빨라진다고 할 수 있다.CacheManager스프링 부트에서 spring-boot-starter-cache을 추가하여 구성할 수 있..." }, { "title": "PathPattern과 servletPath", "url": "/posts/spring-PathPattern%EA%B3%BC-servletPath/", "categories": "study, spring", "tags": "spring", "date": "2022-11-10 18:25:26 +0900", "snippet": "[spring] PathPattern과 servletPath문제다음과 같이 interceptor를 등록할 때, addPathPatterns()에 /api/**를 등록하였지만, /api/article을 요청했을 때 인터셉터가 제대로 동작하지 않았다. 하지만 /**로 등록하니 제대로 동작하였다.public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(authInterceptor) .order(1) .addPathPatterns(&..." }, { "title": "checked vs unchecked exception", "url": "/posts/java-checked-vs-unchecked-exception/", "categories": "study, java", "tags": "java", "date": "2022-11-10 18:24:26 +0900", "snippet": "[java] checked vs unchecked exception자바에서 프로그램에 이상이 있을 때 던져지는 Throwable은 Error와 Exception이 있다. Error : 시스템이 비정상적인 상황에 있다는 것을 의미. 시스템 레벨에서 발생하는 심각한 오류이기 때문에 개발자가 미리 예측하거나 처리할 수 없다. ex) OutOfMemoryError, ThreadDeath Exception : 개발자들이 만든 애플리케이션 코드에서 예외가 발생했다는 것을 의미한다. Check..." }, { "title": "HPA", "url": "/posts/devops-HPA/", "categories": "study, devops", "tags": "kubernetes", "date": "2022-11-10 18:23:26 +0900", "snippet": "[devops] HPAHorizontalPodAutoscaler의 약자로, k8s에서 CPU 사용률을 체크하여 Pod의 개수를 스케일링하는 기술이다. 지정한 메트릭을 controller가 체크하여 부하에 따라 필요한 pod의 replica 수가 되도록 자동으로 pod 수를 늘리거나 줄일 수 있는 기술이다.Auto scalingAuto scaling은 사용자가 정의한 주기(스케줄링)나 이벤트(모니터링 알람)에 따라 서버를 자동으로 생성하거나 삭제한다. 서비스 트래픽에 따라 서버를 늘리거나 줄여 발생하는 요금을 최소화한다.![0F..." }, { "title": "Helm", "url": "/posts/devops-Helm/", "categories": "study, devops", "tags": "kubernetes", "date": "2022-11-10 18:21:26 +0900", "snippet": "HelmKubernetes 패키지 관리를 도와주는 도구. node.js의 npm과 같은 역할을 수행한다.Helm을 사용하면 쿠버네티스 클러스터에서 동작하도록 작성된 패키지들을 관리할 수 있다. 즉, Helm을 사용하면 클러스터에 배포한 애플리케이션을 쉽게 설치, 업데이트, 삭제할 수 있다.일반적으로 쿠버네티스는 여러 오브젝트로 구성되어있는데, 만약 애플리케이션을 새로 업데이트하고 싶으면, 애플리케이션을 포함하는 모든 오브젝트마다 kubectl 명령을 날려야하는데, Helm을 사용하면 하나의 명령으로 애플리케이션을 배포할 수 있..." }, { "title": "Canary 테스트", "url": "/posts/devops-Canary-%ED%85%8C%EC%8A%A4%ED%8A%B8/", "categories": "study, devops", "tags": "", "date": "2022-11-10 18:20:26 +0900", "snippet": "[devops] Canary 테스트안정적인 버전을 릴리즈하기 전에 테스트 버전을 일부 사용자에게 배포하는 것을 말한다.만약 카나리 버전에 심각한 버그가 발생한다해도 사용하는 사용자가 적기 때문에 피해를 최소화할 수 있다. 또한 안정적인 버전과 테스트 버전이 모두 배포된 상태이기 때문에 A/B 테스트가 가능하다.유저가 직접 카나리 버전을 설치하는 경우도 있지만, 유저는 모르고 사용하도록 할 수 있다. 일부의 유저만 새로운 버전으로 서비스를 제공하는 방식이다.출처https://codechacha.com/ko/what-is-cana..." }, { "title": "blue-green 배포", "url": "/posts/devops-blue-green-%EB%B0%B0%ED%8F%AC/", "categories": "study, devops", "tags": "", "date": "2022-11-10 18:19:26 +0900", "snippet": "[devops] blue-green 배포애플리케이션의 이전 버전에 있던 사용자 트래픽을 이전 버전(blue)과 거의 동일한 새 버전(green)으로 점진적으로 이전하는 애플리케이션 배포 모델이다. 이때 두 버전 모두 프로덕션 환경에서 실행 상태를 유지한다.blue에서 green으로 완전히 이전되면 blue는 롤백에 대비하여 대기 상태에 두거나 프로덕션에서 가져온 후 업데이트하여 다음 업데이트의 템플릿으로 삼을 수 있다.k8s는 클라우드 네이티브 애플리케이션의 마이크로서비스를 패키지화하는 컨테이너의 오케스트레이션을 지원하며, 개..." }, { "title": "스프링 파일업다운로드", "url": "/posts/spring-%ED%8C%8C%EC%9D%BC-%EC%97%85%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C/", "categories": "study, spring", "tags": "", "date": "2022-11-09 18:19:26 +0900", "snippet": "[spring] 파일 업/다운로드HTML 폼 전송 방식HTML에서 폼을 전송하는 방식(Content-Type)에는 다음 두가지가 있다. application/x-www-form-urlencoded : 문자와 같은 데이터를 키와 함께 전송하는 방식 ex) username=Kim&amp;amp;age=20 multipart/form-data : 여러 개의 데이터를 파트별로 나누어 전송하는 방식. 파일과 같은 바이너리 데이터를 전송할 때 쓰임. Content-Type: multipa..." }, { "title": "Spring 파라미터 Validation", "url": "/posts/spring-Validation/", "categories": "study, spring", "tags": "", "date": "2022-11-09 18:19:26 +0900", "snippet": "[spring] 파라미터 validationBindingResultHTTP 메세지 컨버터에서 발생한 데이터 바인딩 오류를 담아 컨트롤러에서 이용할 수 있는 객체. 다음과 같이 바인딩 오류가 발생할 수 있는 파라미터 바로 다음에 파라미터로서 추가한다.@PostMapping(&quot;/add&quot;)public String addItemV1(@ModelAttribute Item item, BindingResult bindingResult)컨트롤러에서 데이터 바인딩 오류가 발생하면 400 오류를 클라이언트로 전달한다. 하지만 ..." }, { "title": "유닛테스트 구현 검증이란?", "url": "/posts/design-pattern-%EC%9C%A0%EB%8B%9B%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%ED%98%84-%EA%B2%80%EC%A6%9D%EC%9D%B4%EB%9E%80/", "categories": "study, design pattern", "tags": "design", "date": "2022-11-09 18:19:26 +0900", "snippet": "비즈니스 코드를 먼저 작성하고 유닛테스트를 작성할 때, 완성된 코드를 보고 테스트 코드를 작성하다보면 내부 구현에 맞추어 테스트를 작성하게 되고, 구현 자체를 검증하게 되는 일이 많이 발생하였다.유닛 테스트에서는 구현이 아닌 행동을 검증(test behaviour, not implementation)해야한다. 따라서 구현을 검증한 테스트 코드를 고치려 했으나 어디까지가 구현을 검증한 것인지가 모호했다. A 메서드 안에서 B 메서드를 제대로 호출했는지를 보는 것도 구현 검증일까? 구현 검증을 피하고자 DB를 검사해도 되는 걸..." }, { "title": "Keep-Alive", "url": "/posts/web-keep-alive/", "categories": "study, web", "tags": "web", "date": "2022-11-05 18:51:26 +0900", "snippet": "아래와 같이 http 헤더를 보다보면 keep-alive라고 명시된 부분이 보일 때가 있다. connection : keep-alive Keep-Alive:timeout=5, max=1000이 keep-alive는 무슨 뜻일까 궁금하여 찾아보았다.keep-aliveconnection : keep-alive connection은 네트워크 연결을 현재 요청이 종료된 이후에도 유지할 것인가를 설정하는 헤더이다. 다음과 같은 값을 지정할 수 있음 close : 한 요청이 종료되면 연결을 끊음. 디폴트 ..." }, { "title": "CORS", "url": "/posts/web-CORS/", "categories": "study, web", "tags": "cors", "date": "2022-11-05 18:44:26 +0900", "snippet": " CORS : Cross-Origin Resource Sharing(교차 출처 리소스 공유)서로 다른 출처(Origin)에서 리소스를 공유할 때 적용되는 정책이다.출처(Origin)이란?URL은 다음과 같이 여러 개의 구성요소로 이루어져있다.여기서 출처란 protocol + host + port 을 뜻한다. 이 조합이 같아야 같은 출처로 인정된다. 이때 http, https는 각각 80 443 포트로 추정되어 생략되어도 된다 하지만 만약 http://google.com:80 같이 포트 번호가 명시되어있다면 포트번호까지 모..." }, { "title": "mybatis dynamic field", "url": "/posts/spring-mybatis-dynamic-field/", "categories": "study, spring", "tags": "", "date": "2022-11-05 18:41:26 +0900", "snippet": "게시글 검색을 개발하는 도중 검색의 대상이 되는 field(title | nickname | content)를 동적으로 mybatis 쿼리문 상에 사용해야할 일이 있었다. 따라서 다음과 같이 #{} 를 사용하여 변수를 넣었으나 오류가 발생했다.&amp;lt;where&amp;gt; &amp;lt;when test=&quot;type != &#39;hashtag&#39;&quot;&amp;gt; atc.#{type} LIKE concat(&#39;%&#39;, #{keyword}, &#39;%&#39;) &amp;lt;/whe..." }, { "title": "InvalidDefinitionException", "url": "/posts/spring-InvalidDefinitionException/", "categories": "study, spring", "tags": "", "date": "2022-11-05 18:36:26 +0900", "snippet": "@ResquestBody로 받는 매개변수의 클래스에 @NoArgsConstructor를 빼니 InvalidDefinitionException 에러가 발생했다.@PostMapping(&quot;/login&quot;)public String login(@Valid @RequestBody LoginRequestBody loginRequestBody)@Getter@AllArgsConstructor@ToStringpublic class LoginRequestBody { com.fasterxml.jackson.databind.exc...." }, { "title": "interceptor", "url": "/posts/spring-Interceptor/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:35:26 +0900", "snippet": "스프링 인터셉터는 스프링 MVC가 제공하는 기술로, 서블릿 필터하고는 적용순서, 범위, 사용방법이 다르다.소개스프링 인터셉터 흐름 HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 서블릿 -&amp;gt; 스프링 인터셉터 -&amp;gt; 컨트롤러 스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출됨. 스프링 인터셉터는 스프링 MVC가 제공하는 기능으로, 디스패처 서블릿 이후에 등장하게 된다. 스프링 MVC의 시작점이 디스패처 서블릿이라고 생각하..." }, { "title": "HTTP 메시지 컨버터", "url": "/posts/spring-HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%BB%A8%EB%B2%84%ED%84%B0/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:34:26 +0900", "snippet": "스프링에서 컨트롤러를 개발하다보면, url 파라미터를 long 으로 받아도 문제없이 작동된다.@GetMapping(path = &quot;/article/{articleId}&quot;)public String getArticleDetail(@PathVariable long articleId) {위와 같은 컨트롤러가 있을 때, 유저는 /article/123라는 요청을 보내면 자동으로 getArticleDetail의 매개변수인 articleId에 123 값이 문제없이 할당된다.URL 파라미터는 기본적으로 문자열로 인식다. 하지만..." }, { "title": "Pure DI - IoC가 없는 DI", "url": "/posts/spring-DI%EB%8A%94-IOC%EB%A5%BC-%ED%95%84%EC%9A%94%EB%A1%9C%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4(%EC%A0%95%EB%A6%AC)/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:34:26 +0900", "snippet": "이 포스트는 참고문서를 필자가 이해하기 쉽게 정리한 내용입니다.DI는 IoC를 사용하지 않아도 된다DI(Dependency Injection)다음 PizzaStore 클래스는 정해진 개수의 Pizza인스턴스를 가지고 있다. 만약 Pizza가 더 필요하면 PizzaStore를 직접 수정해야하다. 이는 OCP를 위반하며 DI로 해결해줄 수 있다public class PizzaStore{ private readonly Pizza[] pizzas = new Pizza[] { new P..." }, { "title": "converter", "url": "/posts/spring-converter/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:33:26 +0900", "snippet": "controller 인자로 enum 받는 문제를 해결했던 것은 enum 타입에 맞춘 Converter를 bean에 등록하는 것이었다. 단순히 bean에 등록하는 것으로 controller에서 httpConverter 동작할 때 이것을 적용한 것이다. 이 뒤에 무엇이 있을까 하여 조사해보았다.스프링에서는 기본적인 타입 변환은 자동으로 지원한다. 따라서 파라미터로 넘어온 문자 데이터가 컨트롤러에서 직접 Integer 타입으로 변환된다.@GetMapping(path = &quot;/{articleId}&quot;)public Str..." }, { "title": "controller에서 enum을 인자로 받기", "url": "/posts/spring-controller%EC%97%90%EC%84%9C-enum%EC%9D%84-%EC%9D%B8%EC%9E%90%EB%A1%9C-%EB%B0%9B%EA%B8%B0/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:32:26 +0900", "snippet": "검색 API를 개발하는 과정에서 다음과 같이 검색 타입을 enum 으로 지정하였고, controller의 param으로 받으려고 했다.@Getter@AllArgsConstructorpublic enum SearchType { TITLE(&quot;title&quot;), CONTENT(&quot;content&quot;), HASHTAG(&quot;hashtag&quot;), NICKNAME(&quot;nickname&quot;); private final String type;}public class ArticleSearch..." }, { "title": "ArgumentResolver 활용", "url": "/posts/spring-ArgumentResolver-%ED%99%9C%EC%9A%A9/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:31:26 +0900", "snippet": "ArgumentResolver 활용ArgumentResolver는 스프링 MVC 구조의 어댑터 핸들러에서 핸들러에 필요한 파라미터를 만들어주는데 호출하는 부분이다. 이 ArgumentResolver를 직접 구현하여 활용하면 다양한 상황에서 편리하게 적용할 수 있다.로그인 회원 정보를 편리하게 받아오는 예제컨트롤러@GetMapping(&quot;/&quot;)public String homeLoginV3ArgumentResolver(@Login Member loginMember, Model model)Login 어노테이션@Tar..." }, { "title": "Valid vs Validatedated", "url": "/posts/spring-@Valid-vs-@Validated/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:25:26 +0900", "snippet": "@Valid JSR-303 표준 객체 제약조건 검증 어노테이션 ArgumentResolver에 의해 처리된다. 검증에 오류가 있다면 MethodArgumentNotValidException 예외가 발생하며 디스패처 서블릿에 기본으로 등록된 예외 리졸버인 DefaultHandlerExceptionResolver에 의해 400 에러가 발생한다. 스프링에서는 ArgumentResolver에 의해 처리되기에 @Valid는 기본적으로 컨트롤러에서만 동작하며 다른 계층에서는 검증되지 않는다. 다른 계층에서 파라미터를 검증하기 위해..." }, { "title": "클래스 초기화 블록", "url": "/posts/java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B8%94%EB%A1%9D/", "categories": "study, java", "tags": "java", "date": "2022-11-05 18:24:26 +0900", "snippet": "클래스 초기화 블록어떤 클래스에 static 변수를 추가했더니 github copilot이 다음과 같은 문장을 추천해주었다.public class Crypto { private static CryptoProperties cryptoProperties; // github copilot suggestion static { cryptoProperties = new CryptoProperties(); } ...처음보는 문법이기에 조사해보았더니 클래스 초기화 블록이라는 단어를 접할 수 있었다.클래스 초기화 블록클래스의 멤버변수를 초..." }, { "title": "pinpoint", "url": "/posts/devops-pinpoint/", "categories": "study, devops", "tags": "pinpoint", "date": "2022-11-05 18:23:26 +0900", "snippet": "Pinpoint Pinpoint는 대규모 분산 시스템의 성능을 분석하고 문제를 진단, 처리하는 플랫폼입니다. 2012년 7월에 개발을 시작해 2015년 1월 9일에 오픈소스로 공개했습니다Pinpoint 개발 동기와 Pinpoint의 특징인터넷 서비스의 시스템 복잡도가 증가함에 따라 장애나 성능 문제가 발생했을 때 해결이 어려워졌다. 네이버의 시스템도 마찬가지였다. 시스템 복잡도가 높아지며 발생하는 문제를 해결하기 위해 n계층 아키텍처를 효과적으로 추적할 수 있는 새로운 플랫폼을 개발하기로 했고 그것이 Pinpoint이다.Pi..." }, { "title": "istio", "url": "/posts/devops-istio/", "categories": "study, devops", "tags": "istio", "date": "2022-11-05 18:21:26 +0900", "snippet": "Istio istio는 service mesh를 위한 tool입니다. istio를 사용하면 MSA(Micro Service Architecture)를 적용할 때 반복적으로 설정해야하는 L7/모니터링을 쉽고 간편하게 설정할 수 있습니다.Service meshService mesh는 API 등을 사용하여 마이크로 서비스 간 통신을 안전하고, 빠르고, 신뢰할 수 있게 만들기 위해 설계된 전용 인프라 계층이다. Service mesh는 보통 application 서비스에 경량화 프록시를 사이드카 방식으로 배치하여 서비스 간 통신을..." }, { "title": "사이드카 패턴", "url": "/posts/devops-%EC%82%AC%EC%9D%B4%EB%93%9C%EC%B9%B4-%ED%8C%A8%ED%84%B4/", "categories": "study, devops", "tags": "sidecar", "date": "2022-11-05 18:20:26 +0900", "snippet": "사이드카 패턴쿠버네티스의 패턴 중 하나로, 어플리케이션 컨테이너와 독립적으로 동작하는 별도의 컨테이너를 붙이는 패턴이다. 어플리케이션 컨테이너의 변경이나 수정 없이 독립적으로 동작하는 컨테이너를 붙였다 뗐다 할 수 있다.파드에서의 사이드카파드는 쿠버네티스에서 가장 기본적인 배포 단위로서 자신에게 속한 컨테이너들에게 런타임제약을 걸 수 있다. 예를 들어 모든 컨테이너는 동일한 노드에 배치되고, 동일한 파드 수명주기를 공유하게 할 수 있다. 파드는 또한 컨테이너들이 볼륨을 공유하고 로컬 네트워크 또는 호스트 IPC를 통해 서로 통..." }, { "title": "API 예외처리", "url": "/posts/spring-API-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:17:26 +0900", "snippet": "예외 발생 시에도 JSON 응답 보내기ResponseEntity를 사용해서 응답을 보내면 된다.public ResponseEntity&amp;lt;String&amp;gt; errorPage500Api() { String result = &quot;error&quot;; return new ResponseEntity(result, HttpStatus.BAD_REQUEST.value());}ResponseEntity를 사용해서 응답하기 때문세 메시지 컨버터가 동작하면서 클라이언트에 JSON이 반환된다.스프링부트 예외 처리Basi..." }, { "title": "AOP", "url": "/posts/spring-AOP/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:16:26 +0900", "snippet": " AOP = Aspect Oriented Programming = 관점 지향 프로그래밍관점 지향이란 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 모듈화 하겠다는 것이다. 여기서 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다.AOP에서 각 관점을 기준으로 모듈화한다는 것은 코드들을 부분적으로 나누어서 모듈화하겠다는 의미다. 개발을 하다보면 서로 다른 파일에서 같은 코드를 반복해서 쓰는 경우가 있는데 이것을 흩어진 관심사(crosscutting concerns)..." }, { "title": "ModelAttribute와 NoArgsConstructor 추가 시 아무것도 안들어가는 이슈", "url": "/posts/spring-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-@NoArgsConstructor-%EC%9D%B4%EC%8A%88/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:15:26 +0900", "snippet": "제목 그대로 다음과 같이 @NoArgsConstructor 애노테이션을 @ModelAttribute로 적용되는 컨트롤러 파라미터 클래스에 추가하니 제대로 쿼리를 날려도 아무것도 안들어가는 이슈가 발생했다.@GetMapping(&quot;/article&quot;)public ResponseEntity getArticles(@ModelAttribute SelectArticlesQuery query)@Getter@AllArgsConstructor@NoArgsConstructor@ToStringpublic class SelectAr..." }, { "title": "컨트롤러 매개변수/반환 타입 유형", "url": "/posts/spring-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EB%B0%98%ED%99%98-%ED%83%80%EC%9E%85-%EC%9C%A0%ED%98%95/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:14:26 +0900", "snippet": "요청파라미터(쿼리, form 데이터)HttpServletRequest@RequestMapping(&quot;/request-param-v1&quot;)public void requestParamV1(HttpServletRequest request, HttpServletResponse response)HttpServletRequest에서 조회해서 꺼내올 수 있다.@RequestParam @RequestMapping(&quot;/request-param-v2&quot;) public String requestParamV2( ..." }, { "title": "예외 처리와 오류페이지", "url": "/posts/spring-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC%EC%99%80-%EC%98%A4%EB%A5%98%ED%8E%98%EC%9D%B4%EC%A7%80/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:13:26 +0900", "snippet": "서블릿 예외처리서블릿의 예외처리 방식Exception WAS &amp;lt;- 서블릿 컨테이너 &amp;lt;- 필터 &amp;lt;- 서블릿 &amp;lt;- 인터셉터 &amp;lt;- 컨트롤러(예외발생) 웹 애플리케이션에서 발생한 예외를 잡지 못하면, 예외는 서블릿 컨테이너에까지 전달된다. 서블릿 컨테이너는 넘어온 예외를 기준으로 등록된 오류페이지를 조회한다. 등록된 것이 없다면 기본으로 등록되어있는 500 Internal Server Error 페이지를 클라이언트로 반환한다.response.sendError() W..." }, { "title": "스프링 MVC 구조", "url": "/posts/spring-%EC%8A%A4%ED%94%84%EB%A7%81-MVC-%EA%B5%AC%EC%A1%B0/", "categories": "study, spring", "tags": "architecture", "date": "2022-11-05 18:12:26 +0900", "snippet": "과정 클라이언트가 서버로 요청하면 먼저 Dispatcher Servlet 받음 Dispatcher Servlet은 http 요청의 URL과 메소드를 보고 이것을 처리할 수 있는 핸들러(컨트롤러)를 찾기 위해 핸들러 매핑 과정을 진행한다. 핸들러를 찾으면 이 핸들러를 처리할 수 있는 핸들러 어댑터를 조회한다. 핸들러 어댑터를 실행시킨다. 핸들러 어댑터는 요청을 적절히 처리한 다음 핸들러를 호출한다. 핸들러는 작업을 완료한 후 핸들러 어댑터에게 작업 결과를 반환한다. 핸들러 어댑터는 이 결과를 가공하여 ModelAndV..." }, { "title": "서블릿 필터", "url": "/posts/spring-%EC%84%9C%EB%B8%94%EB%A6%BF-%ED%95%84%ED%84%B0/", "categories": "study, spring", "tags": "spring", "date": "2022-11-05 18:11:26 +0900", "snippet": "서블릿 필터스프링에서 공통 관심사를 처리하기 위한 방법으로, 스프링 인터셉터와 함께 쓰이는 방법이다. 스프링 AOP를 사용하여 공통관심사를 처리할 수 있지만 웹과 관련된 공통 관심사는 서블릿 필터나 스프링 인터셉터를 사용하는 것이 좋다. 서플릿 필터나 스프링 인터셉터는 HttpServletRequest를 제공해주기 때문이다.소개필터 흐름 HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 -&amp;gt; 디스패처 서블릿 -&amp;gt; 컨트롤러필터는 디스패처 서블릿이 호출되기 전에 호출된다. 필터를 통해 다음과..." }, { "title": "쿠키 인증 vs 세션 vs JWT", "url": "/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/", "categories": "study, web", "tags": "web", "date": "2022-09-30 18:19:26 +0900", "snippet": "쿠키사용자가 로그인하면, 사용자 식별자를 암호화 또는 평문으로 쿠키에 담는 방식. 요청이 오면 쿠키에 담긴 식별자를 보고 유저를 구분한다. 장점 유효한 쿠키인지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 암호화를 하면 brute force 대응 가능(특정 횟수 이상 인증 실패시 ip 잠금) 간단히 구현 가능 단점 쿠키가 탈취되면 위장 가능 세션인증이 완료되면 사용자 식별자를 서버(DB 등)에..." }, { "title": "프론트 아키텍쳐 흐름", "url": "/posts/%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EB%B3%80%ED%99%94/", "categories": "study, design pattern", "tags": "architecture", "date": "2022-09-17 22:00:00 +0900", "snippet": "프론트 아키텍처 흐름MVC Model - View -Controller로 나눈 아키텍처 Model 컨트롤러가 호출했을때, 요청에 맞는 역할을 수행한다. 비즈니스 로직을 구현하는 영역으로 응용프로그램에서 데이터를 처리하는 부분 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야한다. Controller 클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델컴포넌트를 호출한다. 또한 클라이언트가 보낸 데이터가 있다면, 모델에 전달하기 쉽게 데이터를 가공한다...." }, { "title": "스프링 게층구조", "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81-%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0/", "categories": "study, spring", "tags": "spring", "date": "2022-09-13 11:00:00 +0900", "snippet": "스프링 계층구조Web 계층 컨트롤러(@Controller)와 JSP/Freemarker 등의 뷰 템플릿 영역 이외에도 필터(@Filter), 인터셉터, 컨트롤러 어드바이스(@Controller Advice) 등 외부 요청과 응답에 대한 전반적인 영역을 나타낸다. 외부 요청과 응답에 대한 전반적인 영역. 어플리케이션의 진입점이기 때문에 다른 레이어에서 발생한 예외도 처리함. 인증을 관리하고 권한없는 사용자의 인가를 거부하는 역할도 함. 데이터 처리 : DTO만 처리해야함.Service 계층 @Service가 사용되는 서..." }, { "title": "WAS vs 웹서버", "url": "/posts/was-webserver/", "categories": "study, web", "tags": "web", "date": "2022-09-12 20:00:00 +0900", "snippet": "WAS(Web Application Server) DB 조회나 다양한 로직처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다. 웹 컨테이너 혹은 서블릿 컨테이너 라고도 불린다. 컨테이너란, jsp, servlet을 실행시킬 수 있는 소프트웨어를 말함 즉, WAS란 JSP, servlet 구동환경을 제공한다. 쉬운 설명 : 포트에 연결되어 요청을 프로그램으로 쏴주..." }, { "title": "Open Graph(OG) 프로토콜", "url": "/posts/opengraph/", "categories": "study, web", "tags": "web", "date": "2022-09-11 16:00:00 +0900", "snippet": "Open Graph 프로토콜HTML문서의 head에는 &amp;lt;meta&amp;gt; 태그로 사이트의 정보가 표기되어있는 경우가 많다. 이는 크롤러가 무엇이 제목이고, 무엇이 내용인지 파악하기 쉽도록 하기 위해서 표기한 것이다.페이스북의 Open Graph 프로토콜은 이러한 메타태그의 표기 방법은 통일한 것이다. 이 Open Graph 프로토콜이 우리가 보는 미리보기 화면의 실체를 구성하는 메타 데이터 표기 방법이다.작동원리 사용자가 링크를 입력창에 입력한다. 페이스북, 네이버 블로그, 카카오톡은 입력창의 문자열이 “..." }, { "title": "Mysql Count 속도", "url": "/posts/Mysql-Count%EC%9D%98-%EC%86%8D%EB%8F%84/", "categories": "study, database", "tags": "db", "date": "2022-09-08 18:19:26 +0900", "snippet": "Mysql의 Select Count(*) 얼마나 빠를까?사용하는 데이터베이스 엔진에 따라 다르다. InnoDB : O(n) MyISAM : O(1)이유는 MyISAM의 경우 row가 몇 개 있는지 저장하고 있기에 Count(*) 쿼리가 들어오면 그 저장한 값을 바로 리턴하여 O(1)이 된다.Count(*) vs Count(column) vs Count(*) WhereCount(*)이 가장 빠르다.이유는 Count(*) 의 경우 내부적으로 값을 확인하지 않고, row의 개수만 확인한다.하지만 column을 주면 내부적으로 값..." }, { "title": "리액트 리팩토링", "url": "/posts/%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81/", "categories": "study, react", "tags": "", "date": "2022-09-04 21:00:00 +0900", "snippet": "리액트 리팩토링useEffect 사용useEffect 올바른 사용 props, state 변경에 따라 다른 데이터, state를 업데이트해야할 때 useEffect의 사용을 자제하자. useEffect vs EventHandler 중 어느 쪽에서 유저 인터랙션을 처리해야할까? useEffect 내에서 data fetching을 할 때 주의해야할 점.race condition 문제주로 API 요청을 보낼 때 발생함. 요청을 여러 번 보낼 때, 앞 요청이 끝나기 전에 뒤 요청이 먼저 끝날 수도 있다. 이러한 상황을 항상 고려..." }, { "title": "자바 기본", "url": "/posts/java-%EA%B8%B0%EB%B3%B8/", "categories": "study, java", "tags": "", "date": "2022-09-04 14:00:00 +0900", "snippet": "Eclipse 프로젝트 생성new Java project를 하면 여러 선택지가 나옴. Project layout use project folder as root for sources and class files 빌드 전 소스코드와 빌드 후 생성된 결과물이 root에 한번에 생김 Create separate folders for sources and class files 빌드 전 소스코드와 빌드 후 생성된 결과..." }, { "title": "useEffect 올바른 사용", "url": "/posts/useEffect-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%82%AC%EC%9A%A9/", "categories": "study, react", "tags": "react", "date": "2022-08-24 14:00:00 +0900", "snippet": "useEffect 올바른 사용props, state 변경에 따라 다른 데이터, state를 업데이트해야할 때useEffect를 사용하면 안된다.props, state가 변경이 되면 리렌더링이 발생하는데, 리렌더링이 끝난 후 useEffect가 호출되어 다시 리렌더링이 발생하기 때문이다.따라서 다음과 같이 코드를 변경해야한다.데이터를 업데이트해야하는 경우// useEffect로 업데이트function TodoList({ todos, filter }) { const [newTodo, setNewTodo] = useState(&#..." }, { "title": "바벨", "url": "/posts/babel/", "categories": "study, javascript", "tags": "javascript", "date": "2022-08-23 14:00:00 +0900", "snippet": "바벨바벨이란?자바스크립트 트랜스파일러.보통 모던 자바스크립트를 호환성을 위해 예전 문법으로 변환할때 사용한다.Typescript와 JSX 코드를 변환할 때도 사용한다.바벨 설정 파일 예시{ &quot;presets&quot;: [ [ &quot;@babel/env&quot;, { &quot;targets&quot;: { &quot;chrome&quot;: &quot;79&quot;, // 예시) 크롬 79까지 지원하는 코드를 만든다. &quot;edge&q..." }, { "title": "선언형프로그래밍", "url": "/posts/%EC%84%A0%EC%96%B8%ED%98%95/", "categories": "study, design pattern", "tags": "declare", "date": "2022-08-19 21:00:00 +0900", "snippet": "선언형, 명령형 그리고 추상화선언형이란? 명령형은 어떻게(How)에, 선언형은 무엇(What)에 집중한다.선언형은 명령형 코드에서 ‘어떻게’를 감추고 ‘무엇을’만 노출하는 방식의 추상화이다. 일종의 리팩토링이다.예시를 들면 다음과 같다.// 명령형 코드 : 배열에 있는 모든 숫자를 하나씩 제곱해서 result 배열에 넣는다.function double(arr) { let results = []; for (let i = 0; i &amp;lt; arr.length; i++) { results.push(arr[i] * ..." }, { "title": "React-query 에서 cache를 사용하는 방법", "url": "/posts/react-query-cache/", "categories": "study, react", "tags": "", "date": "2022-08-19 21:00:00 +0900", "snippet": "useQuery 설정React-Query 공식문서상 캐싱개념은 stale과 cachetime을 통해 이루어진다useQuery의 옵션으로 staletime과 cachetime을 보낼 수 있다. staletime : fetch를 통해 전달받은 데이터는 리액트 쿼리의 자료구조 내용중 캐시에 저장되는데, 이 캐시데이터의 ‘신선한 상태’가 언제까지 될지를 말해주는 옵션 default = 0, 받아오는 즉시 stale하다고 판단하여 캐싱데이터와 무관하게 계속해서 fetching을 날림 cachetime : ..." }, { "title": "DB 페이징 기법", "url": "/posts/%ED%8E%98%EC%9D%B4%EC%A7%95/", "categories": "study, database", "tags": "db", "date": "2022-08-16 21:00:00 +0900", "snippet": "페이징DB 에서 페이징을 구현하는 방법오프셋 페이징limit과 offset을 활용하여 페이징을 구현하는 방법.SELECT * FROM tableORDER BY timestampOFFSET 10LIMIT 5장점 구현이 간단하다.단점 Offset을 정말로 건너 뛰는 게 아니라, 한번은 읽는다. 따라서 만약 Offset이 100만이라면, 100만개의 데이터를 읽고 그다음 Limit으로 할당된 데이터를 읽는다. 사용자가 다음 페이지로 넘어가기 전에 새로운 데이터가 입력된다면, 다음 페이지에서 중복데이터가 보일 수 있다. 사용자..." }, { "title": "자바스크립트 실행 컨텍스트", "url": "/posts/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/", "categories": "study, javascript", "tags": "javascript", "date": "2022-08-14 17:30:00 +0900", "snippet": "실행컨텍스트 코드의 실제 진행상황을 추적하는데 필요한 정보들을 모아둔 구조 함수가 ()로 호출되면 실행컨텍스트가 생성됨. 실행 컨텍스트에는 파라미터를 포함한 지역 메모리와 실행문이 있음. 함수가 종료되면 실행 컨텍스트는 사라진다.자바스크립트의 함수 객체 서브루틴으로 실행할 수 있는 객체 동작을 나타내는 실행코드가 있으면서, 일반 객체와 동일하게 동작할 수 있다. 서브루틴 실행 : sum() 일반 객체 : sum.a = 1; 콜스택 현재 실행되고 ..." }, { "title": "코테대비 SQL 문법", "url": "/posts/%EC%BD%94%ED%85%8C-%EB%8C%80%EB%B9%84-sql-%EB%AC%B8%EB%B2%95/", "categories": "study, db", "tags": "", "date": "2022-08-01 14:00:00 +0900", "snippet": "정렬SELECT * FROM ANIMAL_INS ORDER BY ANIMAL_ID ASCORDER BY ANIMAL_ID DESCORDER BY NAME ASC, DATETIME DESC조건SELECT ANIMAL_ID, NAME FROM ANIMAL_INSWHERE INTAKE_CONDITION=&quot;Sick&quot;WHERE INTAKE_CONDITION&amp;lt;&amp;gt;&quot;Aged&quot;WHERE (A.SEX_UPON_INTAKE&amp;lt;&amp;gt;&quot;Spayed Female&..." }, { "title": "CSS 최적화", "url": "/posts/css-%EC%B5%9C%EC%A0%81%ED%99%94/", "categories": "study, css", "tags": "css", "date": "2022-07-31 22:00:00 +0900", "snippet": "CSS 최적화가 필요한 이유CSS는 렌더링을 막는다.CSS의 존재만으로도, CSS가 파싱되기 전까지 브라우저는 렌더링이 지연된다. 만약 브라우저가 CSS가 없는 페이지를 그대로 노출하면, 스타일적용이 되지않은 페이지가 나타나기 때문이다. 이를 FOUC라고 불린다.CSS는 HTML 파싱도 막을 수 있다브라우저가 CSS가 파싱되기 전까지 콘텐츠를 보여주지 않더라고, HTML의 로딩된 부분만을 일단 보여줄 수 있다. 그러나 스크립트의 경우 async defer 가 없다면 파싱을 막게 된다. 스크립트는 잠재적으로 페이지를 조작할 여자..." }, { "title": "클래스형 컴포넌트 vs 함수형 컴포넌트", "url": "/posts/%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/", "categories": "study, react", "tags": "react", "date": "2022-07-31 21:00:00 +0900", "snippet": "클래스형 컴포넌트import React, { Component } from &#39;react&#39;;class Hello extends Component { static defaultProps = { name: &#39;이름없음&#39; }; render() { const { color, name, isSpecial } = this.props; return ( &amp;lt;div style=&amp;gt; {isSpecial &amp;amp;&amp;amp; &amp;l..." }, { "title": "React에서 Key를 사용하는 이유", "url": "/posts/react-key/", "categories": "study, react", "tags": "react", "date": "2022-07-28 22:00:00 +0900", "snippet": "리액트로 개발을 하다가 리스트를 만들면, 다음과 같이 key를 사용하라는 안내문이 뜬다.평소엔 무시하고 key를 그냥 넣었지만, 왜 그런지 갑자기 궁금해져 찾아보았다.Recursing On Children해당 내용은 리액트 공식문서에 Recursing On Children으로 나와있다.리액트 리렌더링 과정에서 리스트를 처리할때, 리액트는 기본적으로 실제 DOM의 리스트와 virtual DOM의 변경된 리스트를 비교한다.// 전&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;first&amp;lt;/li&a..." }, { "title": "JS 코테 대비 메소드 정리", "url": "/posts/js-%EC%BD%94%ED%85%8C-%EB%8C%80%EB%B9%84/", "categories": "알고리즘", "tags": "", "date": "2022-07-21 22:00:00 +0900", "snippet": "문법 for … of : 반복가능한 객체 (Array, String, Set) for … in : 객체. 키를 뽑아냄.Set Set.prototype.add(value) Set.prototype.clear() Set.prototype.delete(value) Set.prototype.forEach((value, key, set) =&amp;gt; {}) 값, 키, set을 받음 Set.ptototype.has(value)Map Map.prototype.set(key, value)..." }, { "title": "학습 내용 요약", "url": "/posts/summary/", "categories": "study, summary", "tags": "summary", "date": "2022-07-19 14:00:00 +0900", "snippet": "프론트엔드Virtual DOM리액트의 작동방식은 상태변화 시, 그 컴포넌트와 하위 컴포넌트를 모두 교체하기에 많은 DOM 변화가 일어난다.이때 리액트에서는 DOM을 추상화한 객체인 Virtual DOM을 변경하고, 변경이 완료되면 실제 DOM과의 차이점을 확인한다음 한번의 리렌더로 해결한다.Virtual DOM은 메모리에 존재하여 메모리를 차지한다는 단점이 있다.리액트도 DOM API를 사용하여 뷰를 변화시키기에, DOM API보다 더 빠르진 않다. Virtual DOM은 리액트를 빠르게 하기 위한 수단.링크React key리..." }, { "title": "virtual DOM와 리렌더링", "url": "/posts/virtual-Dom/", "categories": "study, react", "tags": "react", "date": "2022-07-17 14:00:00 +0900", "snippet": "Virtual DOM은 DOM을 추상화한 가상의 객체이다.DOM 이란?HTML 문서를 파싱하여 문서의 구성요소들을 객체로 구조화하여 나타낸 것.HTML Elements, 속성, CSS style, Events, Methods 를 구조화해서 나타낸 객체고, 이 객체를 이용해서 웹페이지 구성요소를 제어할 수 있다.Virtual DOM은 이러한 DOM을 추상화한 가상의 객체이다.Virtual DOM 이 해결하고자 하는 문제React 작동 방식은 상태가 변경된 컴포넌트는 그 컴포넌트부터 자식 컴포넌트까지 리렌더링한다. 하지만 이런 식..." }, { "title": "React 18로 업데이트 방법, 문제점 정리", "url": "/posts/react18%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/", "categories": "projects, forkie", "tags": "", "date": "2022-06-03 14:00:00 +0900", "snippet": "기존에 React 17을 사용하던 Forkie Player 프로젝트를 React 18로 업데이트 하는 기록업데이트 하는 이유 automatic batching 동영상이 끝났을때 다음 영상으로 넘어가거나, 현재 영상의 시작부분으로 돌아가기 위해선 동영상의 timeupdate, ready, pause, ended 등등의 상태에 대응할 필요가 있다. 이때 이벤트 핸들러 안에서 여러 상태업데이트를 할때, automatic batching이 없을때는 서로 다른 타이밍에 발생하는 업데이트를 대응하기가 까다로웠다..." }, { "title": "velog 메모", "url": "/posts/velog-%EB%A9%94%EB%AA%A8/", "categories": "study, react", "tags": "", "date": "2022-04-24 23:00:00 +0900", "snippet": "리액트 리렌더링https://velog.io/@eunbinn/when-does-react-render-your-component children으로 넘어온 컴포넌트는 사용되는 컴포넌트가 리렌더링되도, 리렌더링의 영향을 받지 않는다. 리렌더링은 현재 컴포넌트에서 변화된 것이 없어도, 자식으로 전파된다. but 현재 컴포넌트에 useMemo를 사용하면, 변화가 없을시 자식으로도 전파되지 않음 useMemo도 써야할 때를 알아야한다. (구조변경 등의 방법으로 리렌더링을 막을 수 있음)" }, { "title": "함수형 프로그래밍 (이해하기 쉽게)", "url": "/posts/%ED%95%A8%EC%88%98%ED%98%95%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/", "categories": "study, design pattern", "tags": "fp", "date": "2022-03-30 14:00:00 +0900", "snippet": "액션, 계산, 데이터순수함수 vs 부수효과를 대체한 개념들.데이터 : 이벤트에 대한 사실. 액션에 의해 변화됨액션 : 데이터를 변화시킬 수 있음. 실행시점이나 횟수에 의존하여 언제하느냐에 따라 결과가 달라지면 액션이다.계산 : 입력값을 통해 출력을 만들어내는 것. 같은 입력에 대해 항상 같은 출력값만 내놓아야한다. 외부 세계에 영향을 주면 안됨.함수형 프로그래밍 예시)// 함수형 프로그래밍 관점에서 분리해보자.function App() { // 데이터 const [count, setCount] = useState(0); ..." }, { "title": "view", "url": "/posts/view/", "categories": "study, database", "tags": "db", "date": "2022-03-02 23:25:00 +0900", "snippet": "View다른 테이블을 기반으로 만들어진 가상 테이블. 논리적으로만 존재하는 테이블.장점 질의문을 쉽게 작성할 수 있음 데이터 보안유지에 도움이 됨. 데이터 관리가 편해짐특징 ALTER 문으로 뷰를 재정의하는 것은 불가능 기본 테이블 삭제 시 같이 삭제된다. 독자적인 인덱스를 가질 수 없음.**뷰생성 **CREATE VIEW 뷰_이름[(속성_리스트)] AS SELECT 문 [WITH CHECK OPTION] AS SELECT 문 : 뷰를 정의. ORDER BY는 사용불가 WITH CHECK OPTION : 뷰에 삽입..." }, { "title": "IPv6", "url": "/posts/ipv6/", "categories": "study, network", "tags": "network", "date": "2022-03-02 14:00:00 +0900", "snippet": "IPv6 128비트 사용. Multicast 대신에 Broadcast를 함. ICMPv6 ARP, IGMP 기능흡수 ARP : IP주소를 MAC 주소로 변환하는 프로토콜 IPv4 에서 IPv6로의 전환 정책 Dual stack : 두가지 다 지원하도록 하여, 두가지 주소를 모두 사용할 수 있도록 하는 것 tunneling : 종단 사이에 IPv4를 쓰는 홉이 있을때, 그 중간 단..." }, { "title": "deadlock 발생 조건", "url": "/posts/deadlock/", "categories": "study, os", "tags": "os", "date": "2022-03-02 14:00:00 +0900", "snippet": "deadlock 발생 조건아래 4가지 조건을 모두 만족하면 데드락 발생가능성이 있음 상호배제(Mutual Exclusion) 한 리소스는 한번에 한 프로세스만이 사용할 수 있음 Hold and wait No preemption Circular waitdeadlock 방지법 Prevention 교착 상태가 발생할 수 있는 요구조건을 만족시키지 않게 함으로써 방지 Avoidance 교착상태 발생 가능성이 있는 자원할당을 하지 않음 ex) 은행..." }, { "title": "17088 등차수열 변환", "url": "/posts/17088-%EB%93%B1%EC%B0%A8%EC%88%98%EC%97%B4%EB%B0%98%ED%99%98/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2022-03-02 14:00:00 +0900", "snippet": "알고리즘 첫번째와 두번째 원소 사이의 공차를 구함 두번째 원소부터 마지막원소까지의 공차를 만족하는 경우만으로 dfs를 진행함 마지막원소까지 공차를 만족하는 모든 경우의 수를 구하고, 그 중 최소 연산으로 만족하는 경우의 수를 반환함. 위 과정을 첫번째 원소와 두번째 원소 사이의 공차의 경우의수만큼 진행하고, 그 중에서 최소 연산의 수를 구한다. 각 원소별로, (-1, 0, 1) 세 개의 연산을 할 수 있으므로 공차의 경우의 수는 9개. 삽질 다이나믹을 적용할 수 있을거..." }, { "title": "서브네팅", "url": "/posts/subnetting/", "categories": "study, network", "tags": "network", "date": "2022-02-27 21:34:00 +0900", "snippet": "서브네팅사용가능한 IP 주소 범위를 분할하여 사용하는 것특징 2의 배수로, 같은 크기로 분할주소할당서브넷 마스크는 다음과 같음 네트워크 주소사용부분 모두 1 + 호스트 주소 사용부분 모두 0각 서브넷에서는 다음과 같이 2개의 주소는 예약되어있음 네트워크 주소 : (기존 네트워크 부 + 분할부분 매핑 주소) + (남은 호스트부분 모두 0) 브로드캐스트 주소 : (기존 네트워크 부 + 분할 매핑 주소) + (남은 호스트 부분 모두 1)따라서 서브넷에서 사용가능한 주소 범위는, 네트워크 주소와 브로드캐스트 주소를 제외한 나머..." }, { "title": "관계 데이터 모델", "url": "/posts/data/", "categories": "study, database", "tags": "db", "date": "2022-02-25 22:30:00 +0900", "snippet": "관계 데이터 모델용어 릴레이션 : 하나의 개체에 관한 데이터를 2차원 테이블로 저장한 것. 릴레이션 스키마 : 릴레이션의 이름과 속성이름으로 정의. 정적. 내포 릴레이션 인스턴스 : 릴레이션에 존재하는 튜플들의 집합. 동적. 외연 도메인 : 하나의 속성이 가질 수 있는 모든 값의 집합. 적합성 판단의 기준이 됨 데이터베이스의 구성 데이터베이스 스키마 : 데이터베이스의 전체구조. 릴레이션 스키마의 모음 데이터베이스 인스턴스 : 데이터베이스를 구성하는 릴..." }, { "title": "반정규화", "url": "/posts/denormalized/", "categories": "study, database", "tags": "db", "date": "2022-02-25 22:00:00 +0900", "snippet": "반정규화시스템의 성능 향상, 개발 및 운영의 편의성을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위.과도한 반정규화는 성능 저하를 불러일으킴. 시스셈의 성능과 관리효율성은 증가하지만, 데이터의 일관성 및 정합성을 저하될 수 있음. 따라서 사전에 데이터의 일관성 및 정합성을 우선할지, 데이터베이스의 성능과 단순화를 우선으로 할지 결정해야함 방법 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가테이블 통합두개의 테이블이 조인되는 경우가..." }, { "title": "응집도와 결합도", "url": "/posts/%EC%9D%91%EC%A7%91%EB%8F%84/", "categories": "study, design pattern", "tags": "", "date": "2022-02-24 23:47:00 +0900", "snippet": "응집도모듈 내부의 기능적인 집중 정도. 높을 수록 좋다.우연적 응집도 &amp;lt; 논리적 응집도 &amp;lt; 시간적 응집도 &amp;lt; 절차적 응집도 &amp;lt; 교환적 응집도 &amp;lt; 순차적 응집도 &amp;lt; 기능적 응집도기능적 응집도(Functional Cohesion) : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우순차적 응집도(Sequential Cohesion) : 모듈 내에서 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우교환적 응집도(Communication Coh..." }, { "title": "스키마", "url": "/posts/scheme/", "categories": "study, database", "tags": "", "date": "2022-02-24 00:24:00 +0900", "snippet": "내부 스키마데이터베이스가 실제로 저장되는 방법을 정의한 것.개념 스키마데이터베이스 전체의 논리적 구조를 정의한 것. 데이터베이스 하나에 하나만 존재.개체, 관계, 제약조건, 보안정책 등을 정의한다.외부 스키마사용자에게 필요한 데이터베이스를 정의한 것" }, { "title": "블랙박스/화이트박스 테스트", "url": "/posts/blackbox-whitebox/", "categories": "study, software engineering", "tags": "", "date": "2022-02-23 00:18:00 +0900", "snippet": "블랙박스 테스트소프트웨어의 내부 구조나 작동 원리는 모르는 상태에서 동작을 검사하는 방식기법 동등 분할 기법 : 프로그램 입력 도메인을 테스트 케이스가 산출될 수 있는 데이터 클래스로 분류하는 방법 경계값 분석 기법 : 입력 조건의 중간 값보다 경계값에서 에러가 발생될 확률이 높으므로 오류 예측 기법 : 놓치기 쉬운 오류들을 감각 및 경험으로 찾아보는 방법 원인 결과 그래프 기법 : 입력 데이터 간 관계가 출력에 미치는 영향을 그래프로 표현하여 오류를 발견 의사결정 테이블 테스팅 : 논리적 조건이나 상황에서 입력 조건..." }, { "title": "전위식/후위식", "url": "/posts/prefix-postfix/", "categories": "study, algorithm", "tags": "", "date": "2022-02-23 00:04:00 +0900", "snippet": "전위식연산자를 먼저 표시하고 연산에 필요한 피연산자를 나중에 표시(A + B) * (C - D)((A + B) * (C - D))*(+(AB)-(CD))*+AB-CD후위식피연산자를 먼저 표시하고, 연산자를 나중에 표시(A+B) * (C-D)((A+B) * (C-D))((AB)+(CD)-)*AB+CD-*" }, { "title": "통합 테스트", "url": "/posts/integration-test/", "categories": "study, software engineering", "tags": "", "date": "2022-02-22 23:59:00 +0900", "snippet": "통합 테스트상향식 통합 테스트프로그램의 하위 모듈에서 상위모듈로 통합하면서 테스트하는 기법. 하위 모듈을 클러스터로 결합 더미 모듈인 드라이버 작성 통합된 클러스터 단위로 테스트 테스트 완료 후 클러스터는 프로그램 구조의 상위로 이동해 결합하고, 드라이버는 실제 모듈로 대체 됨.하향식 통합 테스트프로그램의 상위모듈에서 하위모듈로 통합하면서 테스트하는 기법 주요 제어 모듈은 작성된 프로그램을 사용. 주요 제어 모듈의 종속 모듈은 Stub으로 대체 DFS, BFS로 하위 모듈인 Stub을 한번에 하나씩 실제 모듈로 교체..." }, { "title": "럼바우 분석기법", "url": "/posts/rumbaugh/", "categories": "study, software engineering", "tags": "", "date": "2022-02-22 01:50:00 +0900", "snippet": "럼바우 분석기법모델링 기법중 하나로 그래픽으로 표현한 분석기법객체 모델링 기법이라고도 한다.3단계로 구성 객체 모델링 동적 모델링 기능 모델링1. 객체 모델링(object modeling)객체 다이어그램을 표시함. 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 클래스 다이어그램으로 표현한 것2. 동적 모델링상태 다이어그램을 통해 시간의 흐름에 따라 객체들을 모델링한다.객체들관계 관계에는 제어흐름, 상호작용, 동적순서 등의 관계가 있다.3. 기능..." }, { "title": "UML", "url": "/posts/UML/", "categories": "study, software engineering", "tags": "", "date": "2022-02-22 01:15:00 +0900", "snippet": "UML(Unified Modeling Language)통합 모델링 언어를 사용하여 시스템 상호작용, 업무 흐름, 시스템 구조, 컴포넌트 관계 등을 그린 도면.프로그래밍을 단순화 시켜 표현하여 의사소통 하기 좋고, 대규모 프로젝트에서는 로드맵을 만들거나 개발을 위한 시스템 구축의 기본을 마련한다.요구사항 모델링에 사용되는 기법 중 하나구성요소 사물 (things) 구조사물 : 시스템의 개념적, 물리적 요소를 표현. (ex : 클래스, usecase, 컴포넌트) 행동사물 : 시간과 공간에 따른 요소들의 ..." }, { "title": "객체지향 분석론", "url": "/posts/oop-analysis/", "categories": "study, software engineering", "tags": "", "date": "2022-02-22 01:00:00 +0900", "snippet": "Coad YourdonE-R 다이어그램을 사용하여 객체의 행위를 모델링.객체 식별, 구조 식별, 주제정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 주로 관계를 분석 하는 기법Booch미시적, 거시적 개발 프로세스를 모두 사용하는 분석 방법.클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의JacobsonUseCase를 사용하여 분석.Wirfs-Brock 방법분석과 설계간 구분이 없으며, 고객 명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법출처https://m.blog.naver...." }, { "title": "CASE", "url": "/posts/case/", "categories": "study, software engineering", "tags": "", "date": "2022-02-22 01:00:00 +0900", "snippet": "CASE(Computer Aided Software Engineering)소프트웨어 개발 시 사용되는 분석 자동화 도구. 소프트웨어 개발 과정의 일부나 전체를 자동화하는 도구이다.CAD 기기와 유사한 것이라고 생각하면 됨. 요구분석 -&amp;gt; 설계 -&amp;gt; 구현 -&amp;gt; 검사 및 디버깅 과정을 CASE를 활용하여 자동화함CASE의 장점 개발 속도가 빨라짐. 하나의 tool을 활용함으로써, 표준화된 개발 환경을 구축할 수 있음. 따라서 커뮤니케이션이 용이해짐. 오류 수정이 쉬워지고, 이로인해 소프..." }, { "title": "GoF", "url": "/posts/Gof/", "categories": "study, design pattern", "tags": "", "date": "2022-02-22 01:00:00 +0900", "snippet": "GoF(Gang of Four)GoF에서는 23가지 디자인패턴을 3가지 유형으로 분류함. 생성 패턴(Creation pattern) 객체를 생성하는데 관련된 패턴들 객체가 생성되는 과정의 유연성을 높이고, 코드의 유지를 쉽게함 구조 패턴(Structural Pattern) 프로그램 구조에 관련된 패턴들 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용할 수 있는 패턴들 행동 패턴(Behavioral Pattern) ..." }, { "title": "운영체제 소개", "url": "/posts/cs-os/", "categories": "study, os", "tags": "os", "date": "2022-02-21 02:00:00 +0900", "snippet": "운영체제 정의컴퓨터 시스템의 4가지 요소 유저 어플리케이션 OS 하드웨어운영체제 유저 관점 : 어플리케이션을 수행함. 컴퓨터 사용을 편리하게 해줌 시스템 관점 : 자원할당자. 어플리케이션과 i/o 장치의 수행을 다루는 프로그램 컨트롤러커널OS에 속하며, 컴퓨터에서 항상 수행되는 프로그램.하드웨어의 자원을 자원이 필요한 프로세스에게 나눠주고, 프로세스 제어, 메모리 제어, 시스템 콜 등을 수행하는 부분이다.컴퓨터 시스템 수행컴퓨터 시스템 조직cpu, disk(buffer), memory, usb(buffer), gra..." }, { "title": "Arrow function", "url": "/posts/arrowfunction/", "categories": "study, javascript", "tags": "javascript", "date": "2022-02-18 12:50:00 +0900", "snippet": "화살표함수기존의 function 표현방식보다 간결하게 함수를 표현할 수 있다. 화살표함수는 항상 익명이며, 자신의 this, arguments, super, new.target을 바인딩하지 않는다. 따라서 생성자로는 사용할 수 없다. 화살표함수 도입 영향 : 짧은 함수, 상위 스코프 this짧은 함수var materials = [&quot;Hydrogen&quot;, &quot;Helium&quot;, &quot;Lithium&quot;, &quot;Beryllium&quot;];materials.map(function (m..." }, { "title": "Promise, async/await", "url": "/posts/promise-async-await/", "categories": "study, javascript", "tags": "javascript", "date": "2022-02-18 12:30:00 +0900", "snippet": "Promise비동기로 처리하기 위한 방법 중 하나.다음과 같이 사용//Promise 선언var _promise = function (param) { return new Promise(function (resolve, reject) { window.setTimeout(function () { if (param) { resolve(&quot;해결 완료&quot;); } else { reject(Error(&quot;실패!!&quot;)); } }, 3000); })..." }, { "title": "this에 대해서", "url": "/posts/this/", "categories": "study, javascript", "tags": "javascript", "date": "2022-02-18 12:10:00 +0900", "snippet": "this에 대해서자바스크립트에서 모든 함수는 실행될때마다 함수 내부에 this라는 객체가 추가된다. arguments라는 유사배열 객체와 함께 함수 내부로 암묵적으로 전달되는 것이다. 그렇기 때문에 자바스크립트에서의 this는 함수가 호출된 상황에 따라 그 모습을 달리한다.상황 1. 객체의 메서드를 호출할때객체의 프로퍼티가 함수일 경우 메서드라고 부른다. this는 함수를 실행할 때 함수를 소유하고 있는 객체를 참조한다. 즉, 해당 메서드를 호출한 객체로 바인딩 된다. A.B일때, B함수 내부에서의 this는 A를 가리키는 것..." }, { "title": "closure", "url": "/posts/closure/", "categories": "study, javascript", "tags": "javascript", "date": "2022-02-09 02:00:00 +0900", "snippet": "Closure두개의 함수로 만들어진 환경으로 이루어진 특별한 객체의 한 종류이다. 여기서 환경이란, 클로저가 생성될 때 그 범위에 있던 여러 지역변수들이 포함된 context를 말한다. 이 클로저를 통해서 자바스크립트에는 없는 private 속성/메소드, public 속성/메소드를 구현할 수 있다.클로저 생성하기다음은 클로저가 생성되는 조건이다. 내부 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용된다. 내부 함수는 외부 함수의 실행 환경(execution environment)에서 실행된다. 내부 함수에서 사용되는..." }, { "title": "hoisting", "url": "/posts/hoisting/", "categories": "study, javascript", "tags": "javascript", "date": "2022-02-09 01:20:00 +0900", "snippet": "호이스팅은 변수를 끌어올리는 것. var로 선언된 모든 변수 선언을 hoist한다. hoist란 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것을 의미한다. 즉, 함수 내의 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것자바스크립트에서 변수의 선언은 끌어올려진다. 다음의 코드를 보자.function getX() { console.log(x); // undefined; var x = 100; console.log(x); // 100}getX();다른 언어의 경우 첫번째 console.log..." }, { "title": "javascript 이벤트루프", "url": "/posts/eventloop/", "categories": "study, javascript", "tags": "javascript", "date": "2022-02-08 11:20:00 +0900", "snippet": "이벤트 루프javascript를 공부하다보면 아래와 같은 말을 종종 듣는다. 싱글스레드 기반으로 동작하는 자바스크립트 이벤트 루프를 기반으로 하는 싱글스레드 Node.js정말 싱글 스레드인가? 어떻게 싱글 스레드인가? 이벤트 루프는 무엇인가? 를 간단히 알아보기 위해 자바스크립트가 동작하는 환경과 엔진에 대해 알아보자.Javascript Enginejavascript로 작성한 코드를 해석하고 실행하는 인터프리터. 주로 웹브라우저에서 사용되지만, node.js에서는 V8 엔진이 사용된다.구글에서 개발한 V8 엔진을 비롯해, ..." }, { "title": "알고리즘 개요", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EC%9A%94/", "categories": "study, algorithm", "tags": "", "date": "2022-02-07 11:00:00 +0900", "snippet": "DP복잡한 문제를 간단한 여러 하위문제로 나누어 푸는 방법두가지 구현방식이 존재함 top-down 여러개의 하위문제로 나누고, 하위문제를 푼 다음, 그것들을 결합하여 최종적으로 최적해를 구한다. 이때 하위문제로 나눌때 같은 하위문제를 가지고 있는 경우가 있다. 이때의 최적해를 저장해서 사용하여 같은 하위문제를 다시 풀지 않도록 하는 방법을 메모이제이션이라고 한다. bottom-up 하위문제들의 해로 상위문제의 최적해를 구한다. 피보나치 예시top-downf (in..." }, { "title": "singleton", "url": "/posts/architecture/", "categories": "cs, design pattern", "tags": "singleton", "date": "2022-02-07 01:00:00 +0900", "snippet": "Singleton 패턴애플리케이션에서 인스턴스를 하나만 만들어 사용하기 위한 패턴이다.커넥션 풀, 스레드 풀, 디바이스 설정 객체 등의 경우, 인스턴스를 여러 개 만들게하면 자원을 낭비하게 되거나 버그를 발생시킬 수 있으므로 오직 하나만 생성하고 그 인스턴스를 사용하도록 하는 것이 목적이다.구현하나의 인스턴스만을 유지하기 위해 인스턴스 생성에 특별한 제약을 걸어둬야한다. new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정 유일한 단일 객체를 반환할 수 있도록 정적 메소드를 지원. 유일한 단일 객체를 참조..." }, { "title": "데이터베이스 개요", "url": "/posts/database-%EA%B0%9C%EC%9A%94/", "categories": "study, database", "tags": "db", "date": "2022-02-04 11:40:00 +0900", "snippet": "데이터베이스파일시스템의 문제점 앱과 상호 연동되어있기 때문에 다음과 같은 문제가 발생함. 데이터 종속성 데이터 중복성 데이터 무결성 데이터베이스 특징 데이터 독립성 물리적 독립성 : 데이터베이스를 수정하더라도, 응용 프로그램을 수정할 필요는 없음 논리적 독립성 : 하나의 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있음. 데이터의 무결성 여러 경로를 통해 잘못된 데이터가 발생하는 것을 방지하기 위해, 데이..." }, { "title": "React) JS 다운로드 시간 동안의 로딩 화면", "url": "/posts/react-%EB%A1%9C%EB%94%A9-%EC%B2%98%EB%A6%AC/", "categories": "study, react", "tags": "", "date": "2022-02-03 03:00:00 +0900", "snippet": "최근 프로젝트에서 리액트 앱을 배포하였는데, 인터넷 속도가 느린 환경에서 자바스크립트를 다운로드 받는 시간이 오래 걸린다는 걸 눈치챘다.눈치챘다는 표현이 어울리는데 왜냐하면 사실 당연한 건데 이제까지 신경쓰지 않았던 부분이기 때문이다. 리액트앱은 매우 큰 자바스크립트 파일 하나로 이루어져있고, 이를 다운로드 받는 것은 당연히 오래 걸리는 일이기 때문이다.따라서 이 시간 동안 단순한 로딩 화면이라도 띄울수있다면 사용자 경험을 향상 시킬 수 있을 것이라 생각되어 관련된 공부를 하게 되었다.리액트 앱이 띄워지기까지사용자가 우리의 앱..." }, { "title": "2631 줄세우기", "url": "/posts/2631%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2022-01-30 14:00:00 +0900", "snippet": "알고리즘 LIS를 구하고, LIS를 구성하지 않는 요소들만 배치해주면 됨 LIS를 구하는 방법으론 n이 최대 200이니 O(n^2)을 써도 충분함 LIS 구하는 코드 O(n^2) 이전 요소들 중에 자기보다 작은 것 중, 가장 큰 LIS를 가진 요소에 이어 붙임 for (int i = 1; i &amp;lt;= n; i++) { save[i] = 1; for (int j = 1; j &amp;lt; n; j++..." }, { "title": "운영체제 개요", "url": "/posts/os/", "categories": "study, os", "tags": "os", "date": "2022-01-25 02:00:00 +0900", "snippet": "프로세스와 스레드의 차이프로세스실행중인 프로그램으로, 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말함.OS로부터 주소공간, 파일, 메모리등을 할당받으며, 이것들을 총칭하여 프로세스라고한다.할당받는 메모리 공간 프로세스 스택 : 함수의 매개변수, 복귀주소, 로컬 변수 같은 임시자료를 저장 데이터 섹션 : 전역변수들을 수록 힙 : 프로세스 실행 중에 동적으로 항당되는 메모리프로세스 제어 블록(Process Control Block, PCB)PCB는 특정 프로세스에 대한 중요한 정보를 저장하고 있는 OS의 자료구조이..." }, { "title": "1522 문자열 교환", "url": "/posts/1522/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2022-01-24 21:00:00 +0900", "snippet": "알고리즘 문자열에서 a의 개수를 ac 라고 할때, 시작점을 문자열의 맨처음부터 맨 끝까지 이동하면서, 길이가 ac인 문자열을 안에 b가 몇개있는지 검사한다. 이때 검사한 b의 개수 중 최소가 필요한 최소의 교환횟수 쉽게 말해서, 길이가 ac인 문자열 안에 b를 최소로 포함한 문자열을 a로 채우는 문제로 치환한 것이다.코드#include &amp;lt;iostream&amp;gt;using namespace std;string str;int ans = 2000000000;int min(int a,int b) { return..." }, { "title": "network 개요", "url": "/posts/network/", "categories": "study, network", "tags": "network", "date": "2022-01-24 12:00:00 +0900", "snippet": "HTTP의 GET과 POST 비교GET 데이터가 HTTP Request Message의 헤더부분의 url에 담겨서 전송됨. url의 끝에 ? 뒤에 데이터를 붙여 요청. 데이터의 크기가 제한적임. 데이터가 url에 노출되므로 보안에 약함POST 데이터가 HTTP Requst Message의 바디부분에 담김 데이터 크기가 커도 됨. GET 방식보다 보안적임.어디에 무엇을 적용할까? 서버에서 데이터를 가져와서 보여줄때 GET 방식이 적합함 서버의 값이나 상태 등을 변경할때 PO..." }, { "title": "DataStructure 개요", "url": "/posts/datastructure/", "categories": "study, datastructure", "tags": "자료구조", "date": "2022-01-23 14:00:00 +0900", "snippet": "Array vs Linked ListArray 논리적 저장 순서와 물리적 저장순서가 일치함. 장점 Random Access : 인덱스로 원하는 원소에 바로 접근이 가능하여, O(1)에 해당원소로 접근가능 언어에따라 다르지만, 필요한 만큼만 메모리를 차지함 단점 중간에 한 원소를 삭제하거나, 새로운 원소를 넣을때, 다른 원소를 shift 해줘야하여 O(n)의 시간이 걸림. Linked Li..." }, { "title": "(Typescript) React typescript hack", "url": "/posts/typescript-react-hack/", "categories": "study, react", "tags": "", "date": "2022-01-22 01:00:00 +0900", "snippet": "React 에서 Typescript 사용시 참고할만한 Typing 기법을 기록한 곳React.HTMLArributes&amp;lt;[HTMLElement]&amp;gt;한 Element에 부여될 속성 값들을 모두 참조할때 사용하면 좋다. 다음과 같이 기본 HTML 엘리먼트를 스타일링해서 사용할때 유용함export interface ITextButtonProps extends IProps, React.HTMLAttributes&amp;lt;HTMLDivElement&amp;gt; { text?: string | JSX.Elem..." }, { "title": "(CSS)다른 엘리먼트의 이벤트 발생 시, 스타일 적용법", "url": "/posts/(CSS)%EB%8B%A4%EB%A5%B8-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EC%9D%98-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B0%9C%EC%83%9D-%EC%8B%9C,-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%A0%81%EC%9A%A9%EB%B2%95/", "categories": "study, css", "tags": "", "date": "2022-01-22 01:00:00 +0900", "snippet": "yourlist_web_renewal 중, 한 input 엘리먼트의 placeholder가 보일시와 안보일 시, label 엘리먼트에 각기 다른 스타일을 적용해야하는 일이 있었다.현재 사용중인 tailwind에선 어떻게 사용해야할지 모르겠으나 순수 CSS 방식으로 하면 다음과 같다..form_field:placeholder-shown ~ .form__label { font-size: 1rem; top: 0; cursor: text;}.form_field:focus ~ .form__label { top: -1.2rem; ..." }, { "title": "flex, grid로 남은 곳 꽉채우기", "url": "/posts/flex,grid%EB%A1%9C-%EB%82%A8%EB%8A%94%EA%B3%B5%EA%B0%84-%EC%B1%84%EC%9A%B0%EA%B8%B0/", "categories": "study, css", "tags": "", "date": "2022-01-21 14:00:00 +0900", "snippet": "최근 프로젝트를 하면서, 다른 요소들의 크기는 정해져있을때 남은 한 요소의 크기를 부모 요소에서 남는 공간만큼 부여하는 부분이 많았다(그리고 앞으로도 많을 것 같다)위 부분을 구현할때, flex와 grid를 통해 해결했어서 그것을 기록 하는 차원에서 이 글을 적어본다.flex만약 다음과 같이 div 엘리먼트들이 배치되어있고, 우리는 가운데 expand를 container의 남는 공간만큼 확장 시키고 싶다고 하자..container { display: flex; background-color: burlywood;}.leftI..." }, { "title": "13144 List of Unique Numbers", "url": "/posts/13144/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2022-01-18 20:00:00 +0900", "snippet": "알고리즘(내방식) 숫자를 왼쪽에서 오른쪽으로 살펴가면서, 그 수가 나온 인덱스를 기록(saveIdx)한다. i를 기록할때 이미 기록된 인덱스가 있을 경우, 그 인덱스부터 이전에 체크가 안된 인덱스들은 i 까지만 연속해서 숫자를 뽑을 수 있다. 따라서 이에 해당하는 경우의 수를 정답에 추가시켜준다.알고리즘(투포인터) 내가 한 방식에서 관점만 바꾸면 투포인터 방법이 된다. 왼쪽에서 오른쪽으로 end를 하나씩 늘려가며 숫자를 살펴가면서, 현재 수를 체크한다. 만약 i에서..." }, { "title": "MVVM, MVP 패턴", "url": "/posts/MVVM-MVP/", "categories": "study, design pattern", "tags": "architecture", "date": "2022-01-18 14:00:00 +0900", "snippet": "MVVMModel - View - View Model 의 약자로, 프로그램의 비지니스 로직과 프레젠테이션 로직을 UI로 명확하게 분리하는 패턴구성요소 Model : 데이터를 보관하고 있는 부분으로, 데이터를 불러오거나 업데이트하는 로직이 있음. View Model : Model에 데이터를 요청하고 가공함. 비지니스 로직을 처리. View로부터 입력을 받아 적절한 처리를 함 View : UI 담당. UI에 연관된 로직만 수행한다. 필요한 데이터는 View Model과 data binding을 통해 얻는다. 사용자의 입력을 ..." }, { "title": "Git", "url": "/posts/git/", "categories": "study, software engineering", "tags": "", "date": "2022-01-18 00:12:00 +0900", "snippet": "GitGIT의 개발 목표 빠른 속도 단순한 구조 비선형적인 개발(수천 개의 동시다발적인 브랜치) 완벽한 분산(DVCS) 대형 프로젝트에도 유용할 것Inside of GitGit은 기본적으로 파일시스템의 스냅샷을 저장한다.(커밋 당시의 GIT 디렉터리의 모든 파일 정보를 저장) 또한 파일 및 스냅샷을 해시하여 바뀐 버전인지 아닌지 빠르게 체크함이후 스냅샷들의 크기가 커지면, 주기적으로 git gc(garbage collection)을 통해 delta를 만듦gitignore.gitignore 에서는 아래와 같은 glob ..." }, { "title": "MVC 패턴", "url": "/posts/MVC-%ED%8C%A8%ED%84%B4/", "categories": "study, design pattern", "tags": "architecture", "date": "2022-01-17 00:33:00 +0900", "snippet": "MVC 컴포넌트의 역할Model 컨트롤러가 호출했을때, 요청에 맞는 역할을 수행한다. 비즈니스 로직을 구현하는 영역으로 응용프로그램에서 데이터를 처리하는 부분이다. DB에 연결하고 데이터를 추출하거나 CRUD 등의 작업을 수행한다. 상태의 변화가 있을때, 컨트롤러와 뷰에 통보해 후속 조치 명령을 받을 수 있게 된다. 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야한다.Controller 클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델컴포넌트를 호출한다. 또한 클라이언트가 보낸 데이터가 있다면..." }, { "title": "TDD", "url": "/posts/TDD/", "categories": "study, design pattern", "tags": "tdd", "date": "2022-01-17 00:30:00 +0900", "snippet": "TDD 란?Test-Driven Development의 약자로, 테스트가 코드 작성을 주도하는 개발방식이며, 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다.우선 개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고, 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 일단 테스트를 통과하는 코드를 작성하고, 리팩토링하는 과정을 거치는 것이다.장점코드를 작성하기 전에 보다 요구사항에 집중테스트를 작성하기 전에 개발자는 해당 기능의 요구사항과 명세를 분명히 이해하고 있어야한다. 이는 use..." }, { "title": "RESTful API", "url": "/posts/RESTful-API/", "categories": "study, web", "tags": "rest", "date": "2022-01-16 23:00:00 +0900", "snippet": "REST란, REprensentational State Transfer의 약자이다. 따라서, RESTful API는 REST의 기본 원칙을 잘 지킨 API를 의미한다.REST는 하나의 아키텍쳐로, Resource Oriented Architecture이다. API 설계의 중심에 자원(resource)가 있고, HTTP Method를 통해 자원을 처리하도록 설계하는 것이다. www와 같은 분산 하이퍼 미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴RE..." }, { "title": "9935 문자열 폭발", "url": "/posts/9935-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%8F%AD%EB%B0%9C/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2022-01-15 02:00:00 +0900", "snippet": "매우 어렵게 구현하여 풀긴하였으나, 스택을 사용하면 매우 직관적으로 편하게 구현할 수 있었다.스택을 사용하여 문제를 푼 경험이 적어서 스택을 떠오르지 못한 것 같다스택을 사용한 문자열 문제를 몇문제 풀어봐야할 것 같음내 풀이 : 빡센 구현알고리즘 앞에서부터 검사하다가 폭발문자열과 일치하는 문자열이 발견되면, 그 문자열을 폭파시키고, 없어진 다음 문자열을 참조하도록 함. 예를들어, 문자열 인덱스 3~6이 폭파되었다면, to[3] = 7 을 저장하여, 검사하는 위치를 앞으로 당겨서 다시 검사할때, 폭파된 문자열을 점프하도록 한..." }, { "title": "함수형 프로그래밍", "url": "/posts/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/", "categories": "study, design pattern", "tags": "fp", "date": "2022-01-14 14:00:00 +0900", "snippet": "부수 효과가 없는 순수함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용하는 것을 가능하도록 하여, 참조 투명성을 지키도록 하는 프로그래밍 패러다임순수 함수형 프로그래밍만으로 개발을 하기에는 무리가 있다. 따라서 적절히 조절해가면서 개발을 해나가자.요약함수형 프로그래밍의 가장 큰 특징 두 가지 immutable data first class citizen으로서의 functionimmutable data각 함수는 외부의 값을 변경하지 않고, side effect를 일으키지 않도록 하는 순수함수여야함.first-c..." }, { "title": "알고리즘 팁(WIP)", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%81-%EC%A0%95%EB%A6%AC/", "categories": "알고리즘", "tags": "", "date": "2022-01-14 14:00:00 +0900", "snippet": "구조 관련정렬된 배열의 앞 뒤로 새로운 요소를 삽입 해야되는 경우 필요한 길이의 2배길이의 배열을 선언한 다음, (start, to)로 인덱스를 트래킹해가면서 넣는다. 이때 start, to의 초깃값은 2배 길이의 배열의 딱 중간이어야함(그래야 최솟값만 들어가거나, 최댓값만 들어갈때도 배열이 터지지 않음)소수판별 floor(sqrt(n)) 까지만 검사해도 됨.라이브러리 관련string &amp;lt; &amp;gt; == + 등의 연산자 사용가능 .substr(index, size) 첫번째에는 시작 ..." }, { "title": "Object Oriented Programming", "url": "/posts/oop/", "categories": "study, design pattern", "tags": "oop", "date": "2022-01-13 14:00:00 +0900", "snippet": "OOP는 너무 거대한 개념이라 다 다루지는 못하지만 간단히만 알아보자간단한 설명OOP : 중심적 프로그래밍 패러다임. 현실 세계의 사물들을 객체라고 보고, 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍하는 것(추상화)장점 OOP로 작성한 코드는 재사용성이 높다. 자주 사용되는 로직을 라이브러리로 만들어두면 개발로드가 줄어들고, 신뢰성도 확보가 됨 라이브러리를 각종 예외상황에 맞게 잘 구현하면, 개발자가 사소한 실수를 해도 에러를 컴파일 ..." }, { "title": "React v18 주요 변경점", "url": "/posts/reactv18/", "categories": "study, react", "tags": "react", "date": "2022-01-10 00:20:00 +0900", "snippet": "React v18의 정식 출시가 코앞에 있고, 가장 큰 변경점 중 하나가 서버사이드 렌더링에 관한 내용이라는 소식을 듣고 마침 SSR 에 대해 흥미가 있던 터라 한번 React v18의 주요 변경점이 뭔지 공부해보기로 했다.먼저 기존의 React v17을 v18로 마이그레이션 하는 것은 문제 없다고 한다. 리액트 팀에서 이 부분을 특히 신경써서 만들었다고 하니 믿어도 될 것같다.Automatic batching먼저 리액트의 배치에 대해 알아야한다.Batching리액트에서 더 나은 성능과 예상치않는 버그의 방지를 위해 여러 개의..." }, { "title": "좋은 코드란 무엇인가?", "url": "/posts/%EC%A2%8B%EC%9D%80%EC%BD%94%EB%93%9C%EB%9E%80/", "categories": "study, clean code", "tags": "", "date": "2022-01-06 02:00:00 +0900", "snippet": "좋은 코드란 무엇일까?일반적으로 좋은 코드라고 하면 다음 세가지를 얘기한다. 읽기 좋은 코드 테스트가 용이한 코드 중복이 없는 코드그럼 왜 위 세가지가 갖춰진 코드를 좋은 코드라 하는 걸까? 그리고 어떻게 이 세가지를 지키며 코드를 작성할수 있을까?왜 좋지 않은 코드가 생산되는가?우리는 항상 좋은 코드를 작성하기 위해 노력한다.하지만 언제나 이것을 놓치는 시점이 존재하기에 좋지 않은 코드가 나오게 된다.그럼 어떠다가 놓치게 되는 것일까?우리가 마주치는 상황 이미 운영중인 서비스의 CS 대응하며 수정 변경된 요구사항, ..." }, { "title": "css 선택자", "url": "/posts/css%EC%84%A0%ED%83%9D%EC%9E%90/", "categories": "study, css", "tags": "", "date": "2022-01-05 14:00:00 +0900", "snippet": "*아무 표시 없이 사용하면 페이지에 있는 모든 요소가 대상* { margin : 0; padding : 0;}특정 요소의 모든 자식 요소에 적용할 수도 있음#container * { border : 1px solid black;}주의점 : 남발할 시 성능저하를 불러일으킴#Xid를 대상으로 삼음#container { width : 960px; margin : auto;}주의점 : id는 유연성이 부족하기 때문에, 꼭 id를 사용해야하는지 자문하자. 따라서 찾기 어려운 요소에만 id를 사용하자.Xcla..." }, { "title": "redux-saga concepts", "url": "/posts/redux-saga/", "categories": "study, react", "tags": "redux", "date": "2022-01-02 18:19:26 +0900", "snippet": "Declarative Effectsimport { takeEvery } from &quot;redux-saga/effects&quot;;import Api from &quot;./path/to/api&quot;;function* watchFetchProducts() { yield takeEvery(&quot;PRODUCTS_REQUESTED&quot;, fetchProducts);}function* fetchProducts() { const products = yield Api.fetch(&quot;/products&quo..." }, { "title": "generator 문법", "url": "/posts/generator/", "categories": "study, javascript", "tags": "javascript", "date": "2022-01-02 18:19:26 +0900", "snippet": "Generator 문법 자바스크립트의 기능이며 Redux-saga의 핵심 기능이다. 함수를 특정 구간에 멈춰놓고, 원할때 다시 돌아가게 할 수 있음. 또 반환을 여러번 할수 있다.예시function* generate() { yield 1; yield 2; yield 3; return 4;}const generator = generate(); 제너레이터 함수를 호출 하면, 제너레이터 객체를 반환한다. 이 객체에 있는 메서드인 .next()를 호출하면 yield 한 값을 반환하고 코드의 흐름을 멈춤.generator..." }, { "title": "Decision Tree를 이용한 서울 미세먼지 예측 모델", "url": "/posts/%EB%AF%B8%EC%84%B8%EB%A8%BC%EC%A7%80%EC%98%88%EC%B8%A1%EB%AA%A8%EB%8D%B8/", "categories": "projects", "tags": "", "date": "2022-01-02 18:00:00 +0900", "snippet": "소스코드 깃허브 링크모델 소개 중국 도시별 미세먼지 PM10 농도와, 서울의 기온, 풍속, 습도를 가지고, 서울의 하루 뒤 미세먼지 PM10 농도를 예측하는 모델 서울의 기온, 풍속, 습도는 현재(중국 미세먼지 데이터 날짜와 일치)와 다음날(서울 미세먼지 데이터 날짜와 일치) 데이터를 모두 넣음. 학습할 중국의 도시는 공업이 발달한 도시로 선정하였으며, 다음과 같이 총 10개 시를 선정 베이징, 항저우, 청도, 충칭, 칭다오, 난징, 톈진, 쑤저우, 우한, 상하이 데이터..." }, { "title": "자바스크립트 데코데이터 패턴", "url": "/posts/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0%ED%8C%A8%ED%84%B4/", "categories": "study, javascript", "tags": "javascript", "date": "2021-12-31 16:31:00 +0900", "snippet": "데코레이터 패턴 하나의 코드를 다른 코드로 래핑하거나 javascript 함수를 래핑하는 방법 동일한 클래스의 다른 객체에는 영향을 주지 않고, 정적/동적으로 개별 객체에 동작을 추가할 수 있는 디자인 패턴이다. 문법 let variable = function(object) { object.property = &#39;characteristic&#39;;} @variableclass GFG { }console.log(GFG.property); 현재는 아..." }, { "title": "14658 하늘에서 별똥별", "url": "/posts/14658/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-12-30 14:00:00 +0900", "snippet": "알고리즘 한 점에서 x축으로의 범위를 정하고, 다른 점에서 y축으로의 범위를 정하는 방식으로 모든 두개의 점 조합으로 트래펄린을 설치한다.코드#include &amp;lt;iostream&amp;gt;using namespace std;int n, m, l, k;pair&amp;lt;int, int&amp;gt; s[110];int max(int a, int b) { return a &amp;lt; b ? b : a;}int main() { cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;..." }, { "title": "4485 젤다", "url": "/posts/4485-%EC%A0%A4%EB%8B%A4/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-12-27 23:00:00 +0900", "snippet": "알고리즘 문제를 해석하면, 한 점에서 다른 한 점까지 가는데 최소경로를 찾는 문제로 해석할 수 있다. 따라서 다익스트라 알고리즘을 적용하면 쉽게 풀수있다. 이때 한 칸에 저장된 값은, 그 칸으로 접근하는 경로의 길이로 치환하여 품. 여담 문제 내에 다익스트라라는 꽤나 많은 힌트가 있었으나, dfs에 사로잡혀서 오래 걸렸다. 2차원 배열을 대상으로 다익스트라를 구현한 문제는 처음이었기에 꽤나 신선했다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;qu..." }, { "title": "1613 역사", "url": "/posts/1613-%EC%97%AD%EC%82%AC/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-12-26 23:00:00 +0900", "snippet": "알고리즘BFS 입력으로 들어온, 알려진 전후관계로 그래프를 만듦. 체크를 해야하는 원소 두개가 들어오면, 먼저 첫번째 거에서 bfs를 시작하여 두번째거가 나오면 첫번째가 앞에 있는 것이므로 -1를 출력 찾지못하면, 두번째에서 첫번째를 BFS로 찾음. 찾으면 1을 출력. 찾지못하면, 0 을 출력 시간 복잡도 : O(NM) 사건의 개수 - N, 찾아야하는 선후관계 - M N은 최대 400, M은 최대 50000임. 대략 2천만번의 연산 필요. ..." }, { "title": "react 작동원리부터 tailwindcss 사용까지", "url": "/posts/react-%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC%EB%B6%80%ED%84%B0-tailwindcss-%EC%82%AC%EC%9A%A9%EA%B9%8C%EC%A7%80/", "categories": "study, react", "tags": "", "date": "2021-12-26 18:19:26 +0900", "snippet": "개요 yourlist 웹 리뉴얼 프로젝트에서 tailwind css를 사용하기로 결정하였고, create-react-app을 사용하여 리액트앱을 만든 후, tailwind css를 추가하였다. 이때 tailwind css는 먼저 css 파일을 컴파일 하고, 컴파일 이후의 css 파일을 import 하는 방식으로 동작한다. 따라서 매번 리액트 앱을 실행하기 전에 새로 컴파일을 해줘야하는데, create-react-app에 tailwindcss 추가하는 가이드를 따라서 하면, 런타임 중에 세이브만으로도 서버를 껐다가 킬 필요..." }, { "title": "flutter (rn 개발자를 위한 정리 4)", "url": "/posts/flutter-(rn-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A0%95%EB%A6%AC4)/", "categories": "study, flutter", "tags": "", "date": "2021-12-23 02:00:00 +0900", "snippet": "Props ReactNative 에서 대부분의 컴포넌트는 매겨변수나 속성을 props로 전달함 Flutter에서는 매개변수가 있는 생성자에서 받은 속성을 final로 표시된 지역변수나 함수에 할당함 // Flutterclass CustomCard extends StatelessWidget { CustomCard({@required this.index, @required this.onPress}); final index; final Function onPress; @override Wi..." }, { "title": "flutter (rn 개발자를 위한 정리 3)", "url": "/posts/flutter-(rn-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A0%95%EB%A6%AC3)/", "categories": "study, flutter", "tags": "", "date": "2021-12-22 21:00:00 +0900", "snippet": "Flutter 위젯ViewsView 컨테이너 React Native 에서는 View 가 컨테이너이고 Flexbox를 이용한 레이아웃, 스타일, 터치 핸들링, 접근성제어를 지원 Flutter에서는 Container나, Column, Row, Center같은 위젯 라이브러리의 핵심 레이아웃 위젯을 사용할 수 있음. 레이아웃 위젯 FlatList, SectionList ListView : 목록의 수가 적은 경우에 가장 적합함. 무거운 목록이거나 무한 스크롤 목록일때는 ListVie..." }, { "title": "flutter (rn 개발자를 위한 정리 2)", "url": "/posts/flutter-(rn-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A0%95%EB%A6%AC-2)/", "categories": "study, flutter", "tags": "", "date": "2021-11-25 21:00:00 +0900", "snippet": "기본앱 생성 IDE 에서 생성하는 방법 커맨드라인에서 생성하는 방법$ flutter create &amp;lt;projectname&amp;gt;앱 실행 IDE에서 run 클릭 최상위 디렉토리에서 flutter run 입력importimport &#39;package:flutter/material.dart&#39;;import &#39;package:flutter/cupertino.dart&#39;; // ios 위젯import &#39;package:flutter/widgets.dart&#39;;import &#39..." }, { "title": "flutter (rn 개발자를 위한 정리 1)", "url": "/posts/flutter-(rn-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%A0%95%EB%A6%AC)/", "categories": "study, flutter", "tags": "", "date": "2021-11-25 21:00:00 +0900", "snippet": "진입점main() { // 항상 최상단 앱의 진입점 main() 이 있어야함.}콘솔print(&quot;hello world&quot;)변수 dart 는 타입검사를 하는 언어 정적 타입 검사와 런타임 타입검사를 동시에 사용하며, 변수의 값이 변수의 정적타입과 항상 일치하는지 검사함. 타입 추론을 하기에 일부 타입표기는 생략가능String name = &#39;dart&#39;; // 명시적 타입 선언var othername = &#39;dart&#39;; //타입 추론 초기화하지 않은 변수는 null값을 가짐.va..." }, { "title": "LocateC", "url": "/posts/st-algorithm/", "categories": "projects", "tags": "", "date": "2021-11-25 18:19:26 +0900", "snippet": "개발 계기 코로나 전에 커피를 마시면서 자주 길거리를 걸어다녔는데, 항상 다 마시고 남은 빈 통만 들고 한참을 쓰레기통을 찾아다녔던 기억이 있었다. 그런데 학과 내에서 학교 생활에 도움을 줄 서비스를 개발하는 공모전을 하였고, 위 기억을 되살려서 학교 내 흡연장소, 쓰레기통의 위치를 알려주는 서비스를 개발해보기로 하였다.서비스 소개 교내에 위치한 흡연장소, 쓰레기통의 위치를 사진과 함께 확인 가능. 가장 가까운 곳에 위치한 흡연장소/쓰레기통을 안내 사용자는 관리자에게 서버에 등록되지않은 새로운 위치를 추가하도록 요청을..." }, { "title": "Yourlist", "url": "/posts/yourlist/", "categories": "projects", "tags": "", "date": "2021-11-24 14:38:44 +0900", "snippet": "서비스 소개 사용자가 원하는 유튜브 영상의, 원하는 부분만을 가지고 재생목록을 만들 수 있도록 하는 서비스 회원가입을 통해 회원이 될 수 있고, 회원은 재생목록을 무제한으로 만들 수 있지만, 비회면원 5개까지만 가능 i18n을 통한 글로벌 언어 제공 앱, 웹에서 모두 사용가능하도록 개발. 서비스 링크 web playstore새롭게 배운 점react-native, expo 처음으로 react-native와 react-native의 개발 플랫폼인 expo를 통해 앱개발을 하였다..." }, { "title": "flutter 첫 걸음", "url": "/posts/flutter-%EA%B3%B5%EB%B6%80/", "categories": "study, flutter", "tags": "", "date": "2021-11-23 23:00:00 +0900", "snippet": "1단계 : Starter Flutter app void main() =&amp;gt; runApp(MyApp()); 처럼 화살표 함수 사용가능 한줄 함수에 화살표를 사용한다. 최상단 앱 : StatelessWidget을 상속받아 앱 자체를 위젝으로 만든다. Flutter에서는 정렬, 여백, 레이아웃 등 모든 것이 위젯임. Scaffold 위젯은, app bar, title, body 속성을 기본으로 제공함. 위젯은 build() 를 오버라이딩하여 하위 위젯을 어떻게 표현할지 명시 가능2단계 :..." }, { "title": "2629 양팔저울", "url": "/posts/2629-%EC%96%91%ED%8C%94%EC%A0%80%EC%9A%B8/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-11-18 14:00:00 +0900", "snippet": "알고리즘 모든 경우를 따지기 위해서 각 추가 구슬 반대쪽에 올라가는 경우, 저울에 안올라가는 경우, 구슬과 같은 쪽에 올라갈 경우를 모두 고려해야함 배낭문제를 응용하여, 추를 하나씩 모든 무게에 대해 검사를 한다. true이면 구슬 반대쪽 저울에 추만으로 만들 수 있는 무게라는 뜻. 현재 추를 사용하여 만들 수 있는 무게면 true표시 현재 추를 사용하지않고 이전 추로만으로도 만들 수 있는 무게면, 현재추를 구슬과 같은 저울에 놓고 만들 수 있는 무게도 true 표시 위..." }, { "title": "10986 나머지합", "url": "/posts/10986-%EB%82%98%EB%A8%B8%EC%A7%80%ED%95%A9/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-09-10 20:00:00 +0900", "snippet": "알고리즘 구간합 정의 : i ~ j 까지의 구간합 = (1~ j 까지의 구간합) - (1 ~ i -1 까지의 구간합) 위 정의에 따라 우리가 구해야하는 (i ~ j 까지의 구간합) % m = 0 은 ((1~ j 까지의 구간합) % m - (1 ~ i -1 까지의 구간합) % m) % m 과 같음 따라서 (1~ j 까지의 구간합) % m = (1 ~ i -1 까지의 구간합) % m 인 (i, j) 가 조건을 만족함. 코드#include &amp;lt;iostream&amp;gt;typed..." }, { "title": "12906 새로운 하노이탑", "url": "/posts/12906-%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%95%98%EB%85%B8%EC%9D%B4%ED%83%91/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-09-08 20:00:00 +0900", "snippet": "알고리즘 평범하게 BFS하면 되는데, 방문 표시를 어떻게 하느냐가 이번 문제의 관건이다. 난 각 기둥의 문자열 사이에 “/” 라는 문자를 추가하여 상태를 구분짓고, 이것을 set에 저장하였다. 이렇게 상태를 구분지어본 것은 처음이라, 코드를 짜면서도 계속 내 코드를 의심했다 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;set&amp;gt;using namespace std;struct nod..." }, { "title": "9576 책 나눠주기", "url": "/posts/9576-%EC%B1%85-%EB%82%98%EB%88%A0%EC%A3%BC%EA%B8%B0/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-09-02 20:00:00 +0900", "snippet": "알고리즘 a, b에서 b의 순서대로 정렬 1 2 1 1 이런식으로 입력이 들어오면, 1 2에서 1에 넣고 1 1에선 넣을 수가 없기 때문에. 정렬된 (a, b)를 앞에서부터 검사하는데, a에서 b까지 1씩 증가하면서 가능하면 책을 배정하고, b까지 검사했는데도 남아있는 책이없으면 패스한다. 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt..." }, { "title": "expo push notification", "url": "/posts/paasta-noti/", "categories": "study, react-native", "tags": "", "date": "2021-09-02 16:00:00 +0900", "snippet": "paasta notification 회의 방법들 expo 서버로 보내는 방법 (https://docs.expo.dev/push-notifications/sending-notifications/) expo에서 제공하는 라이브러리를 사용하면 됨. but 자바 sdk를 제공하긴 하는데 이건 maven 기반이고, 현재 우리 프로젝트는 gradle 기반임 fcm, apns 에 직접 보내는 방법 (https://docs.expo.dev/pu..." }, { "title": "타입스크립트", "url": "/posts/typescript/", "categories": "study, typescript", "tags": "", "date": "2021-08-25 16:00:00 +0900", "snippet": "타입스크립트 연습 tsconfig.json compilerOptions:{ ​ “outDir” : “./dist” // 컴파일된 파일 저장. expo 에선 안해도 될듯 } jsx -&amp;gt; tsx, js -&amp;gt; ts 기본타입let mightBeUndefined: string | undefined = undefined; // string 일수도 있고 undefined 일수도 있음let nullableNumber: n..." }, { "title": "1918 후위표기식", "url": "/posts/1918-%ED%9B%84%EC%9C%84%ED%91%9C%EA%B8%B0%EC%8B%9D/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-08-24 21:00:00 +0900", "snippet": "알고리즘 괄호치기 / 는 앞에서부터 가까운 두 괄호를 묶음. 그다음 + - 로 마찬가지로 함. 양쪽에 모두 없으면 패스함 출력 여는괄호, 연산자는 스택에 넣기. 닫는 괄호가 나오면 여는괄호가 나올때까지 쭉 빼기. 알파벳은 그냥 출력. 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std..." }, { "title": "expo 배포", "url": "/posts/expo-%EB%B0%B0%ED%8F%AC/", "categories": "study, react-native", "tags": "", "date": "2021-08-24 16:00:00 +0900", "snippet": "EXPO 앱 google playstore 배포 app.json 수정 expo build:android -t app-bundle google play app signing 이 선행되어야함. https://docs.expo.dev/distribution/app-signing/ keystore를 구글 개발자계정에서 받을 수 있는듯? https://support.google.com/googleplay/android-developer/answer/984..." }, { "title": "React-boilterplate 설명", "url": "/posts/react-boilerplate/", "categories": "study, react", "tags": "", "date": "2021-08-18 16:00:00 +0900", "snippet": "react-boilerplate 설명 react-boilerplate 라는, 리액트 프로젝트를 처음 시작할때 create-react-app을 대체하여 사용하기에 아주 좋아보이는 프로젝트가 있다. https://github.com/react-boilerplate/react-boilerplate 상당히 많은 초기 설정을 하는데, 너무 많아서 뭐가 뭔지 알아보기가 어렵다. 따라서 이 초기설정들을 설명해놓은 글이 있고, 이 포스트는 이 글을 보고 공부한 내용을 적은 것이다. ht..." }, { "title": "9251 LCS", "url": "/posts/9251-LCS/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-08-17 21:00:00 +0900", "snippet": "알고리즘https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-SubsequenceLCS 알고리즘을 굉장히 잘 설명한 글이 있어 링크로 대체코드#include &amp;lt;ios..." }, { "title": "2096 내려가기", "url": "/posts/2096-%EB%82%B4%EB%A0%A4%EA%B0%80%EA%B8%B0/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-08-12 21:00:00 +0900", "snippet": "알고리즘 내려올 수 있는 곳은 굉장히 한정되어있고, 순차적으로 가장 작은값을 or 가장 큰값을 구하기만 하면 되는 문제이기에 일차원 DP로 해결이 가능하다. 이런 종류의 문제를 “슬라이딩 윈도우” 라고 부르는 것 같다코드#include &amp;lt;iostream&amp;gt;using namespace std;int n, ansMax = -1, ansMin = 2000000000, cur[2][3], tCur[2][3];int min(int a, int b) { return a &amp;lt; b ? a : b;}int..." }, { "title": "17387 선분교차 2", "url": "/posts/17387-%EC%84%A0%EB%B6%84%EA%B5%90%EC%B0%A8-2/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-08-08 21:00:00 +0900", "snippet": "알고리즘 양 선분이 평행할 경우, 또는 한 쪽이 x축에 평행하고, 다른 축이 y축에 평행할 경우엔 조건문을 통해 범위를 잘 검사하여 처리 나머지 경우엔 다음과 같은 방법을 사용한다. 첫번째 선분을 이루는 직선이 두번째 선분을 양분하고, 그 반대도 양분하면 두 선분은 교차한다. 이때 한 직선이 한 선분을 양분하는지 알아보는 식은 다음과 같다. f1 = (y21-y11)(x12-x11) - (x21-x11)(y12-y11) ..." }, { "title": "11779 최소비용구하기 2", "url": "/posts/11779-%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9%EA%B5%AC%ED%95%98%EA%B8%B0-2/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-08-07 21:00:00 +0900", "snippet": "알고리즘 일반적인 다익스트라로 푸는데, 풀면서 이전에 어디서 왔는지를 기록한다. 다익스트라가 끝나고, 끝에서부터 왔던길을 되돌아가며 경로를 찾아낸다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#define INF 2000000000000typedef long long ll;using namespace std;int n, m, s, e, pa..." }, { "title": "1208 부분수열의 하1 2", "url": "/posts/1208-%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A92/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-08-06 21:00:00 +0900", "snippet": "알고리즘 수를 두개 집합으로 나눔. 나눈 집합 각각에 대해 모든 경우를 살펴봐서 각 집합 내부에서 s에 도달한 횟수를 세고, 만들 수 있는 수와 그 수가 나온 횟수를 센다. 위에서 센 횟수로, 양 집합에서 만들 수 있는 수가 a, b이고, 이 a, b가 각 집합에서 나온 횟수를 c, d라고 하면, a + b = s 일때, c * d만큼의 수를 전체 경우의 수에 더한다. 이때 save 배열을 set으로 구현한다면 메모리 사용량이 대폭 줄어든다.(각 집합이 최대 20개이니, 나올..." }, { "title": "1504 특정한 최단경로", "url": "/posts/1504-%ED%8A%B9%EC%A0%95%ED%95%9C-%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-26 22:00:00 +0900", "snippet": "알고리즘 1 -&amp;gt; v1 -&amp;gt; v2 -&amp;gt; n 과 1 -&amp;gt; v2 -&amp;gt; v1 -&amp;gt; n 중 어느것이 더 짧은지 확인하면 된다. 즉, 원점이 1일때, v1 일때, v2일때 다익스트라를 진행하고, 거기서 나온 거리로 위 거리를 계산하여 출력하면 된다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;#define INF 2100000000;..." }, { "title": "115653 구슬탈출4", "url": "/posts/15653-%EA%B5%AC%EC%8A%AC%ED%83%88%EC%B6%9C4/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-24 22:00:00 +0900", "snippet": "알고리즘 푸는 방법은 bfs지만, 구현이 더 까다로운 문제이다. visit은 빨간구슬, 파란구슬의 위치를 동시에 기록하여 두 구슬 모두 같은 자리로 다시 가지 않도록 한다. 각 방향으로 기우릴때는 일단 한쪽을 먼저 보낸다고 가정하고, 실제로 먼저 보내는지 검사한 후 아니라면 다른쪽을 먼저 보낸다. 한쪽이 구멍에 먼저 빠지면, (-1,-1) 위치로 보내어 충돌이 발생하지 않도록 한다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#define INF 20..." }, { "title": "12872 플레이리스트", "url": "/posts/12872-%ED%94%8C%EB%A0%88%EC%9D%B4%EB%A6%AC%EC%8A%A4%ED%8A%B8/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-23 00:00:44 +0900", "snippet": "알고리즘 dp를 사용 save[101][101] 로 메모이제이션을 위한 배열을 선언 한 곳에는 이제까지 들어간 새로운 곡의 수, 한 곳에는 현재 깊이 원리 m == 0 일때, 현재 깊이 d에서는 이전 곡의 구성이 어찌됐든 간에, 현재~끝에 나와야할 곡의 구성의 수는 같다. 하지만 m이 0이 아니고, 모든 곡이 나와야한다는 조건이 있으므로, 이전곡의 구성에 영향을 받는데, 이때 이전에 들어간 개별적인 곡의 수가 몇개였는지에 대해서만 생각해주면 된다. ..." }, { "title": "15989 1,2,3 더하기 4", "url": "/posts/15989-1,2,3-%EB%8D%94%ED%95%98%EA%B8%B0-4/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-10 21:00:44 +0900", "snippet": "알고리즘 save[0] = 1로 초기화 i : 1~3 에서 j : i~m 까지 save[j] += save[j-i] 를 반복 원리 i = 1에서는 1로만 쭉 더한 것(3 = 1 + 1 + 1) 경우만 따짐. i = 2에서는 1로만 더한 것에 2를 추가한 경우를 따진다. i = 3에서도 마찬가지. ex) m = 4일때 i = 1 ..." }, { "title": "1890 점프", "url": "/posts/1890-%EC%A0%90%ED%94%84/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-09 21:00:44 +0900", "snippet": "알고리즘 save[0][0] = 1 부터 시작해서, 모든 점을 순서대로 방문하며 자신의 위, 왼쪽 점들 중 자신에게로 올 수 있는 모든 점들을 save[i][j]에 저장한다.코드#include &amp;lt;iostream&amp;gt;typedef long long ll;using namespace std;int n, map[101][101];ll save[101][101];ll dp();int main() { cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) for..." }, { "title": "11048 이동하기", "url": "/posts/11048-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-09 21:00:44 +0900", "snippet": "알고리즘 (1,1)에서부터 순서대로 모든 점을 대상으로 visit (i -1, j), (i, j-1), (i-1,j-1) 이 가지고 있는 점 중 가장 큰 점을 visit(i,j) 에 저장한다.코드#include &amp;lt;iostream&amp;gt;using namespace std;int visit[1010][1010], n, m, map[1010][1010];int max(int a, int b) { return a &amp;gt; b ? a : b;}int main() { ios::sync_with_stdio(fa..." }, { "title": "14529 Where&#39;s Bessie", "url": "/posts/14529-Where's-Bessie/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-08 21:10:44 +0900", "snippet": "알고리즘 그냥 조건에 맞춰서 풀면 되는 문제이다. 가능한 모든 사각형에 대해 검사하고, pcl을 뽑아낸 다음에, 마지막으로 ‘다른 pcl에 포함되는 pcl’을 제거하고 출력하면 된다. ‘한 색은 연속된 지역이 하나이고, 다른 색은 두개 이상이어야한다. ‘ 라는 조건은 다음과 같이 하면된다. 인접한 같은 색에 대해서만 BFS를 진행하고, BFS 진행된 총 수 t를 센다. t가 현재 지역에서 그 색의 수와 같으면 첫번째 조건이 만족되었다고 표시, 그것이 아니라면 두번째 조건이 만족했다고 표시하는데, ..." }, { "title": "브라우저 동작원리", "url": "/posts/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC/", "categories": "study, web", "tags": "browser", "date": "2021-07-07 21:10:44 +0900", "snippet": "기본 구조 사용자 인터페이스 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어 렌더링 엔진 : 요청한 콘텐츠를 표시. HTML 을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함. 통신 UI 백엔드 : 콤보박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서 OS 사용자 인터페이스 체계를 사용함. 자바스크립트 해석기 자료저장소 : Localstorage, SessionStorage, Cookie 크롬은 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지함. 즉,..." }, { "title": "10875 뱀", "url": "/posts/10875-%EB%B1%80/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-07 21:10:44 +0900", "snippet": "알고리즘 뱀이 성장하면서 생기는 가로직선, 세로직선을 따로 저장. 새롭게 생기는 직선이 이전에 저장된 직선에 걸리는지 확인. 이때, 직선은 정렬하여 뱀이 나아가는 방향에서 가장 가까운 직선에 걸리도록 하자.여담 깔끔하게 구현하기에 매우 애를 먹었고, 가능하지도 않았다. 그만큼 분리하여 생각해야하는 조건들이 많고, 그렇기에 실수를 할 가능성이 매우 크다. 알고리즘 자체를 간단하므로, 틀렸습니다가 뜬다면 실수를 하지 않았는지를 중점으로 찾아보면 될 것 같다.코드#include &amp;lt;iostream&amp;gt;#..." }, { "title": "9874 Wormholes", "url": "/posts/9874-Wormholes/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-05 19:10:44 +0900", "snippet": "알고리즘 페어링 쌍을 만들고, 사이클이 있는지 확인하는 작업을 모든 페어링 쌍을 대상으로 하면 됨. 헤멘 부분 사이클을 찾을때 같은 페어링쌍을 다시 방문하는게 아니라, 같은 점을 다시 방문하는지 확인해야함. check 를 언제 초기화해야하는지 헷갈림 -&amp;gt; 확실히하려면 매 시작점마다하면 됨. 여담 출척 Olympiad&amp;gt; USA Computing Olympiad 인데, 요즘 이 출처의 문제들을 풀면서 느낀 게, 이 출처의 문제들은 내용자체는 간단한데, 예외 또는 특수..." }, { "title": "5827 What&#39;s Up With Gravity", "url": "/posts/5827-What's-Up-With-Gravity/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-04 21:10:44 +0900", "snippet": "알고리즘 BFS 사용 시작할때 C는 떨구고 시작. bfs를 진행하는데 왼쪽, 오른쪽, 중력 바꿔서 검사하고 떨군다. 떨어지는 도중에 D를 만나면, 만났다고 표시 -&amp;gt; 끝나고 바로 ans 업데이트 이때 visit은 해당 위치에서 해당 중력일때 최소 flip을 저장함 나는 이동후 떨구기 전과 떨군 후 두가지만 visit 표시했지만, 더 할 수도 있을 거 같음. 시간 더 줄이기 우선순위 큐 사용하여, flip 횟수가 적은 것을 우선하기 ..." }, { "title": "React native 기초", "url": "/posts/react-native-%EA%B3%B5%EB%B6%80/", "categories": "study, react-native", "tags": "", "date": "2021-07-03 19:30:44 +0900", "snippet": "개발환경 만들기 필요한 것 : 안드로이드 스튜디오, expo, 안드로이드 emulator npm install -g expo-cli 안드로이드 스튜디오 설치 -&amp;gt; 설치 후 sdk도 설치 안드로이드 스튜디오을 키고, configuration에 들어가서 AVD manager을 누르고, create virtual device를 눌러 가상머신 만들기 프로젝트 시작 expo init [프로젝트명] expo start 하면 실행됨 아까 만든 가상머신을 실행시키고, run on and..." }, { "title": "14466 소가 길을 건너간 이유 6", "url": "/posts/14466-%EC%86%8C%EA%B0%80-%EA%B8%B8%EC%9D%84-%EA%B1%B4%EB%84%88%EA%B0%84-%EC%9D%B4%EC%9C%A0-6/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-07-02 21:10:44 +0900", "snippet": "알고리즘 모든 소를 대상으로 ‘길’이 있는 길로 다니지 말고 BFS를 함 다른 소를 만날때마다 count를 1씩 증가시키고, 한 소의 bfs가 다 끝나면 n - count를 ans에 저장 ans / 2를 출력코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int n, k, r, map[101][101];list..." }, { "title": "16639 괄호 추가하기 3", "url": "/posts/16639-%EA%B4%84%ED%98%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0-3/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-06-30 23:30:44 +0900", "snippet": "알고리즘 브루트포스로 함. 서로 이웃한 정수끼리 연산을 하는 조합을 하는데, 모든 조합을 전부 다 돌린다. 숫자는 최대 10개이고, 브루트포스로 했을때 O(n!) 이므로, 충분히 시간안에 돌릴 수 있다. 코드#include &amp;lt;iostream&amp;gt;using namespace std;long long N, num[10];char op[10];long long calculate(int deep);long long max(long long a, long long b) { retur..." }, { "title": "18500 미네랄 2", "url": "/posts/18500-%EB%AF%B8%EB%84%A4%EB%9E%84-2/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-06-29 19:38:44 +0900", "snippet": "알고리즘 2933 미네랄과 상당히 유사한 문제이지만, “분리된 클러스터의 각 열중 맨 아래 부분이 아닌 부분이 다른 클러스터 위에 떨어질 수 있다”라는 조건을 하나 더 생각해야함. 막대를 던지고 클러스터가 분리되면 바닥에 닿았는지 판단. 닿지 않았다면 아래로 내리는데, 내려갈 수 있는 미네랄을 다 검사. 가장 적게 내려갈 수 있는 거리만큼 클러스터를 내림.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;algorithm&am..." }, { "title": "10021 watering the field", "url": "/posts/10021-watering-the-field/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-06-24 19:38:44 +0900", "snippet": "알고리즘 크루스칼 모든 필드 사이의 거리를 계산하고, 양 쪽 필드의 번호와 거리를 벡터에 저장한다. 거리순으로 정렬하고, 크루스칼 알고리즘 시행 이때, 단순히 union-find 알고리즘으로 하면 find에서 시간초과가 난다. 따라서 set을 활용해서 크루스칼을 하면 된다.헤맨 지점 set을 이용해서 할때, 서로 다른 집합이었다가 합쳐질때, 하나만 옮기면 안된다. 그 set에 속해있는 모든 점을 다 옮겨야함 꼭 첫번째 집합으로 합쳐지지 않는다. 따라서, 모든 점들이 같은 집합에 있는지 하나하나 확인해봐야한다.코드#..." }, { "title": "5213 과외맨", "url": "/posts/5213-%EA%B3%BC%EC%99%B8%EB%A7%A8/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-06-19 19:38:44 +0900", "snippet": "알고리즘 BFS로 하나씩 찾아갈 수 있지만, 나는 연결되어있는 타일을 그래프로 표현한 다음 BFS를 하였다. BFS를 할땐, visit을 -1로 초기화하고, 이전에 온 곳을 기록하는 형식으로 하자. 그러면 마지막에서부터 온곳을 탐색하며 가서 첫번째 타일까지 가면 된다. 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;usi..." }, { "title": "Graph ql front", "url": "/posts/GraphQL-front/", "categories": "study, graphql", "tags": "", "date": "2021-06-19 12:35:44 +0900", "snippet": "설치yarn add @apollo/react-hooks apollo-boost graphql사용법 GraphQL API로 요청을 보낼때는, 요청문을 axios나 fetch를 사용하여 POST 메소드로 보내야함. 하지만 Apollo를 사용하면, 위와같이 하지 않아도 된다. 먼저, Apollo client를 만들어야함. Apollo client 셋업다음과 같이, apollo.js 파일을 생성하고, client를 만들어주자. uri에는 graphQL 서버의 주소가 들어가면 된다.// s..." }, { "title": "Graph ql back", "url": "/posts/GraphQL-back/", "categories": "study, graphql", "tags": "GraphQL", "date": "2021-06-19 12:35:44 +0900", "snippet": "Qraph QL 이 해결할 수 있는 문제 over-fetching : 요청한 것보다 많이 보내줌. ex) username만 필요한데, 프로필 사진도 보냄 under-fetching : 하나의 작업을 위해 여러 요청을 보내게 하는 것. QraphQL에는 URL이 존재하지 않음. 하나의 엔드포인트만 있고, 그곳으로 쿼리를 보내면, 쿼리에 맞춰서 알아서 데이터를 보내준다. 즉, 정확히 요청한 데이터만 보내준다. 시작https://www.npmjs.com/package/graphql-..." }, { "title": "3108 logo", "url": "/posts/3108-logo/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-06-16 12:35:44 +0900", "snippet": "알고리즘 겹치는 사각형을 각기 다른 집합으로 분류 + (0,0) 점이 속하는 집합이 있는지 확인 앞에서부터 겹치는 사각형을 확인하고, 겹치면, 큐의 맨 앞에 넣어서 DFS 방식으로 집합을 분류 매번 모든 사각형을 검사하는데, 이미 분류된 사각형은 다시 검사하지 않아도 됨. 이때 (0,0,0,0)인 사각형(사실은 점)을 1개 더 저장하여, 검사할때 이 점도 검사하도록 하여, 클래스가 분류되면, 원점이 속하는 집합이 있는거고, 분류되지 않으면 없는 것이니, 이것으로 최종 결과를 계산함.코드#include &amp;lt;io..." }, { "title": "1039 교환", "url": "/posts/1039-%EA%B5%90%ED%99%98/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-06-13 19:38:44 +0900", "snippet": "알고리즘 DP 사용. bottom-up 방식으로 끝까지 간 후, 하나씩 올리면서 가장 큰 걸 반환 0&amp;lt;= i &amp;lt; j &amp;lt;= M 일때, array[i] == 0 이고, j == M이면 바꾸지 않음. 10 이하는 무조건 -1, 나머지는 0이 반환되면 한번도 끝까지 도달하지 못한 것이므로 K번 바꾸기 연산이 불가능한 것. 즉, -1 출력코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;alg..." }, { "title": "Junctions/Seoul 2021 해커톤", "url": "/posts/junction_portfolio/", "categories": "projects", "tags": "", "date": "2021-05-26 21:38:44 +0900", "snippet": "Junctions/Seoul 2021 해커톤 Junction 은 핀란드에서 시작된 국제 해커톤으로, 2박 3일동안 진행된다. Autocrypto, Microsoft, SIA, AWS game tech 4개의 기업이 파트너로 참가하고, 참가자들은 이 4개의 기업 중 하나를 자신이 참가할 track으로 선택하여 참여한다. 수상은 track 별로 1,2,3등과 전체 우승으로 나뉜다. track 별 수상자는 기업의 관련자가 뽑으며, 전체 우승은 참가자들의 투표로 결정된다.역할 및 결과 우리팀 Hippy는 AWS game tec..." }, { "title": "로티(lottie) 애니메이션 적용", "url": "/posts/lottie_animation/", "categories": "study, css", "tags": "", "date": "2021-05-24 21:38:44 +0900", "snippet": "lottie 애니메이션Junction 해커톤을 하며 lottie 애니메이션을 접하게 되었다.간단히 코드로 불러올 수 있으며, json 파일로 불러올 경우 색상 변경 등의 커스터마이징도 가능하여 활용도가 높다.불러오는 법(react 기준) npm install @lottiefiles/react-lottie-player 다음 코드 삽입 &amp;lt;Player src={fireVideo} background=&quot;transparent&quot; speed=&quot;1&quot; style..." }, { "title": "CSS 단위", "url": "/posts/CSS_unit/", "categories": "study, css", "tags": "css", "date": "2021-05-24 21:38:44 +0900", "snippet": "em : 부모의 단위에 배수를 더하는 것.body {​ font-size:14px;}div {​ font-size:1.2em;}면 div엔 16.8px로 들어간다.이때 부모의 크기에서 배수를 더하는 거라서, 자식마다 em을 써서 내려가면 크기는 계속 배수로 증가하게 된다.remroot의 단위에 배수를 더하는 것. 최상위 태그에 대해서 배수로만 구하는 거라, 자식의 깊이가 깊어져도 크기가 기하급수적으로 커지지 않는다.vh : viewport height, vw : viewport width뷰포트의 높이값과 너비값에 맞추어 사용한..." }, { "title": "CSS position 에 관하여", "url": "/posts/CSS_position/", "categories": "study, css", "tags": "", "date": "2021-05-24 21:38:44 +0900", "snippet": "static 기본 속성 원래 있어야할 위치에 있다. top, left, right, bottom 으로 위치 조절 불가능relative static 일 때의 위치를 기준으로 조절 가능. 겹치는 element 가 있으면, z-index로 결정한다.absolute position:static 을 가지고 있지 않은 부모를 기준으로 위치가 조절 된다.fixed 브라우저 기준으로 위치 조절 가능" }, { "title": "JunctionXSeoul 2021 후기", "url": "/posts/junction_seoul_2021_review/", "categories": "projects", "tags": "", "date": "2021-05-24 17:38:44 +0900", "snippet": "결과AWS game tech 트랙 우승!후기해커톤 첫 참여였지만 좋은 팀원들과 함께해서 트랙 우승을 이루어내 기뻤다.front-end 참여하여 메인 기능과는 보다는 디자이너님이 만들어주신 뷰 구현에 힘을 쏟았다.배운 것도 많았고, 더 공부할 것도 많이 보였다. 배운 것 tool 관련 trello 기본 사용법 figma 사용법 slack 을 통한 협업 lottie animation, json을 이용한 색상 및 동작 변형 ..." }, { "title": "16928 뱀과 사다리게임", "url": "/posts/16928/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-05-19 23:38:44 +0900", "snippet": "알고리즘 BFS로 가능한 경우를 찾아가면 된다. 그런데 주의점은, 뱀을 타는게 더 이득일 경우가 있다는 것만 주의하자 ex) 2 12 6030 9965 29 코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int N, M, box[110];list&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; q;bool visited[110];int BFS();int main() { cin &amp;gt;&amp..." }, { "title": "14238 출근기록", "url": "/posts/14238/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-05-18 23:38:44 +0900", "snippet": "알고리즘 DP 사용 앞에서부터 백트래킹처럼 조건이 맞을때 전진 만약 끝까지 갔으면 gotAns = true 설정하여, true이면 바로 종료. 만약 끝까지 안갔으면, save에 저장 이때 save[현재-2 문자][현재-1문자][남은 A][남은 B][남은 C] 로 함 현재 상태를 결정하는 건, 전전문자, 전 문자, 남은 A의 개수, 남은 B의 개수, 남은 C의 개수로 결정되므로. 사용한 A,B,C 의 개수가 같다면, 현재-2 이전의 문자 배열은 상관없기 때문이다. DP 함수 시작부분..." }, { "title": "2437 저울", "url": "/posts/2437/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-05-17 18:38:44 +0900", "snippet": "알고리즘 정렬 후 앞에서부터 검사 (이전까지 연속적으로 잴 수 있는 무게의 최댓값 + 1) 보다 현재 추가 더 무거우면 break. 최댓값 + 1이 잴수없는 최소의 값임.코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int n, weights[1010];int main() { cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; weights[i]; sort(&amp;amp..." }, { "title": "15971 두 로봇", "url": "/posts/15971/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-05-17 18:38:44 +0900", "snippet": "알고리즘 BFS로 시작 정점부터, 이제까지 경로 중에 있었던 가장 큰 weight(bigest)와 이제까지의 weight를 모두 합한 값(length)을 저장해나가며 진행. 이때 visit을 표시할 때, true/false 값이 아닌, length을 저장. BFS를 진행할 땐, node에 저장된 length와 현재 로봇의 length와 그 통로의 weight를 합한 값이 작을때만 진행. 3을 위해서는 visit 배열을 큰 값으로 초기화해야함.코드#include &amp;lt;bits/stdc++.h&amp;gt;usin..." }, { "title": "Firebase/Function firestore, storage 쓰기, 읽기", "url": "/posts/firebase_function_firestore_storage/", "categories": "study, firebase", "tags": "firebase", "date": "2021-05-15 16:00:00 +0900", "snippet": "firebase cloud function에서 firestore와 storage의 이벤트트리거를 등록하는 예제는 firebase 문서에 자세히 설명되어있다.여기서는 cloud functions에서 firestore와 storage에 접근하여 읽고 쓰는 법을 간단한 코드로 보여줄 것이다. firestore firebase cloud function 가이드에 나온대로 admin을 초기화시켜준다. admin.firestore() 로 firestore 관련 함수를 호출하면 끝. const admin..." }, { "title": "Firebase/Function Puppeteer 사용하기", "url": "/posts/Firebase_cloudfunction_puppeteer/", "categories": "study, firebase", "tags": "firebase", "date": "2021-05-15 16:00:00 +0900", "snippet": "일반 노드에서의 환경과 같이 사용하면 된다. 홈페이지에 접속 후 스크린샷을 찍어 스토리지에 업로드하는 예시const puppeteer = require(&quot;puppeteer&quot;);const { Storage } = require(&quot;@google-cloud/storage&quot;);const storage = new Storage();router.post(&quot;/&quot;, (req, res) =&amp;gt; { (async () =&amp;gt; { const browser = awa..." }, { "title": "REACT/CORS 개발 환경에서, 외부 API 와 연결할때 쿠키가 생성되지 않는 문제", "url": "/posts/React_cors_problem_under_dev_mod/", "categories": "study, react", "tags": "", "date": "2021-05-14 16:00:00 +0900", "snippet": "이미 서버에 올라간 백엔드 API 와 로그인 작업을 하던 도중에, 백엔드에서 보내는 쿠키를 브라우저가 저장하지 않는 문제를 발견했다.찾아보니 CORS 위반으로 생기지 않는 것이라고 하였다.그럴때 해결방법은 두가지가 있다. package.json에 proxy 설정 추가//package.json{ ... &quot;proxy&quot; : &quot;백엔드 주소&quot; ...}위처럼 하면, proxy에서 통신을 하는 것이라고 하여 CORS 를 위반하지 않고 제대로 쿠키를 저장할 수 있다. setupP..." }, { "title": "노드 스터디 7장", "url": "/posts/node_ch7/", "categories": "study, node", "tags": "", "date": "2021-05-10 16:00:00 +0900", "snippet": "MySQL데이터베이스란 DBMS : 데이터베이스 관리시스템 RDBMS : 관계형 DBMS. 대표적으로 Oracle, mysql, mssql 등이 있음.Datagrip 사용 Datagrip : 데이터베이스를 위한 IDE. 학생인증을 하면 무료사용가능 프로젝트 생성 alt+insert 혹은 좌측 + 클릭 -&amp;gt; 원하는 데이터베이스 클릭 좌측 하단에 download 클릭 이후 유저이름, 비밀번호 생성 후 ok 좌측 상단 초록 화살표 클릭하여 connect 오류 내용 : Server retu..." }, { "title": "노드 스터디 6장", "url": "/posts/node_ch6/", "categories": "study, node", "tags": "", "date": "2021-05-06 16:00:00 +0900", "snippet": "Express 로 웹서버 만들기6.1 익스프레스 프로젝트 시작const express = require(&quot;express&quot;);const app = express();app.set(&quot;port&quot;, process.env.PORT || 3000);app.get(&quot;/&quot;, (req, res) =&amp;gt; { res.send(&quot;Hello, Express&quot;);});app.listen(app.get(&quot;port&quot;), () =&amp;gt; { con..." }, { "title": "노드 스터디 4장", "url": "/posts/node_ch4/", "categories": "study, node", "tags": "", "date": "2021-05-06 14:07:00 +0900", "snippet": "http 모듈로 서버 만들기4.1 요청과 응답 이해하기- req : 요청에 관한 정보- res : 응답에 관한 정보. - .writeHead : 헤더. 응답에 대한 정보를 기록하는 메서드. - 첫번째 인수 : 코드 - 두번째 인수 : 응답에 대한 정보를 알림. - .write : 본문(Body) - 첫번째 인수 - 클라이언트로 보낼 데이터. 여러번 호출해서 데이터를 여러개 보내도 됨. - .end : 응답을 종료함. 여기에도 데이터를 넣..." }, { "title": "8980 택배", "url": "/posts/8980/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-05-03 00:38:44 +0900", "snippet": "8980 택배풀이(그리디)1. 각 도착지별로 정보를 따로 관리함.(같이해도 되긴함)2. 도착지 1~N번까지 입력받은 C로 트럭 용량을 초기화함.3. 도착지 2번부터 정보를 하나씩 뽑아가며 검사. 시작지점~현재 도착지-1 까지에서의 최소값을 뽑고, 그만큼을 2의 배열에서 빼줌.(물론 그 최솟값이 현재 정보에서의 택배량보다 많으면 택배량으로 제한.)* 최솟값으로 뽑을 경우, 최대한 많이 담는 것이므로, 그것이 결국 최댓값이 됨.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algori..." }, { "title": "노드 스터디 5장", "url": "/posts/node_ch5/", "categories": "study, node", "tags": "", "date": "2021-04-29 18:07:00 +0900", "snippet": "패키지매지저package.json 설치한 패키지의 버전 관리 노드 프로젝트를 시작하기 전에 무조건 package.json부터 만들고 시작해야함. npm init 으로 프로젝트 생성하면 만들어짐. scripts npm 명령어를 저장해두는 부분. 저장된 명령어를 npm run 으로 실행한다. package-lock.json node_modules에 들어있는 패키지들의 정확한 버전과 의존관계가 담겨있음 npm install –save-dev [패키지] ..." }, { "title": "노드 스터디 3장", "url": "/posts/node_ch3/", "categories": "study, node", "tags": "", "date": "2021-04-29 14:07:00 +0900", "snippet": "Node 3장REPL 사용하기 노드 콘솔은 REPL이라하는데 이유는 Read : 입력한 코드를 읽고 Eval : 해석하고 Print : 결과물을 반환하고 Loop : 종료할 때가지 반복함. 터미널에 node를 입력함으로서 접속가능 간단한 명령어 수행JS 파일 실행 helloworld.js 라는 파일을 만들었으면 node helloworld 로 접근할 수 있음모듈로 만들기 노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와는 다르다. ..." }, { "title": "13303 장애물 경기", "url": "/posts/13303/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-27 12:17:00 +0900", "snippet": "13303 장애물 경기알고리즘1. 장애물을 x 좌표 순으로 정렬. 도착지점의 Y좌표와 걸린 길이(y축 이동만 고려)를 저장하는 set을 선언 후, {startY, 0} 를 추가2. 장애물을 하나씩 꺼내며, 그 장애물에 걸리는 원소만 set에서 꺼내고 하나씩 위로갔을때 거리와 아래로 갔을때 거리를 계산 이때, 꺼낸 것이 10개여도 장애물의 위 아래 각각에서 최소거리가 걸리는 것만 set에 다시 저장 -&amp;gt; 즉, 10개 여도 2개만 저장됨.3. 2에서 검사한 원소는 set에서 제거한다.4. 모든 장애물을 상대로 하..." }, { "title": "9095 1,2,3 더하기", "url": "/posts/9095/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "9095 1,2,3 더하기코드#include &amp;lt;iostream&amp;gt;using namespace std;int tc;long long save[12];long long dp(int n);int main() { cin &amp;gt;&amp;gt; tc; while (tc--) { int n; cin &amp;gt;&amp;gt; n; cout &amp;lt;&amp;lt; dp(n) &amp;lt;&amp;lt; endl; }}long long dp(int n) { if (n &amp;lt; 0) r..." }, { "title": "5373 Samsung sw test", "url": "/posts/5373/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "5373 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_ROTATE 1000#define MAX_TESTCASE 100#define WHITE 100#define YELLOW 200#define RED 300#define ORANGE 400#define GREEN 500#define BLUE 600using namespace std;typedef struct Command { int location; //큐..." }, { "title": "3568 iSharp", "url": "/posts/3568/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "3568 iSharp코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;string def, append;char input[130];void print();int main() { cin.getline(input, 130); int i = 0; while (input[i] != &#39; &#39;) { def.push_back(input[i]); i++; } for (; input[i] != &#39;;&#39;; i++..." }, { "title": "2623 MusicPropram", "url": "/posts/2623/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "2623 MusicPropram코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_SINGER 1000#define MAX_PD 100using namespace std;typedef struct Singer { int beforeCount; bool isCheked; vector&amp;lt;int&amp;gt; next;} Sin..." }, { "title": "2473 Three Liquid", "url": "/posts/2473/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "2473 Three Liquid코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;set&amp;gt;#define MAX_LIQUID 5000using namespace std;int liquid[MAX_LIQUID];int numOfLiquid;int threeLiquid[3];void getZerost();int abs(int a) { return a &amp;lt; 0 ? (-1) * a : a;}void setThre..." }, { "title": "20058 Samsung sw test", "url": "/posts/20058/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "20058 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 64#define MAX_COMMAND 1000using namespace std;typedef struct Location { int row; int col;} Location;int map[MAX_WIDTH][MAX_WIDTH];int tempMap[MAX_WIDTH][MAX_WIDTH..." }, { "title": "20057 Samsung sw test", "url": "/posts/20057/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "20057 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_WIDTH 499using namespace std;int map[MAX_WIDTH][MAX_WIDTH];bool visit[MAX_WIDTH][MAX_WIDTH];int width, amountOfSand = 0;int ten, seven, five, two, one, rest;int getLostAmountSand();void setNum(int row, int col) { ten = (float)map..." }, { "title": "20056 Samsung sw test", "url": "/posts/20056/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "20056 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#define MAX_WIDTH 50using namespace std;typedef struct Fire { int mass; int direction; //0이 위, 시계방향으로 0~7 int speed;} Fire;typedef struct Cell { vector&amp;lt;Fire&amp;gt; fire;}..." }, { "title": "19238 Samsung sw test", "url": "/posts/19238/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "19238 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#define MAX_WIDTH 20#define MAX_CUSTOMER 400#define CUSTOMER 123using namespace std;typedef struct Taxi { int row; int col; int fuel;} Taxi;typedef..." }, { "title": "19236 Samsung sw test", "url": "/posts/19236/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "19236 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define WIDTH 4#define SHARK 100#define BLANK -1using namespace std;typedef struct Fish { int num; int row; int col; int direction; // 위부터 반시계방향으로 1~8 bool isAlive;} Fish;int map[WIDTH][WIDTH];Fish fish[WIDTH*..." }, { "title": "1799 bishop", "url": "/posts/1799/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "1799 bishop코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_N 10using namespace std;int map[MAX_N][MAX_N];bool tempMap[MAX_N][MAX_N] = { 0, };int width, maxCount = 0;void findMaxBishop(int diagonal, int count);bool check(int row, int col);int main() { cin &amp;gt;&am..." }, { "title": "17825 Samsung sw test", "url": "/posts/17825/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "17825 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef struct Map { int score; int next; int blueNext;} Map;int dice[10];Map map[33] = { {0, 1, -1},{2, 2, -1}, {4, 3, -1}, {6,4 , -1}, {8, 5, -1}, {10, 6, 21}, {12, 7, -1}, {14, 8, -1},..." }, { "title": "17822 Samsung sw test", "url": "/posts/17822/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "17822 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#define MAX_BOARD 50#define MAX_TURN 50using namespace std;int board[MAX_BOARD][MAX_BOARD];int numOfTurn, numOfBoard, numOfNum;int turn[MAX_TURN][3]; //xi, 0 or 1, kiint getSumOf..." }, { "title": "17779 Samsung sw test", "url": "/posts/17779/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "17779 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_WIDTH 21using namespace std;int map[MAX_WIDTH][MAX_WIDTH];int width;int minDifference();int getMin(int d1, int d2, int x, int y);int main() { cin &amp;gt;&amp;gt; width; for (int i = 0; i &amp;lt; width; i++) for (int j = 0; j &..." }, { "title": "1748 수 이어쓰기 1", "url": "/posts/1748/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "1748 수 이어쓰기 1코드#include &amp;lt;iostream&amp;gt;using namespace std;int N;int main() { cin &amp;gt;&amp;gt; N; long long result = 0; int d = 1, count = 0; while (N / d != 0) { // 1~9 : 1 / 10~99 : 2 / 100~999 : 3 d *= 10; count++; } while (count != 0) { d /= 10; result += count * (N - d + 1)..." }, { "title": "17142 Samsung sw test", "url": "/posts/17142/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "17142 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;algorithm&amp;gt;#define MAX_WIDTH 50#define WALL 1using namespace std;int map[MAX_WIDTH][MAX_WIDTH];typedef struct Virus { int row;..." }, { "title": "17140 Samsung sw test", "url": "/posts/17140/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "17140 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;vector&amp;gt;#define MAX_NUM 101using namespace std;typedef struct Cell { int value; int count; bool operator &amp;lt; (Cell c) { if (count &amp;lt; c.count..." }, { "title": "1629 곱셈", "url": "/posts/1629/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "1629 곱셈코드#include &amp;lt;iostream&amp;gt;using namespace std;long long A, B, C;long long result = 1;int main() { cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B &amp;gt;&amp;gt; C; while (B != 0) { if (B % 2 == 1) { result = (result * A) % C; } A = (A * A) % C; B /= 2; } cout &amp;lt;&amp;lt; r..." }, { "title": "16236 Samsung sw test", "url": "/posts/16236/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "16236 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#define MAX_WIDTH 20using namespace std;typedef struct Location { int row; int col; int distance; bool operator &amp;lt; (Location t) { if (distance &amp;lt; t.distance) return true; else if (t.distance &amp;..." }, { "title": "16235 Samsung sw test", "url": "/posts/16235/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "16235 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#define MAX_WIDTH 10using namespace std;typedef struct Tree { int age; bool isAlive; bool operator &amp;lt; (Tree t) { return age &amp;lt; t.age; }} Tree;typedef struct Cell {..." }, { "title": "16234 Samsung sw test", "url": "/posts/16234/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "16234 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 50using namespace std;typedef struct Location { int row; int col;} Location;int map[MAX_WIDTH][MAX_WIDTH];int tempMap[MAX_WIDTH][MAX_WIDTH];int width, lowerBound,..." }, { "title": "15686 Samsung sw test", "url": "/posts/15686/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "15686 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_WIDTH 50#define MAX_CHIKEN 13using namespace std;typedef struct Location { int row; int col;} Location;int width, maxChiken, numOfHouse, numOfChiken;Location house[2 * MAX_WIDTH];Location chiken[MAX_CHIKEN];int minDistance = 1000..." }, { "title": "15685 Samsung sw test", "url": "/posts/15685/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "15685 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#define MAP 101#define MAX_DRAGON 20#define MAX_GENERATION 10using namespace std;typedef struct Location { int row; int col;}Location;bool map[MAP][MAP];int dragon[MAX_DRAGON][4];int numOfdragon;void dragonCurb..." }, { "title": "15684 Samsung sw test", "url": "/posts/15684/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "15684 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_VERTICAL 10#define MAX_HORIZONTAL 30#define MAX_LINE 270using namespace std;typedef struct Ladder { bool left; bool right;} Ladder;typedef struct Location { int row; int col;} Location;Ladder ladder[MAX_HORIZONTAL][MAX_VERTICAL];..." }, { "title": "15683 Samsung sw test", "url": "/posts/15683/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "15683 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 8#define WALL 6#define BLINDSPOT 0using namespace std;typedef struct CCTV { int row; int col; int direction; // 1 : 북, 2 : 동, 3 : 남, 4 : 서 int num;} CCTV;int height, width;int map[MAX_WIDTH][..." }, { "title": "15486 퇴사2", "url": "/posts/15486/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "15486 퇴사2코드#include &amp;lt;iostream&amp;gt;using namespace std;int N, T[1500000], P[1500000], DP[1500000];int dp(int deep);int max(int a, int b) { return a &amp;gt; b ? a : b;}int main() { ios::sync_with_stdio(0); cin.tie(0); cin &amp;gt;&amp;gt; N; for (int i = 0; i &amp;lt; N; i++) { cin &amp..." }, { "title": "14891 Samsung sw test", "url": "/posts/14891/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14891 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#define MAX_ROTATE 100#define LEFT 6#define RIGHT 2using namespace std;int command[MAX_ROTATE][2];int gear[4][8];int numOfRotate;int implementCommand();void implementSingleCommand(int gearN, int way);void rotat..." }, { "title": "14890 Samsung sw test", "url": "/posts/14890/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14890 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_N 100using namespace std;int map[MAX_N][MAX_N];int width;int need;int checkEveryArr();bool checkSingleArr(int arr[MAX_N]);int main() { cin &amp;gt;&amp;gt; width &amp;gt;&amp;gt; need; for (int i =..." }, { "title": "14889 Samsung sw test", "url": "/posts/14889/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14889 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 20using namespace std;int numOfPeople;int map[MAX_WIDTH][MAX_WIDTH];int minDifferenceBetweenTwoTeam(int arr[10], int len, int deep);int getSum(int arr[10]);int min(int a, int b);int main() { ..." }, { "title": "14888 Samsung sw test", "url": "/posts/14888/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14888 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_NUM 11using namespace std;int num[MAX_NUM];int numOfNum;int operators[4]; // + - * /int operatorPerm[MAX_NUM - 1]; // 1 : +, 2 : -, 3 : *, 4 : /int min = 1000000001;int max = -1000000001;void getMinAndMax(int operatorPerm[MAX_NUM..." }, { "title": "14863 서울에서 경산까지", "url": "/posts/14863/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14863 서울에서 경산까지알고리즘 (dp)1. dp를 평범하게 진행. dp배열은 dp[101][100001] 로 앞에는 현재 위치, 뒤에는 시간2. 시간이 맞으면 진행하되, 안맞으면 result 를 초기화해둔 -20000000이 그대로 있음.3. 0보다 낮으면, 현재 시간포함 0초까지 -20000000로 초기화. 같은 상태에 더 낮은 시간을 가지고 접근하는 걸 막음.다른 방법 (dp)1. dp[100005] 로 시간만으로 dp를 만듬.2. 첫번째 노드의 시간과 값으로 dp 초기화3. dp 배열을 t=k 부터 검사하여 값이 있..." }, { "title": "14503 Samsung sw test", "url": "/posts/14503/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14503 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_WIDTH 50using namespace std;int direction;int location[2];int map[MAX_WIDTH][MAX_WIDTH];int height, width;int robot();bool changeDirection();int main() { cin &amp;gt;&amp;gt; height &amp;gt;&amp;gt; width; cin &amp;gt;&amp;gt; lo..." }, { "title": "14502 Samsung sw test", "url": "/posts/14502/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14502 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 8using namespace std;typedef struct Cell { int row; int col;} Cell;int map[MAX_WIDTH][MAX_WIDTH];int tempMap[MAX_WIDTH][MAX_WIDTH];int width, height;int getMaxSaf..." }, { "title": "14501 Samsung sw test", "url": "/posts/14501/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "14501 Samsung sw test코드#include &amp;lt;iostream&amp;gt;#define MAX_DAY 15using namespace std;int day;int time[MAX_DAY];int proceeds[MAX_DAY];int DP(int d, int proceed);int max(int a, int b);int main() { cin &amp;gt;&amp;gt; day; for (int i = 0; i &amp;lt; day; i++) cin &amp;gt;&amp;gt; time[i] ..." }, { "title": "13460 Gold 2", "url": "/posts/13460/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "13460 Gold 2코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 10#define MAX_DEEP 10using namespace std;char map[MAX_WIDTH][MAX_WIDTH];int width;int height;int R[2];int B[2];int Hole[2];int minDeep;void getProperties();void findM..." }, { "title": "12865 평범한 배낭", "url": "/posts/12865/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:38:44 +0900", "snippet": "12865 평범한 배낭코드#include &amp;lt;iostream&amp;gt;using namespace std;int numOfObject, weight, DP[101][100001];int main() { cin &amp;gt;&amp;gt; numOfObject &amp;gt;&amp;gt; weight; for (int i = 1; i &amp;lt;= numOfObject; i++) { int w, v; cin &amp;gt;&amp;gt; w &amp;gt;&amp;gt; v; for (int j = 1..." }, { "title": "9527 1의 개수세기", "url": "/posts/9527/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "9527 1의 개수세기알고리즘(수학)1. 2^n 마다 규칙이 있음2. f(n)을 2^n ~ 2^(n+1)-1 에서의 1의 개수라고 한다면, f(n) = 2^n + f(i) ( 0 &amp;lt;= i &amp;lt;= n-1 ) 이 성립한다.3. 그리고 들어오는 수 A,B에 대해 (1~B 까지의 1의 개수) - (1~A-1 까지의 1의 개수) 를 하면 값이 나온다.4. 2에서의 규칙에따라 end가 주어지면 0에서 end까지의 1의 개수를 구하는 함수를 선언한다. -&amp;gt; 이때 end 미만의 최대 2^n의 n를 구한다...." }, { "title": "9466 Term project", "url": "/posts/9466/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "9466 Term project알고리즘 (DFS, 그래프)1. 각 학생들이 가리키는 학생을 저장한 student 배열, cycle에 몇명이 있는지 체크하는 cycleCcount 변수, 사이클이 형성됐는지 확인하는 cycleCheck bool형 배열. 검사중인 학생들을 저장하는 q배열2. 첫번째 학생부터 검사 -student가 -1 이면 검사안함. (이미 검사된 것) -검사가 시작되면, q에 넣고, cycleCheck 배열에 표시하고, start엔 자기, end엔 다음걸 가리키며, 그래프따라 dfs 시작 -그래프 따라가면서 ..." }, { "title": "9328 key", "url": "/posts/9328/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "9328 key알고리즘(BFS, 구현)1. 방문한 곳을 체크하는 check 이차원 배열, 키를 저장하는 key 배열, 닫힌문을 저장하는 closedDoor 벡터가 필요2. 먼저 키 배열은 26개의 원소로 이루어진 bool 자료형 배열로 선언. 각 알파벳에 해당하는 키가 들어오면 1을 저장한다.3. 방문가능한지 체크하는 checkCell 함수 선언 -&amp;gt; 빈공간이면 true반환, 문서면 빈공간으로 전환 후 document 1증가하고 true반환 소문자면 열쇠 추가하고, 빈공간으로 전환 후 truw반환 대문자..." }, { "title": "9252 LCS2", "url": "/posts/9252/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "9252 LCS2알고리즘(최장 공통 부분 수열)1. LCS 알고리즘 사용하면 됨구현법1. 문자열 입력 받을 땐. cin.getline(char *c, size) 넣으면 된다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_LENGTH 1000using namespace std;char a[MAX_LENGTH], b[MAX_LENGTH], lcs[MAX_LENGTH];int map[MAX_LENGTH + 1][MAX_LENGTH + 1]..." }, { "title": "7579 app", "url": "/posts/7579/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "7579 app알고리즘(배낭정리, DP)1. 배낭정리 응용. 최대 비용을 가방에 담을 수 있는 최대 무게로 보고, 메모리를 가치로 본다2. 이렇게 2차원 배열을 완성하고, 필요한 메모리 이상이며 비용이 최소인 칸을 판별하고 출력하면 된다.구현법1. 최대 앱 개수는 100개이므로, 101행, 앱 당 최대 비용은 100 이므로 10001열을 선언하여 구현하면 됨.2. 2차원 배열 완성하고나서는 첫번째 원소부터 검사하여, 메모리가 필요이상으로 있는데, 비용이 최소인 것을 찾으면 됨.코드#include &amp;lt;iostream&..." }, { "title": "7453 four Integer&#39;s sum should be zero", "url": "/posts/7453/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "7453 four Integer’s sum should be zero알고리즘(정렬, 이분탐색)1. 앞 두개 정수의 합 배열, 뒤 두개 정수의 합 배열을 만듬.(배열 개수^2 가 합 배열의 길이)2. 두 배열을 정렬3. 앞 합 배열의 원소를 하나씩 빼며 검사 -&amp;gt; 뒤 합 배열에서, upper_bound - lower_bound 값이, 현재 원소에서의 count 값.4. count 를 더하고 다음 원소 검사5. count 값을 long long 으로 선언구현1. lower_bound, upper_bound 로 몇개있는..." }, { "title": "6087 레이저통신", "url": "/posts/6087/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "6087 레이저통신알고리즘(BFS)1. visit 배열을 int로 선언. 이제까지 온 것들의 거울 개수를 저장2. 갈 수 잇고, visit에 저장된 거울 개수와 같거나 작으면 이동 시킴주의점같은 레이저에 도달하지 않기위해 설정한 row != start.row &amp;amp;&amp;amp; col != start.col 은 작동하지 않음-&amp;gt; 같은 줄에만 있어도 애들이 안가기 때문-&amp;gt; 따라서 다음처럼 조건문을 짜야함. row != start.row || col != start.col코드#include ..." }, { "title": "6064 카잉달력", "url": "/posts/6064/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "6064 카잉달력알고리즘(수학)1. n 을 M과 N으로 나누었을때 나온 수가 x와 y 이면 된다. 단, 나누었을때 나오는 수는 0~M-1 or N-1인데 문제에선 1~M, 1~N 까지이므로 이걸 고려해야한다.2. 하나씩 증가시켜가면서하면 너무 오래걸리니, M과 N 중 더 큰수를 더하는 수로 삼고, 그것과 연결된 수부터 시작한다(M-x, N-y) ex) 10 12 3 4 이면 4부터 시작하여 12씩 더함 각 단계의 수를 10과 12로 나누어서 3과 4가 나오면 가능한 것.3. 이때 M과 N이 같을 경우 x, y이 다르게 나오면..." }, { "title": "5014 스타트링크", "url": "/posts/5014/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "5014 스타트링크알고리즘 (BFS)- 직선으로의 BFS 를 사용하면 됨- DP를 사용하면 시간초과가 발생함. - 도달시 다 종료한다고 해도, 그게 최소로 간건지 몰라서 결국 더 검사해야함.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;using namespace std;list&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; q;int F, G, S, U, D;bool check[1000001];int main() { cin &..." }, { "title": "4991 로봇청소기", "url": "/posts/4991/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "4991 로봇청소기알고리즘(BFS, 브루트포스)1. 구현이 더 중요한 문제.2. 그냥 시작 + 각 더러운 곳(DT) 에서 다른 DT로의 최소 거리를 저장한 2차원 배열을 BFS로 만들고3. 시작부터 모든 경로를 탐색하여 최소 거리를 뽑아내면 됨.4. 방문 할 수 없는지 판별은 시작에서 갈 수 없는 DT가 있는지 확인하면 됨구현1. 거리 저장한 2차원 배열은, 최대 DT가 10개이므로 [11][11] 로 선언함 이때, 0은 시작장소를 뜻함 따라서 각 줄의 0번째 칸과 자기자신은 0이어야함2. 시작하는 곳과 DT의 위치를 배열에..." }, { "title": "4811 알약", "url": "/posts/4811/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "4811 알약알고리즘 (dp)1. 하나의 완전한 알약을 one, 반쪽 알약을 half 라고 하면, dp[1001][1001] 를 선언하고, one, half를 기준으로 dp를 저장함2. dp를 진행하면서 밑으로 내려가면서 one이 1개 이상이면 1 줄이고 half 1 증가하고 밑으로 내려갈 수 있고, half가 1개 이상이면 마찬가지로.코드#include &amp;lt;iostream&amp;gt;using namespace std;long long dp[1001][1001];long long DP(int one, int ha..." }, { "title": "4386 make constellation", "url": "/posts/4386/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "4386 make constellation알고리즘(MST)1. 모든 별들 사이의 거리를 구한 다음에, 두 별의 위치, 거리를 저장한 구조체 배열을 거리순으로 오름차순 정렬2. 구조체 배열에서 하나씩 빼가며 크루스칼 시행 -&amp;gt; edge == numOfStar -1 이면 중지 후 출력코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;cstdio&amp;gt;#inclu..." }, { "title": "3197 백조의 호수", "url": "/posts/3197/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "3197 백조의 호수알고리즘(구현)처음 방법 1. 한 백조에서 BFS 실시하여 다른 백조를 만날 수 있는지 검사 2. 전체 맵을 검사해서 녹일 수 있는 걸 녹임 3. day 추가하고 다시 1부터 -&amp;gt; 시간이 너무 걸림. 특히 맵 초기화하는 부분이 많이 걸림두번째 방법 1. 1번은 유지 2. 녹을 수 있는 얼음만 저장한 q에서 얼음을 하나씩 꺼내서 녹이고, 주변에 검사되지않은 얼음이 있으면 따로 저장 -&amp;gt; q가 끝나면 따로 저장한 얼음을 q에 복사 3. day추가하고 다시 1부터 -&amp;gt; 또 ..." }, { "title": "3190 Samsung sw test", "url": "/posts/3190/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "3190 Samsung sw test알고리즘1. 그냥 대가리 옮기고 꼬리 잡히는지, 칸 밖인지 확인하고, 또 사과있는지 확인하고, 또 시간이 바꿀때가 됐는지 확인2. 뱀 몸은 vector로 저장 / 사과 위치는 2차원 bool 배열로 저장하여 메모리랑 참조시간 아낌. / 시간은 Direction 구조체에 저장하고, directionIndex를 선언하여 directionIndex에 있는 시간에 맞으면 방향 바꾸고 index++.3. 구현문제이므로 내가 생각하는 게임이랑 실제 문제 조건은 다를 수 있다. 따라서 예시를 통해 확인..." }, { "title": "2933 미네랄", "url": "/posts/2933/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2933 미네랄알고리즘(구현, 시뮬레이션)1. 들어온 위치의 미네랄을 지움2. 지운 위치에서 상하좌우에 인접한 칸들을 root로 BFS 시행 -&amp;gt; 바닥에 닿는 칸이 있으면 공중에 뜬 클러스터가 아님3. 공중에 뜬 클러스터이면 BFS 시 넣은 칸들을 열순, 열이 같으면 행이 큰 순으로 정렬4. 각 열별로 가장 밑에 있는 칸만 검사하여 밑 클러스트 또는 바닥과 떨어진 최소 거리를 구함5. 정렬한 순으로 최소거리만큼 밑으로 내림6. 끝날때까지 1~5 반복코드#include &amp;lt;iostream&amp;gt;#i..." }, { "title": "2931 가스관", "url": "/posts/2931/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2931 가스관알고리즘(구현)1. M에서 시작해 갈 수 있는 방향으로 가다가 빈칸을 마주하면 스탑. 만약 빈칸이 없으면 아예 처음부터 연결이 안된 것. 이때는 Z 부터 시작해 빈칸을 찾는다.2. 빈칸을 찾으면 빈칸 주변을 검색. 인접한 칸에 바로 연결되는 파이프가 있으면 그 칸을 true로 표시. 표시된 것에 따라 빈칸에 넣을 수 있는 가스관을 배정. ex) 빈칸 | 이면 연결이 안되므로, 오른쪽칸은 false 빈칸 - 이면 연결이 되므로 오른쪽 칸은 true코드#include &amp;lt;bits/stdc++.h&amp..." }, { "title": "2887 planet tunnel", "url": "/posts/2887/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2887 planet tunnel알고리즘(정렬, MST)1. 모든 행성들의 x좌표, y좌표, z좌표를 꺼내 따로 저장하고, 오름차순으로 정렬2. 정렬한 것에서 인접한 것끼리 비용을 계산, (인접한 점 두개 + 비용)을 구조체로 n-1개의 원소를 가지는 배열 3개를 선언하고 집어넣음3. 그 구조체배열 3개는 비용을 기준으로 오름차순으로 정렬4. 구조체 배열 3개를 가리키는 3개의 인덱스 변수 xi, yi, zi를 선언5. xi, yi, zi 중 최소 비용을 unionFind 알고리즘으로 사이클이 형성되는지 확인하면서 집어넣음. ..." }, { "title": "2568 전기줄", "url": "/posts/2568/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2568 전기줄알고리즘(LIS)1. LIS를 구하면 그것들이 겹치지 않고 최대로 연결가능한 전깃줄들이다.2. 따라서 LIS를 구하고 전체 전깃줄에서 LIS를 빼면 빼야하는 전깃줄의 수와 전깃줄의 종류가 나오게 된다.코드#include &amp;lt;bits/stdc++.h&amp;gt;#define MAX_WIRE 100001using namespace std;struct Wire { int a; int b; bool check; bool operator &amp;lt;(Wire s) { return a &amp;lt; s...." }, { "title": "2529 부등호", "url": "/posts/2529/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2529 부등호알고리즘(브루트포스, 백트래킹)1. 모든 경우를 탐색하되, 앞에서부터 하나씩 채워가면서 재귀형태로 하면 백트래킹도 적용하기 쉽다.2. 조건에 맞는 경우만 탐색하면 됨.3. 낮은 거 먼저 탐색하도록하면 굳이 뭘 저장할 필요없이 맨처음것만 minimum에 저장하고, 제일 나중 것을 maxnimum에 저장하면 된다.코드#include &amp;lt;iostream&amp;gt;using namespace std;int N, arr[10];char str[9], mini[10], maxi[10];bool check[10..." }, { "title": "2342 Dance Dance Revolution", "url": "/posts/2342/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2342 Dance Dance Revolution알고리즘(DP)1. 왼발 위치, 오른발 위치, 명령 번호를 기준으로 dp 자료를 만듬 dp[5][5][MAX_COMMAND]2. 명령과 같은 칸에 있을 경우 그대로, 다른 위치에 있을 경우 가능한 위치엔 전부 옮기는 식으로 DP 시행.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_COMMAND 1000000using namespace std;int command[MAX_COMMAND];..." }, { "title": "2252 줄세우기", "url": "/posts/2252/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2252 줄세우기알고리즘(위상정렬)1. 그냥 위상정렬하면된다.구현1. Student 구조체 : beforeCount : 이전에 몇개있는지 셈, next : 큰 학생들 나열, isChecked : 라인에 넣어졌는지 확인2. 처음에 beforeCount가 0인 학생들을 큐에 넣고, isCheked에 체크함3. 하나씩 큐에서 빼면서 아래 시행 -라인에 넣고 -next에 있는 학생들의 beforeCount를 1개씩 줄임 -이때, 그 학생의 beforeCount가 0이 되면, 임시 큐에 넣고 isChecked에 TRUE 표시4. 큐에서..." }, { "title": "2239 sudoku", "url": "/posts/2239/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2239 sudoku알고리즘(백트래킹)1. 칸을 하나씩 탐방하면서, 0으로 기록돼있다면 수직, 수평, 3x3사각형을 검사하여 가능한 숫자를 하나씩 뽑아서 넣고 다음 칸 검사2. 만약 0으로 기록되지않은 칸으로 갔다면 다음칸으로 넘겨주되, 마지막 칸일 경우 스도쿠가 완성된 것이므로 true를 반환한다.3. 마찬가지로, 넣고 다음 칸으로 이동하는데, 마지막칸일 경우 스도쿠가 완성된 것이므로 true를 반환한다.4. 최소일때를 반환하는 것이므로 먼저 검사하는 칸을 왼쪽 위로하고, 1부터 검사하여 가능한 걸 넣으면 된다.구현1. 내가..." }, { "title": "2186 문자판", "url": "/posts/2186/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2186 문자판알고리즘(DFS, DP)1. 문자판을 주어진 조건대로 순회하되, 결과값이 int 안이라는 걸보고 엄청 클 수도 잇다는 걸 예측 or 빙글빙글 계속 돌 수 있으니 DP가 잇어야겠다고 예측2. DP를 DP[r][c][d] 로 구현하되, -1로 초기화를 시키고, 0인것도 기록 -&amp;gt; 문자열이 아예 없을 수도 잇으니 0도 기록하여 더 빨리 DP가 가능해짐.코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int N, M, K, length, DP[101..." }, { "title": "2166 areaOfPolygon", "url": "/posts/2166/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2166 areaOfPolygon알고리즘(기하학)1. 사선정리 사용구현법1. 최대 4000000000000이 나올 수 있으므로, int대신 long long, float은 쓰지말고 double로 통일 시킨다.2. double은 최대 15자리수를 표현가능하므로, 위 값도 충분히 들어갈 수 있다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;cmath&amp;gt;#define MAX_POINT 10000using namespac..." }, { "title": "2151 거울설치", "url": "/posts/2151/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2151 거울설치알고리즘 (BFS)1. 자기 방향으로만 쭉 가다가 ! 를 만나면 자기방향 + 양옆으로 이동. 양옆으로 이동할 땐 거울을 설치하는 것이므로 거울 + 1.2. 이때 visit으로 이미왔던곳을 안가면, 다른 루트로 가는 빛은 중간에 끊기기에, visit에 빛이 그곳에 도착했을 때의 거울의 개수를 저장함. 그리고 다음 빛이 그곳에 도착했을 때, 거울 개수가 적을 때만 이동 아니면 이동시키지 않는다. ex) if( .... &amp;amp;&amp;amp; n + 1 &amp;lt; visit[r][c]) ..." }, { "title": "2143 sumOfTwoArray", "url": "/posts/2143/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2143 sumOfTwoArray알고리즘(이분탐색, 누적합)1. A배열은 그대로 두고, B 배열은 가능한 모든 누적합의 집합을 만들고, 그것을 정렬함 -&amp;gt; 이때 그냥 배열에 집어넣으면 최대 500500개의 원소가 있어서 메모리에서 박살나고, 찾는데 시간도 박살남 -&amp;gt; 난 set을 택했음 -&amp;gt; Pair 구조체를 선언해서, 누적합과 그 누적합이 나온 횟수를 저장함. 그리고 정렬과 비교연산자를 오버로딩하여 set에서 활용할 수 있게함 -&amp;gt; B의 누적합을 하나씩 만들어가며, s..." }, { "title": "2098 TSP", "url": "/posts/2098/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2098 TSP알고리즘(외판원 순회, DP, 비트마스크)1. 비트마스크로 각 비트마다 하나의 도시라고 치고, 검사를 함.2. 방문하지 않았고, 갈수 있는 도시를 방문하는 식으로 끝까지감. -&amp;gt; 끝까지 갔을 때 다시 돌아갈 수 있는 길이 있으면 그 값 반환, 없으면 IMPOSSIBLE 반환 -&amp;gt; 그 전 재귀로 돌아와서 가장 최솟값을 dp[current][bitMask] 에 저장함.3. 각 재귀 처음엔 돌아갈 수 마지막인지 확인하고, 이미 방문됐는지 확인한다.새겨둘 점.1. 모든 출발점에 대해 실행할 필요..." }, { "title": "2056 task", "url": "/posts/2056/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "2056 task알고리즘(위상정렬)1. Task 구조체를 선언하여, time : 현재 task가 걸리는 시간을 저장 / timeTaken : 현재까지 오는데 선행으로 필요한 작업을 수행하면서 걸리는 시간 중 가장 긴 시간 저장 next : 다음으로 이어지는 작업들을 저장2. Task 구조체 배열을 앞에서부터 검사 -&amp;gt; 현재 task의 time과 timeTaken을 더해 temp에 저장. -&amp;gt; 이어지는 작업들을 하나씩 검사 -&amp;gt; 이어지는 작업의 timeTaken보다 현재의 temp가 더 ..." }, { "title": "20055 Samsung sw test", "url": "/posts/20055/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "20055 Samsung sw test알고리즘 (구현)1. durability와 isThereRobot 변수로 구성된 Cell 구조체로 컨베이어 벨트를 만듦2. 무한 루프 안에서, 이동시키고 -&amp;gt; 내리는 위치 로봇빼고 -&amp;gt; 로봇이동 시키고(이동시 내구도 1감소) -&amp;gt; 내리는 위치 로봇빼고 -&amp;gt; 올리는 위치 로봇 올리고(내구도 1감소) -&amp;gt; 내구도 0인 칸이 한계점에 닿으면 종료기타1. 매번 내구도 0인 칸이 몇개인지 세기보단, 내구도를 깎는 칸에 깎고나서 내구도 0..." }, { "title": "1987 Alphabet", "url": "/posts/1987/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1987 Alphabet알고리즘(백트래킹)1. 어떤 알파벳을 검사했는지 기록하는 건 check[26] 배열을 선언하고, 각 알파벳에서 65 값을 빼서 각 자리로 접근한다.(&#39;A&#39; - 65 == 0)2. 인접한 칸을 검사하고, 가능하면 check 표시하고 인접한 칸으로 이동. 안되면 돌아와서(Back Tracking) 다른 인접한 칸 검사3. 갈 수 있는 인접한 칸이 없으면 그 칸이 마지막 칸이므로 maxCount 보다 크면 기록 -&amp;gt; 종료4. 만약 deep이 27에 다다르면, 알파벳 26개를 전부 검..." }, { "title": "1956 운동", "url": "/posts/1956/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1956 운동알고리즘(플로이드 워셜)1. 문제 파악 : 그래프 상의 어떤 점들 집합이건 최소로 사이클을 이루는 집합이면 됨2. 그래프 관련 알고리즘 1. 다익스트라 : 출발점에서 모든 정점까지의 거리 -&amp;gt; 해당 x 2. 밸만포드 : 다익스트라와 마찬가지 3. MST : 최소신장트리 -&amp;gt; 사이클은 감지할 수 있으나, 그것이 최소 사이클인지 모름 and 사이클만을 추출해내기 어려움 4. 플로이드 워셜 : 모든 정점 사이의 거리 -&amp;gt; 자기 자신은 원래 0으로 표시하지만, 이 문제에선 INF로 ..." }, { "title": "19235 모노미노도미노", "url": "/posts/19235/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "19235 모노미노도미노알고리즘(구현)1. 파란 맵과 초록 맵을 따로 만듬.(bool 형으로 해서 true면 블록이 있고, false면 없는 거로 취급)2. 매 실행마다 블록을 잘 놓고 -&amp;gt; 업데이트 하면서 점수 얻고 -&amp;gt; 연한부분 있으면 당긴 다음에 -&amp;gt; 다음 실행3. 실행마다 얻은 점수를 잘 기록해서 리턴함. 그리고 남은 블록 수를 세서 출력.4. 단, 모노미노도미노 1인 경우 - bool형이 아닌 int형으로 하고 0이면 블록 없음, 1 이상이면 각 블록을 나타내서, 옮길 때 어떤 블..." }, { "title": "1865 웜홀", "url": "/posts/1865/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1865 웜홀코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int tc, N, M, W, road[501][501];long long d[501];bool check[501][501];vector&amp;lt;int&amp;gt; connect[501];bool belmanford();int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; tc; while (tc--) { ..." }, { "title": "1806 partial sum", "url": "/posts/1806/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1806 partial sum알고리즘 (브루트포스)1. 길이를 1부터 N까지 검사2. 한 길이를 검사할 때 다음을 실행 1. 수열의 처음부터 길이만큼 더하고 sum에 저장, 첫번째를 따로 first에 저장. -&amp;gt; S를 넘는지 확인하고 안넘으면 2 실행 2. 수열의 (길이)번째부터 검사. 위에서 구한 sum에서 first를 빼고, 현재의 수열원소를 집어넣음. -&amp;gt; 검사 -&amp;gt; 아니면 first에 두번째 저장3. 다 했는데도 안되면 0 반환-&amp;gt; 통과는 되지만, 아주 느림알고리즘(두 ..." }, { "title": "17837 새로운게임2 Samsung sw test", "url": "/posts/17837/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "17837 새로운게임2 Samsung sw test알고리즘(구현)1. 색깔을 저장한 map, 말을 저장하는 3차원 배열 맵(각 칸마다 4칸만 있으면 됨), 각 칸에 말이 몇개있는지 저장하는 인덱스맵2. 턴을 계속 진행함. 각 말을 순차적으로 검사함. 이때 각 말들을 몇 번 검사했는지 저장하는 temp 배열을 생성. 방향과 색깔에 맞춰 이동 시킴. -두번째면 그냥 넘기고 다음 거 검사 -빨강이면 위에서부터 옆으로 이동시킴 -흰색이면 현재 말부터 옆으로 이동시킴 -파랑이나 맵 밖이면 방향을 바꾸고 현재말을 다시 검..." }, { "title": "1753 최단경로", "url": "/posts/1753/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1753 최단경로알고리즘1. 다익스트라코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;#define INF 2000000000;using namespace std;int V, E, s, length[20001];vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; node[20001];priority_queue&amp;lt;pair&amp;lt;int, int&amp;..." }, { "title": "17404 RGB Distance 2", "url": "/posts/17404/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "17404 RGB Distance 2알고리즘 : DP1. bottom-top 방식으로 품2. DP 구성 : (현재 깊이, 이전에 고른 색깔)칸에 현재 깊이에서의 최솟값 저장.3. DP 작동 a. 첫번째 집은 for문으로 하나씩 들어감. b. 두번째 집부터 이전에 고른 색이 아닌 색으로 이동 c. 마지막집 + 1에 도착하면 0을 리턴 d. 마지막집은 0리턴 받은 것에 고른 색의 값 더함. 총 가능한 모든 색 값 중의 최솟값을 DP[deep][before]에 저장함 e. 하나씩 올라가면서 DP에 저장 f. DP에 저장돼있는게 있으..." }, { "title": "17144 Samsung sw test", "url": "/posts/17144/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "17144 Samsung sw test알고리즘1. 기존 map에서 미세먼지가 있는 부분만, 기존에 있던 미세먼지만 확산시키는 게 관건2. 따라서 tempMap을 만들어서 map을 복사한 다음에, map에 있는 미세먼지 양을 받아서, tempMap에 확산시키고, 다 확산하면 tempMap을 map에 복사하고 순환하여야 한다.3. 자꾸 갱신되는 상황을 잊지 말자코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#define MAX_WIDTH 50using nam..." }, { "title": "16954 움직이는 미로탈출", "url": "/posts/16954/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "16954 움직이는 미로탈출알고리즘(BFS)1. q와 nextq를 선언2. q엔 현재 노드를 저장. 하나식 꺼내서 이동가능한 인접 칸을 nextq에 추가.3. 다 추가하면, 벽을 한칸 내림4. 이후 q에 nextq를 넣고, nextq는 비운채 다음 루프 시작.5. 루프 중에 q에서 꺼낸 노드가 벽이 있는 칸이라면 추가안하고 다음 노드로, 최우측상단이라면 종료코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;char miro[8][8];list&amp;lt;pair&amp..." }, { "title": "16946 벽부수고 이동하기 4", "url": "/posts/16946/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "16946 벽부수고 이동하기 4알고리즘 (BFS)1. 각 맵의 빈공간마다 각자의 크기를 BFS로 구함2. 이때, 각자의 id를 지정하여 같은 집합에 속하면 같은 id를 갖도록 하자3. BFS가 끝나면 각 벽을 검사 -&amp;gt; 주변에 인접한 모든 빈공간의 아까 구한 크기를 모두 더하고 자기자신 + 1해서 리턴 -&amp;gt; 이때, 주변에 인접한 빈공간들의 id 중 겹치는 것이 있는지 확인하면서 넣자. id가 같은 것이 이미 들어가있으면 그것은 더하지 않는다.주의점1. memset으로 visit을 매 BFS마다 초기화시..." }, { "title": "16724 피리부는 사나이", "url": "/posts/16724/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "16724 피리부는 사나이알고리즘 (DFS)1. 맵에 있는 서로 이어져있는 그래프의 개수를 세면 됨.2. visit을 만들어, 이미 검사한 그래프의 원소엔 true를 표시한다. 그리고 tempVisit을 만들어, 현재 검사하고 있는 그래프의 원소에 true를 표시한다.3. 먼저, 첫번째 셀부터 검사하지 않았으면 DFS를 실시한다. -&amp;gt; 갈수있는데까지 가면서 tempVisit에 true를 표시 -&amp;gt; tempVsit이든 visit 배열이든 true로 표시돼있는 칸에 오면 중지 -&amp;gt; 이때 상태..." }, { "title": "16566 카드게임", "url": "/posts/16566/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "16566 카드게임알고리즘(이분탐색, 정렬, 분리집합, 세그먼트트리?)1. 고른 카드를 버킷정렬함(400만개이므로 버킷정렬이 훨씬 빠르다. sort는 NlogN)2. 범위를 저장하는 set&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;을 선언하고 첫 범위를 넣음(0-m)3. 철수가 뽑은 카드의 수가 저장된 범위의 끝의 수보다 작을 때의 범위를 찾고, 그 범위안에서 uppper_bound로 큰수를 찾고, 그 찾은 공간을 제외한 양쪽의 두 범위를 다시 범위set에 추가하고, 현재 범위는 삭제한다. e..." }, { "title": "16562 친구비", "url": "/posts/16562/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "16562 친구비알고리즘 (union find)1. unionfind 를 구현하되, 루트에 친구비가 적은 것이 오도록함2. 루트만 골라 친구비를 정산한다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#define MAX_STUDENT 10001using namespace std;int numOfStudent, numOfFriendship,..." }, { "title": "1655 가운데를 말해요", "url": "/posts/1655/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1655 가운데를 말해요내 방식 (multiset)1. 멀티셋으로 가운데를 트래킹해가면서 구함2. 첫번째 원소를 넣고, s.begin()으로 첫번째 iter를 middle로 받고 그대로 출력3. 두번째부턴 middle과 같은 원소가 들어오면, s.insert(s.upperbound(*middle), input) 으로 가장 앞에 넣음 아니면 그냥 s.insert 로 넣음4. 현재 넣는 것이 짝수번째 숫자이고, 넣은 원소가 현재 middle보다 작을 경우 middle-- (작은 원소가 들어왔을 때, middle은 반쪽 바로 앞..." }, { "title": "1647 split town", "url": "/posts/1647/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1647 split town알고리즘(MST)1. MST를 만들고, 가장 거리가 긴 길을 빼면 된다.2. n개의 노드에 대해 n-1개의 간선만 연결되어있으므로, 1개만 빼면 딱 두개로 나눌 수 있는데, 뺀다면 가장 거리가 긴 길이기 때문이다.(2개 이상 빼면 3개이상으로 나눠짐)코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#define MA..." }, { "title": "1644 소수의 연속합", "url": "/posts/1644/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1644 소수의 연속합알고리즘(에라토스테네스의 체, 두 포인터)1. 에라토스테네스의 체로, N이하의 소수를 모두 구함2. 두 포인터로 일치하는 해당하는 연속합을 구함 초기 : start = 0, end = 1, sum = prime[0] while start &amp;lt; end if sum == N count++ sum -= prime[start++] //밑에서 end를 기준으로 끝을 정했으니, start를 조작한다. else if sum &amp;lt; N if end == numOfPrime..." }, { "title": "1562 계단수", "url": "/posts/1562/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1562 계단수알고리즘(DP, 비트마스킹)1. 숫자를 기록하는 num[101] 배열과, DP[101][10][1 &amp;lt;&amp;lt; 10] 배열을 이용하여 DP로 품2. 앞에서부터 길이에 맞게 숫자를 하나하나 기록해감. 기록하면서 비트마스킹으로 0~9가 있는지 표시 -&amp;gt; 이때 이미 표시된 비트에 또 표시하면 기록이 망가짐. 따라서 &amp;amp; 연산자로 검사하고 넣음 ex) int b = bit &amp;amp; (1 &amp;lt;&amp;lt; num[deep]) ? bit : bit + (1 ..." }, { "title": "1516 Developing game", "url": "/posts/1516/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1516 Developing game알고리즘(위상정렬, 그래프. DP)1. 어떤 건물을 짓기 위해 필요한 건물을 짓는 시간의 최대 + 이 건물을 짓는데 걸리는 시간을 출력하면 됨.2. 예를 들어 A -&amp;gt; -&amp;gt; D C B -&amp;gt; -&amp;gt; E 로 그래프가 이루어져 있을 때, A : A를 짓는 시간 B : B를 짓는 시간 C : max(A, B) + C를 짓는데 걸리는 시간 D : C + D를 짓는데 걸리는 시간 E : C + E를 짓는데 걸리는 시간 이기 때문이다. 물론..." }, { "title": "1509 팰린드롬 분할", "url": "/posts/1509/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1509 팰린드롬 분할알고리즘(Manacher’s Algorithm, DP)1. 2차원 bool 형 배열 palindrome에 모든 팰린드롬을 저장. -&amp;gt; palindrome[i][j] 엔 시작이 i이고 끝이 j인 문자열이 팰린드롬인지 아닌지 저장돼있음 -&amp;gt; 구하는 법은 처음부터 i = 0~length, j = i~length; 로 가면서 팰린드롬인지 확인하고, 팰린드롬이면 Manacher’s Algorithm 으로 그 사이 팰린드롬을 전부 표시 아니면 그냥 넘어간다 -&amp;gt; 팰린드롬일경우..." }, { "title": "14939 불끄기", "url": "/posts/14939/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "14939 불끄기알고리즘(브루트, 그리디, 비트마스킹)1. 최소한으로 눌러야하는 경우 : 한 칸은 한번만 눌러야함. 두번 이상누르면 최소가 아니고, 무한 루프가 될 수 잇음2. 모든 방법을 다 검사해봐야 정답을 얻을 수 있음 -&amp;gt; 브루트 포스3. 한번씩만 누르면 누르는 순서는 중요하지않음 -&amp;gt; 첫줄부터 차례대로 누름4. 이때 첫번째줄은 모든 경우로 누른다고 치고, 두번째 줄부터는 위에 전구가 켜진 경우만 눌러도 해결이 가능하다. -&amp;gt; 그리디5. 모든 경우는 0~1023까지 비트마스킹 방식으..." }, { "title": "14938 서강그라운드", "url": "/posts/14938/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "14938 서강그라운드알고리즘(플로이드워셜)1. 접근 방법 - 처음엔 DFS 또는 BFS로 접근 - 근데 해보니 이전에 왔던 것보다 적은 거리를 써서온건 보내고, 보낸 다음부터 이어지는 건 겹치면 빼야함. - 결국 플로이드워셜로 최소거리를 모두 구한 후, 탐색범위 안에 들어오는 지역의 아이템을 모두 더하는 방식과 동일함.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;i..." }, { "title": "14500 Samsung sw test", "url": "/posts/14500/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "14500 Samsung sw test알고리즘1. 가능한 모든 모양으로 검사.코드#include &amp;lt;iostream&amp;gt;#define MAX_WIDTH 501using namespace std;int width, height;int map[MAX_WIDTH][MAX_WIDTH];void getProperties();int putTetromino();int main() { while (true) { getProperties(); cout &amp;lt;&amp;lt; putTetromino(); }}voi..." }, { "title": "14499 Samsung sw test", "url": "/posts/14499/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "14499 Samsung sw test알고리즘1. 각 명령별로 검사. 초기 주사위 상태 (top : 1, north : 2, east : 3, south : 5, western : 4, bottom : 6)2. 명령대로 주사위를 굴리고 -&amp;gt; 그 위치가 맵 밖이면 다음 명령 실행 맵 안이면 이동시키고, 주사위 상태 변경 -&amp;gt; 이후 이동한 칸에 숫자 적용하고 -&amp;gt; 상단 프린트 -&amp;gt; 다음 명령 실행코드#include &amp;lt;iostream&amp;gt;#include ..." }, { "title": "14003 LIS5", "url": "/posts/14003/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "14003 LIS5알고리즘 (LIS)1. LIS 로 구함2. 수열 출력 1. LIS구하면서, 현재 LIS의 인덱스를 항상 저장함 2. LIS를 구하면, 가장 뒤에있는 LIS의 가장 뒤 원소의 인덱스가 저장됨 3. 그 인덱스로부터 길이를 하나씩줄여가며 앞으로 가면서 길이가 맞는걸 뒤에서부터 저장 4. 길이가 0이되면 종료 5. 이렇게하면 가장 뒤에있는 LIS가 저장된다.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#define MAX_LENGTH 10..." }, { "title": "13549 숨바꼭질 3", "url": "/posts/13549/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "13549 숨바꼭질 3알고리즘(BFS)1. BFS로 가능한 곳은 가되, check엔 이전에 온 것보다 적은 시간을 걸리며 온 것을 받아주기 위해 시간을 저장하자.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;list&amp;gt;using namespace std;int N, K, result = 2000000000;int check[200020];list&amp;lt;pair&amp;lt;int,int&amp;gt;&amp..." }, { "title": "13458 Samsung sw test", "url": "/posts/13458/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "13458 Samsung sw test알고리즘1. 오직 1명은 무조건 1명 있어야한다는 말2. 총감독관이 감시할 수 있는 응시자 수만큼 빼고, 감독관 수 1명 늘린다음에, 넣어야하는 부감독관 수를 더함. -&amp;gt; 이를 모든 시험장에 적용3. 이때 총 필요한 감독관을 저장하는 변수는 long long으로 해야함(응시자 수 100만명, 시험장 수 100만개 이므로)코드#include &amp;lt;iostream&amp;gt;#define MAX_CLASS 1000000using namespace std;int testC..." }, { "title": "1339 단어 수학", "url": "/posts/1339/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1339 단어 수학알고리즘(브루트포스, 그리디)- 브루트포스 1. 어떤 알파벳이 나왔는지 기록하고, 거기에 맞춰 알파벳의 종류의 개수만큼 모든 가능한 수를 뽑아 검사한다.- 그리디 1. 들어오는 단어를 알파벳 단위로 분류하고 다음처럼 자릿수를 곱해준다. ABC -&amp;gt; 100A + 10B + C BCA -&amp;gt; 100B + 10C + A 2. 그리고 모든 단어를 더해준다. 101A + 110B + 11C 3. 이를 앞에 자릿수대로 내림차순 정렬하면, 가장 커야할 수가 나오고, 그에따라 수를 부여하고 계산..." }, { "title": "12969 ABC", "url": "/posts/12969/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "12969 ABC알고리즘(dp)1. 현재 깊이 d, 이전에 나왔던 a의 개수, 이전에 나왔던 b의 개수, 이제까지의 k 수를 기준으로 dp를 만들어야함. k도 결과에 영향을 주기 때문.2. 즉, dp[d][a][b][k] 를 선언하고, 이 상태가 검사되면 true로 지정하여 다시 검사하지않음.3. 정답을 찾았을 때는 전역변수 got에 true값을 지정하여 바로 다른 모든걸 종료시키고 출력코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namesp..." }, { "title": "12849 본대산책", "url": "/posts/12849/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "12849 본대산책알고리즘(DP)1. a라는 건물에 x분을 남기고 들어가는 것은, a에 연결된 모든 건물 b에 x+1분을 남기고 들어온 것과 같음2. 즉, 정보과학관에 0분을 남기고 들어오는 것을 시작으로 모든 경우를 탐색하면 된다.3. 쭉쭉 내려가다가 D분에 도달했을때, 장소가 정보과학관이면 1, 아니면 0을 리턴하여 바텀업으로 함4. DP에는 현재 위치와 시간으로 배열을 만들고, 그 위치에서 그 시간이 걸렸을 때의 결과를 1000000007로 나눈 값을 저장함코드#include &amp;lt;iostream&amp;gt;#..." }, { "title": "1248 맞춰봐", "url": "/posts/1248/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1248 맞춰봐알고리즘 (백트래킹)1. 그냥 앞에서부터 가능한 수를 채워나가는 백트래킹 방식을 사용하면 된다.2. 이때, 가능한 수는 ans를 채워간다는 얘기다. 즉, 가능한 경우만을 탐색하여 가서 정답만을 하나하나 채워가는 식으로 모든 경우를 탐색하면 됨.코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int N, ans[10];char S[10][10];bool gotAns;void makeArr(int deep, int beforeSum);bool check(in..." }, { "title": "12100 Samsung sw test", "url": "/posts/12100/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "12100 Samsung sw test알고리즘(DFS 재귀)1. 위, 오른쪽, 아래, 왼쪽으로 차례로 보냄. 보낼때, 보내는 쪽에 가까운 곳부터 하나씩 검사.2. 주의 사항 : 2 4 8 2 8 16 4 2 32 에서 위로 한번 보내면 맨 왼쪽 맨 위는 4가 되야하고 그 밑에 4가 와야함. 하지만 내가 처음 짠 코드에서는 한번 업데이트 된곳을 저장안하고 그때그때 업데이트된 맵에 하나하나씩 적용했기에 맨왼쪽맨위에 8이 왔음 이점에 주의코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;c..." }, { "title": "1202 Jewelry thief", "url": "/posts/1202/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1202 Jewelry thief알고리즘1. 보석을 가치순으로 내림차순으로 정렬2. 가방을 multiset에 저장함3. 가치가 큰 보석부터 차례대로 꺼내면서 적절한 가방을 선택하고, 집어넣음 -적절한 가방 : 무게가 같으면 가장 적절. 같지 않으면 남는 무게가 가장 적은 가방 -찾는 법 1. 같은 게 있는지 확인 2. 없으면, 현재 검사하는 보석의 무게를 넣고 그대로 빼면 넣었던 자리에 있는 옆 가방의 반복자가 반환되는데 이 반복자가 multiset.end()와 같으면 보석 무게가 너무 무거워서 넣을 수 있는 가방이 없..." }, { "title": "1197 MST", "url": "/posts/1197/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1197 MST알고리즘(크루스칼 알고리즘 사용)1. 가장 가중차가 작은 간선부터 검사2. 사이클 검사 1. 간선의 양단이 전부 이미 안들어갔으면 양단을 같은 벡터에 집어넣고, set 벡터에 집어넣음 2. 한쪽만 들어갔다면, 들어가 있는 한쪽의 set벡터에 안들어간 쪽을 집어넣음 3. 두개 다 들어가 있고, 들어간 집합이 같다면, 사이클 형성 -&amp;gt; false 반환 4. 두개 다 들어가 있고, 들어간 집합이 다르다면, 두개를 합침.자료구조간선을 저장하는 Edge 배열노드를 저장하는 Node 배열. - 배열의 인덱스가 ..." }, { "title": "1167 트리의 지름", "url": "/posts/1167/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1167 트리의 지름알고리즘 (dfs, dp)1. 1번 노드를 최상위 노드라고 가정하고 품2. 1번 노드부터 시작하여 트리를 밑으로 탐색함.3. 끝까지 닿으면, 거리를 올리면서(bottom-top) 다시 위로 올라감(재귀로 탐색하면 됨)4. 한 노드에서 재귀로 반환하는 건, 자신의 자식 노드에서 올라오는 것중 가장 큰 값(끝까지 갔을 때의 값들 중 가장 큰 값)5. 또 한 노드에선, 자식 노드에서 올라오는 것 중 가장 큰 값 2개를 저장하여, 탐색이 끝나면, 그 두개의 합이 전역으로 저장되어있는 length값보다 크면 저장.6..." }, { "title": "11657 타임머신", "url": "/posts/11657/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "11657 타임머신알고리즘(밸만포드)1. 밸만포드로 푼다.2. 길이는 long long으로 저장한다.코드#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;struct Road { int to; int time;};struct City { vector&amp;lt;Road&amp;gt; next; long long minTime; int before;};City city[501];list&amp;lt;Road&amp;gt; q;int N, M;bool generateMinTi..." }, { "title": "1149 RGB 거리", "url": "/posts/1149/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1149 RGB 거리알고리즘(dp)1. 그냥 현재 노드에서 이전의 상태가 X였을때의 최솟값을 저장하는 dp 배열 DP[1000][3] 을 선언하고 DP를 해주면 된다.2. 첫번째와 마지막이 상관이없으므로 매번 값을 초기화 시켜줄 필요는 없다.코드#include &amp;lt;iostream&amp;gt;#define INF 2000000000using namespace std;int N, cost[1000][3], DP[1000][3];int getMin(int deep, int bf);int min(int a, int b) ..." }, { "title": "11437 LCA", "url": "/posts/11437/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "11437 LCA알고리즘 (BFS, LCA)1. 트리만들기 1. check 배열을 만들고, 1번 노드만 true 표시함 2. 정점 쌍이 들어왔을 때, 둘중에 check 표시된 것이 A, 안된 것이 B라고 할때, B의 부모엔 A를, 깊이엔 A+1을 넣고, check[B] 에 true 표시함 3. true 표시가 끝나고, B에 인접한 정점들을 BFS로 끝까지 방문하면서 깊이를 부여하고 check 표시함. 4. 만약 둘 다 check에 표시가 안돼있으면, 두 정점의 인접한 정점 벡터에 둘다 추가한다.2. LCA 찾기 1. log2의..." }, { "title": "11401 이항계수 3", "url": "/posts/11401/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "11401 이항계수 3알고리즘(페르마의 소정리, 거듭제곱)1. 페르마의 소정리 적용 nCk = n! / k!(n-k)! % 1000000007 에서 A = n!, B = k!(n-k)!, p = 1000000007 이라고 할 때 위 식은 (A * B^(-1)) % p 를 성립 페르마의 소정리는 p가 소수일때, p와 서로소인 a가 있으면, a^p mod p = a mod p 가 성립. -&amp;gt; a^p-1 mod p = 1 mod p 이므로 a^p-1 mod p = 1 이 성립함을 알려주는 공식 여기서 양변에 a를 한번 ..." }, { "title": "1107 리모컨", "url": "/posts/1107/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1107 리모컨알고리즘(브루트 포스)1. 0~100만까지 하나씩 올라가며, 되는지 검사하고, 가장 적게 누르는 건지 저장2. 되는지 검사할 때는, 고장난 버튼을 bool 배열에 저장하여 바로바로 참조가능하게 하고, 뒤에서부터 하나씩 검사하자헛발질 기록1. 처음엔 들어온 버튼의 자릿수에 맞게, 모든 숫자를 검사하되 재귀로 수를 하나씩 채워하는 식으로 하여 안되는 건 미리 제거하는 식으로 함 -&amp;gt; ex) 2528이면 모든 4자리수를 검사하되, 앞에서부터 안되는건 배제하며 채워감2. 그러나 자릿수를 더 크게 해도 최소가..." }, { "title": "11066 파일합치기", "url": "/posts/11066/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "11066 파일합치기알고리즘(DP)1. 긴 한 줄의 파일들을 두조각으로 분리해서 찾는 방식으로 DP를 함2. 먼저 0, k-1를 넣음3. (0, k-1)의 파일 크기의 합을 구한 후, (0,0)-(1,k-1), (0, 1)-(2,k-1) ... 로 모든 두 조각을 만든 후, 그 조각의 비용을 구함 -&amp;gt; start == end 일 경우 합치지 않으므로 비용은 0 ex) (0,1) 일 경우, 0 + 0 + file[0] + file[1]4. 각 조각의 비용은 dp[start][end]에 저장함.주의점이전 tc의 결과가..." }, { "title": "11054 가장 긴 바이토닉 부분수열", "url": "/posts/11054/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "11054 가장 긴 바이토닉 부분수열알고리즘(LIS)1. 왼쪽에서 오른쪽으로 LIS, 오른쪽에서 왼쪽으로 LIS 후, 모든 점에 대하여 l[i] + r[i] - 1 (길이가 1이면 1일때, 0일경우는 + 1 해줌) 가 최대가 되는 점을 찾고 그점에서의 l[i] + r[i] -1 를 출력하면 됨.2. 길이가 최대1000이므로 dp로 안해도 되는데 해도 무방코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;..." }, { "title": "11049 행렬곱셈순서", "url": "/posts/11049/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "11049 행렬곱셈순서알고리즘(DP)1. 연속된 원소를 크게 이등분하여 계산할 수 있음 ex) (start ~ i, i+1~end)2. dp(start, end)는 start에서 end까지의 범위를 계산할 때 최소비용.3. 현재 비용은, matrixt[start][0]*matrix[i][1]*matrix[end][1] 로 계산할 수 있음.4. start == end 일때 비용은 0코드#include &amp;lt;iostream&amp;gt;#define MAX_MATRIX 501using namespace std;int nu..." }, { "title": "10942 Palindrome", "url": "/posts/10942/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "10942 Palindrome알고리즘(DP)1. 입력으로 받은 것이 팰린드롬인지 확인2. 팰린드롬이면 from-to 사이에 있는 모든 건 다 팰린드롬이다. -&amp;gt; DP에 팰린드롬임을 표시 아니면, from-to에서 팰린드롬이 아님을 판별한 곳까지 팰린드롬이 아니다 -&amp;gt; DP에 팰린드롬이 아님을 표시주의점아무리 잘 짜도ios::sync_with_stdio(false);cin.tie(0);를 써줘야 통과가 됨.코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cs..." }, { "title": "10830 행렬제곱", "url": "/posts/10830/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "10830 행렬제곱알고리즘 (거듭제곱, 행렬곱)1. 그냥 행렬 거듭제곱으로 풀면됨주의점1. 입력의 B를 long long으로 받아야한다2. AB = A 가 나오도록 하는 B행렬은 대각선이 모두 1이고 나머지는 0인 행렬이다코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;long long N, B;long long map[5][5], result[5][5] = { {1,0,0,0,0}, {0,1,0,0,0}, {0,0,1,..." }, { "title": "10775 airport", "url": "/posts/10775/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "10775 airport알고리즘(자료구조, 트리를 이용한 이진탐색)1. 게이트의 개수에 맞게 1~G를 set에 넣음2. bool형 check 배열에서, gi에 아무것도 없으면 gi에 넣고 set에서 gi 삭제3. 이미 gi에 들어가 있으면, set에서 upperbound로 gi초과하는 첫번째를 찾음 -&amp;gt; 만약 그 첫번째가 begin()이면 없는 것 -&amp;gt; false 반환 후 입력 종료 -&amp;gt; begin()이 아니면 그 곳에서 한칸 아래에 도킹하고, true반환주의점1. set의 erase는..." }, { "title": "1043 거짓말", "url": "/posts/1043/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1043 거짓말알고리즘(DFS)1. 처음 진실을 알고있는 사람과 연결돼있는 파티 그룹과, 절대 연결되지 않은 그룹을 나눠야함.2. 나는 단순히 변화가 발생하지 않을 때까지 반복하였음. 그리고 그런 사람이 없는 그룹의 개수만 세서 출력함.다른 풀이1. 내꺼에서 좀더 최적화된 풀이2. 처음에 입력을 받으면서, 각 사람들이 어디 파티와 연결되어있는지 벡터에 저장.3. 처음부터 진실을 알고 있는 사람들이 있는 그룹을 큐에 넣고, 거짓말을 할 수 있는 그룹인지 체크하는 배열에 표시4. 큐에 넣어진 그룹들을 하나씩 빼가며, 그 그룹에 있..." }, { "title": "10217 KCM Travel", "url": "/posts/10217/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "10217 KCM Travel알고리즘(다익스트라, DP)1. 기본적으로 다익스트라를 사용하여 최소경로를 찾아야하는 것을 맞으나, 비용이 넘어버릴경우 이전의 최소경로로 간 것이 의미가 없어진다. 따라서 현재 큐에서 꺼낸 노드가, 이전에 지나간 노드보다 같은 비용일때 더 시간이 많이 걸렸을 경우만 패스. DP[101][10001] 선언2. 첫번째를 제외하고, 모든 노드를 INF 로 초기화3. 다익스트라를 진행하면서, 현재 큐에서 꺼낸 노드의 시간이 DP[현재노드][현재노드의 비용] 보다 클 때 패스 (같은 거는 현재 일 수 ..." }, { "title": "10165 KOI 2014_Elementary", "url": "/posts/10165/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "10165 KOI 2014_Elementary알고리즘1. 각 버스노선의 출발점, 도착점, 번호를 기록한 구조체를 만들고, 출발점을 기준으로 정렬. 출발점이 같으면 도착점이 작은 것이 앞에 위치하도록함.2. 버스노선인덱스를 저장하는 배열을 만들어, 버스노선을 하나씩 검사함. -초기 : 첫번째 버스노선을 넣음3. 검사내용 -출발점이 이전 버스노선과 같은가 -이전 버스노선이 0을 지나치고, 현재 버스노선도 0을 지나치는가 (정렬로 인해 자동으로 현재버스노선이 이전버스노선을 감싸는 형태가 됨.) -현재버스 노선을 넣었을 때 지워..." }, { "title": "1007 vector matching", "url": "/posts/1007/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1007 vector matching알고리즘1. 각 테스트 케이스 별로 모든 x좌표와 y좌표를 더함2. n/2개의 점을 고르고, 그 고른 점들의 모든 x좌표와 y좌표를 더함3. 1에서 구한 x,y 에 2에서 구한 x,y를 2곱하고 뺌. (sumOfEveryX - 2*sumOfChoosedX)4. 3.에서 구한 벡터의 길이를 구한 후 반환. 반환 받은 곳은 최솟값을 다시 반환설명들어오는 점들이 짝수이고, 두개씩 짝 지어준다면 벡터를 구했을 때 반은 더하는 형태이고, 반은 빼는 형태이다.따라서 빼줄 반을 고르고, 전체 X의 합에서..." }, { "title": "1005 ACM Craft", "url": "/posts/1005/", "categories": "알고리즘, beackjoon", "tags": "", "date": "2021-04-26 18:19:26 +0900", "snippet": "1005 ACM Craft알고리즘(위상정렬, DP)1. 1516 게임개발과 비슷한 유형이다2. 위상정렬하여 푼다. 단, 1516과는 다르게 목표건물을 지었다는게 확인되면 while문을 종료하고 출력해도 됨.3. 단, 진짜로 위상정렬한 배열을 만들 필요는 없고, 위상정렬식으로 풀어도 시간은 비슷하다. 오히려 위상정렬을 굳이 안만드는 편이 더 빠를 수있다.4. 더 빠르게 하는 방법은, 목표건물이 속한 그래프만을 검사하는 것.기타1. DP : 왜 알고리즘 분류에 DP가 들어갔나 했더만, 이미 검사한 거는 check표시하여 검사하지..." } ]
