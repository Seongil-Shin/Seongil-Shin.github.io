<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>디피의 개발일지</title>
    <description>학습 및 프로젝트 기록 블로그 React, Spring</description>
    <link>https://seongil-shin.github.io/</link>
    <atom:link href="https://seongil-shin.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 29 Dec 2024 23:01:47 +0900</pubDate>
    <lastBuildDate>Sun, 29 Dec 2024 23:01:47 +0900</lastBuildDate>
    <generator>Jekyll v4.3.4</generator>
    
      <item>
        <title>Node.js</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Javascript를 브라우저 밖에서도 실행할 수 있도록 하는 Javascript의 런타임&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;node.js를 접하다보면 자주 나오는 말은 다음과 같다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이벤트 기반&lt;/li&gt;
  &lt;li&gt;싱글 쓰레드 논블로킹 모델&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-이벤트-기반&quot;&gt;1. 이벤트 기반&lt;/h2&gt;

&lt;p&gt;node.js는 이벤트 리스너에 등록해둔 콜백함수를 실행하는 방식으로 동작한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;router&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 이벤트 기반 모델에서는 이벤트에 따라 호출되는 콜백함수를 관리하는 것이 “이벤트 루프”이다. (브라우저의 이벤트 루프와는 다름)&lt;/p&gt;

&lt;h3 id=&quot;이벤트-루프-동작-원리&quot;&gt;이벤트 루프 동작 원리&lt;/h3&gt;

&lt;p&gt;node.js가 시작되면 스레드가 생기고, 이벤트 루프가 생성된다. 이벤트 루프는 6개의 페이지를 라운드 로빈으로 순회하며 동작한다.&lt;/p&gt;

&lt;p&gt;각 단계는 FIFO 큐를 가지며 다음과 같은 작업을 수행한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;timers
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setInterval&lt;/code&gt; 같은 timer 함수를 처리한다&lt;/li&gt;
      &lt;li&gt;페이즈를 순회하면서 처리할 수 있는 timer 함수를 확인하고 콜백함수를 실행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pending callbacks
    &lt;ul&gt;
      &lt;li&gt;다음 루프 반복으로 연기된 I/O 완료 결과가 큐에 담긴다.&lt;/li&gt;
      &lt;li&gt;I/O 작업이 완료되면 다음 루프에서 이 단계 큐에 들어와 있고, I/O 작업 블록 내의 콜백함수들은 poll 단계의 큐로 넘겨준다.&lt;/li&gt;
      &lt;li&gt;또한 TCP 오류 같은 시스템 작업의 콜백을 실행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;idle, prepare : 내부용으로만 사용됨&lt;/li&gt;
  &lt;li&gt;poll
    &lt;ul&gt;
      &lt;li&gt;I/O와 연관된 콜백을 실행하며 timer 단계에서의 실행시간 제어를 담당한다.&lt;/li&gt;
      &lt;li&gt;poll 큐에 쌓인 콜백함수들을 한도가 넘지 않을때까지 모두 동기적으로 실행한다.&lt;/li&gt;
      &lt;li&gt;한도가 넘거나 더이상 실행항 콜백함수가 없을 경우 아래 규칙에 따라 동작한다.
        &lt;ul&gt;
          &lt;li&gt;check 단계를 검사하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;가 있는지 확인한다. 있으면 check 단계로 넘어간다&lt;/li&gt;
          &lt;li&gt;timer 단계를 검사하여 실행할 timer 함수가 있는지 확인한다. 없으면 있을때까지 대기 한후 timer 단계로 넘어간다.&lt;/li&gt;
          &lt;li&gt;timerㄷ단계를 대기하는 동안 poll 큐에 콜백함수가 쌓이면 즉시 실행한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;check
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;의 콜백함수를 실행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;close callbacks
    &lt;ul&gt;
      &lt;li&gt;close 이벤트에 따른 콜백함수를 실행한다 ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket.on(&quot;close&quot;, ...)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예시)&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
  
&lt;span class=&quot;nf&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;immediate&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이 코드를 실행시 timer 단계라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setTimeout&lt;/code&gt;을 먼저 실행함. timer 단계를 지났다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt;를 먼저 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
  
&lt;span class=&quot;nx&quot;&gt;fs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;__filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
	&lt;span class=&quot;nf&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
	&lt;span class=&quot;nf&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;immediate&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;  
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;i/o 콜백 함수는 poll 단계에서 실행되기에 항상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setImmediate&lt;/code&gt; 먼저 수행되게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-싱글-쓰레드-논블로킹-모델&quot;&gt;2. 싱글 쓰레드 논블로킹 모델&lt;/h2&gt;

&lt;p&gt;Node.js를 접하다보면 자주 보이는 말이 Node.js는 싱글 쓰레드 논블로킹이라는 말이다.&lt;/p&gt;

&lt;p&gt;먼저 싱글쓰레드에 대해서 살펴보면, Node.js는 이론적으로는 싱글 쓰레드지만 완전한 싱글 쓰레드는 아니다.&lt;/p&gt;

&lt;p&gt;구체적으로는 node.js는 동기 작업이 동작하는 main thread(이벤트루프)와 libuv 라이브러리로 관리되는 스레드풀에서 블로킹 작업이 수행된다. 네트워크 I/O 등 블로킹 작업이 발생해도 main thread를 막지 않고, 블로킹 작업은 백그라운드에서 처리하고 main thread 는 그동안 다른 작업을 수행할 수 있다. 이것이 싱글스레드 논블로킹의 의미이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동기 작업 : main thread 에서 실행 (이것도 libuv에서 관리되긴 함)&lt;/li&gt;
  &lt;li&gt;블로킹 작업 (I/O, 네트워크 작업) : libuv를 통해 백그라운드에서 처리됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를들어, 각각 3초, 5초, 6초, 8초가 걸리는 요청이 매우 짧은 간격으로 들어온다면 아래와 같이 동작한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;전부 동기작업만 있을경우, event loop에서 차례대로 처리되어 총 3 + 5 + 6 + 8 = 22초 + a 걸림. (a는 context switching)&lt;/li&gt;
  &lt;li&gt;전부 비동기작업만 있을경우, 논블로킹으로 동작하기에 가장 오래 걸리는 작업과 같은 8초가 걸림.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;libuv&quot;&gt;libuv&lt;/h3&gt;

&lt;p&gt;libuv는 자신의 스레드풀을 가지고 있다. 하지만 네트워크 I/O와 같은 작업들은 OS 커널에서 지원해주는 경우가 많다. 이 경우에는 커널을 사용하고, 커널이 지원하지 않는 작업(Disk I/O 등)에 대해서만 자신의 스레드풀을 사용한다. 이것이 완전한 싱글쓰레드가 아니다라는 것의 의미이다.&lt;/p&gt;

&lt;p&gt;libuv의 스레드풀을 사용하는 작업들&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;DNS resolver (because most OS provide only synchronous API for this)&lt;/li&gt;
  &lt;li&gt;File system API (because this is messy to do asynchronously cross-platform)&lt;/li&gt;
  &lt;li&gt;Crypto (Because this uses the CPU)&lt;/li&gt;
  &lt;li&gt;Zlib (zip compression)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 libuv의 스레드 풀을 늘릴 수는 있으나 libuv의 스레드풀을 사용하는 작업이 아닌 것에 대해서는 큰 의미가 없다. (Disk I/O 또한 Disk가 하나이면 한번에 하나씩 접근 가능하기에 의미 없음) (기본은 4개)&lt;/p&gt;

&lt;h3 id=&quot;worker_threads&quot;&gt;worker_threads&lt;/h3&gt;

&lt;p&gt;node.js 에서 의도적으로 멀티스레드를 사용할 수 있는 방법&lt;/p&gt;

&lt;h2 id=&quot;3-클러스터-모드-멀티-코어-사용&quot;&gt;3. 클러스터 모드 (멀티 코어 사용)&lt;/h2&gt;

&lt;p&gt;물리 코어는 동일 시점에 하나의 스레드만 실행하므로, 하나의 node.js 인스턴스는 싱글 스레드이므로 아무리 많이 사용해봤자 싱글 코어 하나만 차지한다. (libuv 스레드풀에서 여러 스레드를 더 사용할 수 있지만, 일반적으로 하나의 코어만 사용한다고 봄)&lt;/p&gt;

&lt;p&gt;최신 CPU는 멀티코어가 기본이므로 멀티코어 CPU에서 하나의 node.js만 띄우면 비효율적이다. 따라서 다음과 같이 멀티 코어를 전부 활용하는 방법을 사용할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;node.js cluster 모듈 사용&lt;/li&gt;
  &lt;li&gt;PM2 사용&lt;/li&gt;
  &lt;li&gt;worker threads 사용 : node.js 10.5+ 버전부터 CPU 집약 작업을 병렬로 처리할 수 있도록 함. 프로세스는 하나로 동작함.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 이러한 최적화 기법이 항상 통하는 것이 아니다. 만약 성능 bottleneck이 javascript 코드 자체에 있다면 클러스터가 도움이 된다. 하지만 만약 network i/o나 db 작업에 있다면 큰 도움이 안된다. 따라서 어디가 문제인지를 찾아야한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example if you are CPU limited in your nodejs process with the running of your own Javascript, then perhaps you want to implement nodejs clustering to get multiple CPUs all running different requests. But, if the real bottleneck is in your database, then cluster your nodejs request handlers won’t help with the database bottleneck.&lt;/p&gt;

  &lt;p&gt;Benchmark, measure, come up with theories based on the data for what to change, design specific tests to measure that, then implement one of the theories and measure. Adjust based on what you measure. You can only really do this properly (without wasting a lot of time in unproductive directions) by measuring first, making appropriate adjustments and then measuring progress.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://velog.io/@tennfin1/NodeJS%EA%B0%80-Spring%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B4%EB%8B%A4%EA%B3%A0-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%B4%EB%93%9C%EB%A6%BC\&lt;/li&gt;
  &lt;li&gt;https://jdm.kr/blog/166&lt;/li&gt;
  &lt;li&gt;https://medium.com/@vdongbin/node-js-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC-single-thread-event-driven-non-blocking-i-o-event-loop-ce97e58a8e21&lt;/li&gt;
  &lt;li&gt;https://stackoverflow.com/questions/63369876/nodejs-what-is-maximum-thread-that-can-run-same-time-as-thread-pool-size-is-fo&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 29 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/Node.js/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/Node.js/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>node</category>
        
      </item>
    
      <item>
        <title>Typescript</title>
        <description>
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;posts/study/typescript/Typescript%20속도%20개선.md&quot;&gt;Typescript 속도 개선&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/Typescript/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/Typescript/</guid>
        
        
      </item>
    
      <item>
        <title>Typescript 속도 개선</title>
        <description>
&lt;p&gt;https://youtu.be/g9FL8hKoNqE?si=tsCYUjwOX5Z0AqZk&lt;/p&gt;

&lt;h2 id=&quot;분석&quot;&gt;분석&lt;/h2&gt;

&lt;p&gt;Typescript 옵션으로 성능 문제 진단&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extendedDiagnostics&lt;/code&gt; 로 대략적인 컴파일 시간 확인 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateTrace&lt;/code&gt; 로 트레이스 파일을 출력할 수 있음. 이 파일을 툴에 넣어 확인 가능
    &lt;ul&gt;
      &lt;li&gt;trace.json : 컴파일에 소요된 시간 중 오래 걸리는 부분을 출력.&lt;/li&gt;
      &lt;li&gt;types.json : 컴파일러가 인식한 타입의 목록을 출력.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;툴을 사용해서 성능 문제 진단&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@typescript/analyze-trace&lt;/code&gt; : CLI로 trace를 분석하여 hot spot 식별 가능&lt;/li&gt;
  &lt;li&gt;https://ui.perfetto.dev/ : GUI로 상세한 확인이 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개선&quot;&gt;개선&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keyof JSX.IntrinsicElements;&lt;/code&gt;은 175개의 태그 이름이 들어간 union type. 따라서 Row를 정의하는 순간 175개의 태그를 정의할 수 있는 타입이 정의됨&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IntrinsicElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IntrinsicElements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;gap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;never&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Row&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}:&lt;/span&gt;
									   &lt;span class=&quot;nx&quot;&gt;PropsWithChildren&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;as as &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ElementsType&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&amp;gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;영상의 해결책으론 두가지 방법을 제시함&lt;/p&gt;

&lt;h3 id=&quot;type-narrowing&quot;&gt;Type Narrowing&lt;/h3&gt;

&lt;p&gt;일부 태그만 지정하여 타입의 범위를 줄임&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dynamic-inference&quot;&gt;Dynamic inference&lt;/h3&gt;

&lt;p&gt;제네릭을 통해 필요한 태그만 지정해서 사용할 수 있도록 함. Type Narrowing 보다 다양한 태그에 대응가능&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IntrinsicElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IntrinsicElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Elements&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;JSX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;IntrinsicElements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Omit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ElementProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Row&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;as &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&amp;gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 아래와 같이 개선할 수 있음&lt;/p&gt;

&lt;div class=&quot;language-ts highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ComponentProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;react&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Omit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ComponentProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FlexProps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Row&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;as &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{...&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&amp;gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;그외-개선법&quot;&gt;그외 개선법&lt;/h2&gt;

&lt;p&gt;타입스크립트에서 권장하는 컴파일 되기 쉬운 코드 작성법 (&lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Performance#writing-easy-to-compile-code&quot;&gt;링크&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Preferring Interfaces Over Intersections&lt;/li&gt;
  &lt;li&gt;Using Type Annotations&lt;/li&gt;
  &lt;li&gt;Preferring Base Types Over Unions&lt;/li&gt;
  &lt;li&gt;Naming Complex Types&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/Typescript-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/Typescript-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0/</guid>
        
        
      </item>
    
      <item>
        <title>React</title>
        <description>
</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/React/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/React/</guid>
        
        
      </item>
    
      <item>
        <title>React 규칙</title>
        <description>&lt;p&gt;https://ko.react.dev/reference/rules&lt;/p&gt;

&lt;p&gt;관용적인 &lt;a href=&quot;posts/study/react/React.md&quot;&gt;React&lt;/a&gt; 코드를 작성하기 위한 규칙들. 이러한 규칙을 지키면 변화에 더 잘 대처할 수 있고, 다른 라이브러리, 도구, 개발자와의 협업이 원활해진다. 만약 어길 경우 어플리케이션에 버그가 생길 가능성이 높고, 일반적이지 않게 변한다.&lt;/p&gt;

&lt;p&gt;React 규칙을 따르기 쉽게하기 위해 ESLint 플러그인과 함께 Strict Mode를 사용하는 것이 권장된다.&lt;/p&gt;

&lt;h2 id=&quot;컴포넌트와-hooks는-순수해야한다&quot;&gt;컴포넌트와 Hooks는 순수해야한다&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;컴포넌트는 멱등해야한다.&lt;/li&gt;
  &lt;li&gt;사이드 이펙트는 렌더링 외부에서 실행되어야한다.&lt;/li&gt;
  &lt;li&gt;Props와 state는 단일 렌더링에 대해 불변 스냅샷이다. 직접 변경하면 안된다.&lt;/li&gt;
  &lt;li&gt;Hook의 반환값과 인수는 불변이다. 값이 Hook에 전달되면 이를 수정해서는 안된다.&lt;/li&gt;
  &lt;li&gt;JSX로 전달된 값은 불변이다. JSX에 사용한 후 변경하지 말고, 생성되기 전에 변경하라&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react가-컴포넌트와-hook을-호출하는-방식&quot;&gt;React가 컴포넌트와 Hook을 호출하는 방식&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;컴포넌트 함수를 직접 호출하지마라. 컴포넌트는 JSX에서만 사용해야하며 일반 함수처럼 호출하지마라&lt;/li&gt;
  &lt;li&gt;Hook을 일반 값으로 전달하지마라. Hook은 반드시 컴포넌트 내부에서만 호출되어야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hook의-규칙&quot;&gt;Hook의 규칙&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Hook은 최상위레벨에서만 호출해야한다&lt;/li&gt;
  &lt;li&gt;Hook은 React 함수에서만 호출해야한다&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/React-%EA%B7%9C%EC%B9%99/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/React-%EA%B7%9C%EC%B9%99/</guid>
        
        
      </item>
    
      <item>
        <title>React context</title>
        <description>
&lt;p&gt;상태 업데이트 시 해당 컴포넌트만 업데이트?&lt;/p&gt;
</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/React-Context/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/React-Context/</guid>
        
        
      </item>
    
      <item>
        <title>React compiler</title>
        <description>
&lt;h2 id=&quot;1-정의&quot;&gt;1. 정의&lt;/h2&gt;

&lt;p&gt;빌드 시 적용되는 도구로, [[React]]를 자동으로 최적화해준다. 관련 eslint 플러그인도 제공하여 코드 품질을 높이는데 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;11-무엇을-하는가&quot;&gt;1.1 무엇을 하는가?&lt;/h3&gt;

&lt;p&gt;기존에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useMemo&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;useCallback&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React.memo&lt;/code&gt; 와 같은 API 로 직접 메모이제이션하였다. 하지만 개발하다보면 이를 잊어버릴수 있다.&lt;/p&gt;

&lt;p&gt;리액트 컴파일러는 자동으로 컴포넌트와 Hooks 내의 값 또는 값 그룹을 메모이제이션 한다. 만약 JS나 React 규칙을 위반한 경우에는 해당 컴포넌트 또는 Hooks를 건너뛰고 다른 코드를 컴파일한다.&lt;/p&gt;

&lt;p&gt;컴파일러가 초점을 맞춘 두가지 사례&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴포넌트의 연쇄적인 리렌더링 건너뛰기 : 부모만이 변경되었어도 자식까지 전부 리렌더링되는 경우&lt;/li&gt;
  &lt;li&gt;React 외부에서의 비용이 많이 드는 계산 건너뛰기 : 컴포넌트 내에서 호출하는 경우 메모이제이션됨
```js
// 함수 자체는 리액트 컴파일러에 의해 메모이제이션되지 않음.
function expensiveProcess() { … }&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;function Table() {
	// 리액트 컴파일러에 의해 컴포넌트 내에서 메모이제이션 됨.
	const data = expensiveProcess();
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
### 1.2 컴파일러가 가정하는 것

1. 올바르고 의미있는 JS 코드로 작성되었다 (valid, semantic JavaScript.)
2. nullable/optional 값과 속성에 접근하기 전에 그 값이 정의되어있는지 테스트한다. (TS를 사용하는 경우 `strictNullCheck`를 활성화하여 수행함)
3. [[React 규칙]]을 따른다.

만약 규칙을 어긋나는 것이 있다면 그 컴포넌트는 컴파일을 건너뛴다.

## 2. 내부 코드

- 컴파일 전 리액트 코드
```js
function FriendList({ friends }) {
	const onlineCount = useFriendOnlineCount();
	if (friends.length === 0) {
		return &amp;lt;NoFriends /&amp;gt;;
	}
	
	return (
		&amp;lt;div&amp;gt;
			&amp;lt;span&amp;gt;{onlineCount} online&amp;lt;/span&amp;gt;
			{friends.map((friend) =&amp;gt; (
				&amp;lt;FriendListCard key={friend.id} friend={friend} /&amp;gt;
			))}
			&amp;lt;MessageButton /&amp;gt;
		&amp;lt;/div&amp;gt;
	);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일 후 코드
    &lt;ul&gt;
      &lt;li&gt;의존성이 없는 하위 컴포넌트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Symbol.for(&quot;react.memo_cache_sentinel&quot;)&lt;/code&gt; 이면 렌더링, 아니면 이전에 만든 값 사용&lt;/li&gt;
      &lt;li&gt;의존성이 있는 컴포넌트는 의존하는 값들이 이전과 같은지 다른지에따라 동작 구분
```js
function FriendList(t0) {
  const $ = _c(9);
  const { friends } = t0;
  const onlineCount = useFriendOnlineCount();
  if (friends.length === 0) {
  let t1;
  if ($[0] === Symbol.for(“react.memo_cache_sentinel”)) {
      t1 = &lt;NoFriends&gt;&lt;/NoFriends&gt;;
      $[0] = t1;
  } else {
      t1 = $[0];
  }
  return t1;
  }
  let t1;
  if ($[1] !== onlineCount) {
  t1 = &lt;span&gt;{onlineCount} online&lt;/span&gt;;
  $[1] = onlineCount;
  $[2] = t1;
  } else {
  t1 = $[2];
  }
  let t2;
  if ($[3] !== friends) {
  t2 = friends.map(_temp);
  $[3] = friends;
  $[4] = t2;
  } else {
  t2 = $[4];
  }
  let t3;
  if ($[5] === Symbol.for(“react.memo_cache_sentinel”)) {
  t3 = &lt;MessageButton&gt;&lt;/MessageButton&gt;;
  $[5] = t3;
  } else {
  t3 = $[5];
  }
  let t4;
  if ($[6] !== t1 || $[7] !== t2) {
  t4 = (
      &amp;lt;div&amp;gt;
          {t1}
          {t2}
          {t3}
      &amp;lt;/div&amp;gt;
  );
  $[6] = t1;
  $[7] = t2;
  $[8] = t4;
  } else {
  t4 = $[8];
  }
  return t4;
}
function _temp(friend) {
  return &amp;lt;FriendListCard key={friend.id} friend={friend} /&amp;gt;;
}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;

컴파일 후 코드를 보면 `_c` 함수에서 메모이제이션을 담당하고 있는것을 확인할 수 있다.  
- 필요한 의존성만큼의 사이즈를 가진 배열 상태를 반환
- 각 요소의 초기값은 `Symbol.for(&quot;react.memo_cache_sentinel&quot;)`

```ts
// compiler/packages/react-compiler-runtimes/src/index.ts

type MemoCache = Array&amp;lt;number | typeof $empty&amp;gt;;

const $empty = Symbol.for('react.memo_cache_sentinel');
/**
 * DANGER: this hook is NEVER meant to be called directly!
 **/
export function c(size: number) {
  return React.useState(() =&amp;gt; {
    const $ = new Array(size);
    for (let ii = 0; ii &amp;lt; size; ii++) {
      $[ii] = $empty;
    }
    // This symbol is added to tell the react devtools that this array is from
    // useMemoCache.
    // @ts-ignore
    $[$empty] = true;
    return $;
  })[0];
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-궁금증&quot;&gt;3. 궁금증&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;올바르고 의미있는 JS 라는 것은? (valid, semantic JavaScript.)
    &lt;ul&gt;
      &lt;li&gt;valid : ECMAScript 표준에 부합하는 문법과 구조를 가지고 있고, 파싱 과정에서 에러나 경고를 일으키지 않는 코드&lt;/li&gt;
      &lt;li&gt;semantic : 문법적으로만 맞추는 것을 넘어, 의도한 바를 명확히 드러내고 예상 가능한 동작을 하도록 구성된 코드를 의미.
        &lt;ul&gt;
          &lt;li&gt;ex) 변수나 함수 사용 시 의도된 스코프에서 유효하게 사용. 타입 변환 로직이나 비동기 흐름이 명확하게 관리됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최초 로딩 성능에 영향을 줄까?
    &lt;ul&gt;
      &lt;li&gt;큰 영향이 없다고 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유저가 상호작용시 성능은 어떨까?
    &lt;ul&gt;
      &lt;li&gt;불필요한 리렌더링을 줄이니 매우 빨라짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 리렌더링을 잡아서 더이상 개발자는 메모이제이션을 신경쓰지 않아도 될까?
    &lt;ul&gt;
      &lt;li&gt;아니다. 리액트 컴파일러는 props 가 변하지 않을때만 대응되지, props 설계를 잘못하면 리렌더링은 여전히 발생하기에 신경은 써야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;참조를 props로 넣었을때 리액트 컴파일러는 작동하지 않는가?
    &lt;ul&gt;
      &lt;li&gt;아니다. 참조를 사용했을때도 적절히 컴파일 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;외부 라이브러리 사용시에는?
    &lt;ul&gt;
      &lt;li&gt;리액트 입장으론 대응을 아직 잘 못함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;https://www.youtube.com/watch?v=T-rHmWSZajc&amp;amp;ab_channel=ReactConferencesbyGitNation&lt;/li&gt;
  &lt;li&gt;https://ko.react.dev/learn/react-compiler&lt;/li&gt;
  &lt;li&gt;https://helloinyong.tistory.com/365&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/React-Compiler/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/React-Compiler/</guid>
        
        
      </item>
    
      <item>
        <title>Next.js</title>
        <description>
</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/next.js/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/next.js/</guid>
        
        
      </item>
    
      <item>
        <title>Js 알고리즘 팁</title>
        <description>
&lt;ul&gt;
  &lt;li&gt;첫번째처럼 할 경우 모든 요소에 같은 배열의 참조가 들어감
```js
// bad
var arr = new Array(1000).fill(new Array())&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// good
var arr = new Array(1000).fill(0).map(() =&amp;gt; []);&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
- dfs 와 같이 함수를 깊이 탐색해야할때 런타임 오류가 발생하면, 재귀함수가 아닌 반복문으로 dfs 구현해야함
- 진수변환
```js
// 문자열 -&amp;gt; 숫자
var num = parseInt(&quot;12341&quot;, 4); // (문자열, 진수)

// 숫자 -&amp;gt; 문자열
var str = 1314123.toString(6); // 숫자.toString(진수)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/JS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%81/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/JS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%8C%81/</guid>
        
        
      </item>
    
      <item>
        <title>Next.js 최대 connection</title>
        <description>
&lt;p&gt;현상 : https://seongil-shin.github.io/posts/next.js-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B3%BC%EC%A0%95/&lt;/p&gt;

&lt;p&gt;의문&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이슈가 발생할떄 정적페이지에도 응답이 안가나? API 요청이 있는 페이지만 안가나? 아니면 이슈 발생하는 페이지만 안가나?&lt;/li&gt;
  &lt;li&gt;이슈가 발생하는건 외부 API가 느려져서인데 HPA가 의미가 있나?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;추측&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;최대 요청 연결 가능 갯수가 있어서 해당 갯수 이상으로 요청이 hang 되면 정적페이지여도 안감. 이 최대 연결 갯수는 팟 개수에 비례하기에 HPA 를 통해 팟을 늘리면 다른 정적페이지가 응답이 갈만한 스페이스가 확보될 수 있음&lt;/li&gt;
  &lt;li&gt;API 요청이 있는 페이지만 안감. 만약 pod 갯수에 따라 확장되면 이슈 없는 API 요청있는 페이지가 요청될만한 스페이지 확보 가능.&lt;/li&gt;
  &lt;li&gt;해당 페이지만 안감. 이러면 HPA 의미 없음.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;확인해봐야할거&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최대 요청 연결 가능 개수가 있는지. 있다면 pod 갯수에 따라 확장되는지
    &lt;ul&gt;
      &lt;li&gt;ELB : 있지만 2^32 - 1 라는 매우 큰 수이기에 큰 의미는 없음&lt;/li&gt;
      &lt;li&gt;n2c (istio ingress) : ingress의 max connection은 2^32 - 1 라 큰 의미 없을거 같음&lt;/li&gt;
      &lt;li&gt;next.js&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최대 API 요청 연견 가능 갯수가 있는지. 있다면 pod 갯수에 따라 확장되는지
    &lt;ul&gt;
      &lt;li&gt;n2c : egress의 max connection은 2^32 - 1 라 큰 의미 없을거 같음&lt;/li&gt;
      &lt;li&gt;next.js&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 29 Dec 2024 00:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/next.js-%EC%B5%9C%EB%8C%80-Connection/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/next.js-%EC%B5%9C%EB%8C%80-Connection/</guid>
        
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - Appendix</title>
        <description>&lt;h2 id=&quot;a1-암시적-스코프&quot;&gt;A.1 암시적 스코프&lt;/h2&gt;

&lt;p&gt;스코프는 가끔 명확하지 않은 위치에 생성된다. 일반적으론 이러한 암시적 스코프가 작동에 영향을 주진않는데, 알고 있으면 유용하다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;매개변수 스코프&lt;/li&gt;
  &lt;li&gt;함수명 스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;매개변수-스코프&quot;&gt;매개변수 스코프&lt;/h3&gt;

&lt;p&gt;함수 매개변수는 함수 스코프에서 지역으로 선언한 변수와 동일하다고 하였지만, 항상 그렇지는 않다.&lt;/p&gt;

&lt;p&gt;아래와 같이 단순한 매개변수 형태는 함수 스코프와 매개변수 스코프가 같다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 기본값이 있는 매개변수, …을 사용하는 나머지 매개변수, 비구조화 매개변수의 경우에는 매개변수 자체적으로 스코프를 형성하고, 함수 스코프는 그 아래 형성된다. (&lt;strong&gt;단순하지 않은 매개변수는 자체 스코프를 형성한다&lt;/strong&gt;)&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 파란색 버블 (스코프) */&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// 초록색 버블 (스코프)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그 이유는 단순하지 않은 매개변수 형태에서는 다양한 예외 케이스를 효과적으로 다루기 위해 자체 스코프를 형성한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;왼쪽에서 오른쪽으로 연산이 수행되면서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maxId&lt;/code&gt;는 초기화되어있지 않으므로 TDZ 에러를 발생시킴.
```js
// TDZ 에러 발생
function getStudentName(studentId = maxId, maxId) {
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 문제 없음
function getStudentName(maxId, studentId = maxId) {
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
- 기본 매개변수에 함수 표현식이 있는 경우 매개변수 자체에 대한 클로저가 생길 수 있어 복잡성이 더 증가한다.

```js
// id를 재할당하여 5가 출력됨
function getStudentName(id, defaultId = () =&amp;gt; id) {
	id = 5;
	console.log(defaultId())
}
getStudentName(3) // 5


// var id가 매개변수 스코프 내의 id를 가려서 defaultId의 클로저는 매개변수 스코프를 가리키고 있기에 3이 출력됨 
function getStudentName2(id, defaultId = () =&amp;gt; id) {
	var id = 5;
	console.log(defaultId())
}
getStudentName2(3) // 3
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;아래와 같이 과거 코드와의 호환 문제로 상황이 더 복잡해진 경우가 있다.
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;defaultId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 호환 문제로 매개변수와 깉은 이름의 지역변수는 undefined로 초기화하지 않고, 매개변수 id를 매개변수 값으로 초기화함.&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defaultId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;  

  &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 지역변수를 5로 재할당하여 매개변수와 다른 스코프에 있음을 확인할 수 있음.&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defaultId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 3, 3&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 5, 3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 이러한 차이에 영향을 받지 않으려면 다음 사항을 유념해야한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;지역 변수로 매개변수를 섀도잉하지마라&lt;/li&gt;
  &lt;li&gt;기본 매개변수에서는 다른 매개변수를 참조하지마라&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;함수명-스코프&quot;&gt;함수명 스코프&lt;/h3&gt;

&lt;p&gt;함수이름 스코프에서는 함수 자체의 스코프에 함수 표현식의 이름이 추가된다고 설명하였다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;askQuestion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofTheTeacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 ofTheTeacher가 askQuestion이 선언된 외부 스코프에 추가되지 않지만, 단순히 함수 내부 스코프에 추가되는 것도 아니다. 이 경우도 암시 스코프의 예외 케이스를 만든다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;askQuestion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofTheTeacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ofTheTeacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;some name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 중복 선언 오류를 발생하지 않는다&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;let은 재선언이 불가능하지만 함수명인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ofTheTeacher&lt;/code&gt;와 다른 스코프에 있기에 섀도잉으로 처리된다. 실무적으로 이러한 경우가 중요할때가 거의 없지만, 이슈를 피하기 위해 함수 이름과 동일한 이름의 변수를 함수 본문 내부에서 let으로 선언하는 것은 피하라.&lt;/p&gt;

&lt;h2 id=&quot;a2-익명-함수-vs-기명-함수&quot;&gt;A.2 익명 함수 vs 기명 함수&lt;/h2&gt;

&lt;p&gt;요약&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이름 추론은 불완전하다&lt;/li&gt;
  &lt;li&gt;렉시컬 이름을 사용하면 자기 참조가 가능하다&lt;/li&gt;
  &lt;li&gt;이름은 설명을 제공하기에 유용하다&lt;/li&gt;
  &lt;li&gt;화살표함수에는 렉시컬 이름이 없다&lt;/li&gt;
  &lt;li&gt;IIFE에도 이름이 필요하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a21-명시적-혹은-추론된-이름&quot;&gt;A.2.1 명시적 혹은 추론된 이름&lt;/h3&gt;

&lt;p&gt;기명함수를 사용하여 함수의 이름을 명시적으로 남기면 스택트레이스에서도 함수 이름을 확인할 수 있다. 
이와 별개로 익명함수를 사용하더라도 이름이 추론되는 경우가 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;notNamed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;funcion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;notNamed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// notNamed&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;confib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// cb&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와같이 JS는 이름을 추론하기에 추론된 이름을 사용해도 되지만 모든 문제를 해결할 수는 없다&lt;/p&gt;

&lt;h3 id=&quot;a22-이름이-없다면&quot;&gt;A.2.2 이름이 없다면?&lt;/h3&gt;

&lt;p&gt;이름 추론이 정상적으로 동작하지 않는 경우들이 있기에, 이름 추론에 의존하는 것은 불완전하다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;콜백 인자로 전달 시 이름 추론 안됨
```js
function ajax(url, cb) {
  console.log(cb.name)
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ajax(“some.url”, function(){})&lt;/p&gt;

&lt;p&gt;// “”&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
- 함수 표현식을 단순 할당이 아닌 다른 형태로 하는 경우에는 대부분 추론에 실패함. 
```js
var config = {}
config.cb = function(){}
config.cb.name; // &quot;&quot;

var [noName] = [function(){}]
noName.name; // &quot;&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;a23-나는-누구일까요&quot;&gt;A.2.3 나는 누구일까요?&lt;/h3&gt;

&lt;p&gt;렉시컬 이름 식별자가 없으면 함수는 내부적으로 자기 자신을 참조할 방법이 없다. 자기 참조는 재귀나 이벤트 처리하는 작업에서 매우 중요하다&lt;/p&gt;

&lt;h3 id=&quot;a24-이름은-설명입니다&quot;&gt;A.2.4 이름은 설명입니다&lt;/h3&gt;

&lt;p&gt;함수에 이름을 넣지 않으면 코드를 이해하기가 어렵다&lt;/p&gt;

&lt;h3 id=&quot;a25-화살표-함수&quot;&gt;A.2.5 화살표 함수&lt;/h3&gt;

&lt;p&gt;화살표함수는 이름 추론을 통해 이름이 붙더라도 항상 익명이다. 따라서 사용을 지양하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;화살표함수에는 목적이 있지만, 이는 타이핑 횟수를 줄이는 것이 아닌 화살표 함수 렉시컬 this 동작을 이해해야 제대로 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;간단히 말하면 화살표 함수의 this는 렉시컬 스코프에 의해 결정된다. 화살표 함수 자체는 this를 가지지 않으며 화살펴 함수 안에 this를 사용하면 다른 변수 참조처럼 작동한다. 즉 화살표 함수는 this를 다른 렉시컬 변수처럼 취급한다. 이러한 동작을 사용해야하는 경우는 다음과 같다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var self = this&lt;/code&gt; 와 같은 기법을 사용하는 경우&lt;/li&gt;
  &lt;li&gt;내부 함수 표현식에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.bind(this)&lt;/code&gt;를 호출하는 것 대신에 사용하기 위해&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a26-iife&quot;&gt;A.2.6 IIFE&lt;/h3&gt;

&lt;p&gt;IIFE 에도 이름을 붙이는 것이 좋다.&lt;/p&gt;

&lt;p&gt;이와 별개로 IIFE는 보통 함수 표현식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;로 감싸서 정의하는데, 이는 JS 파서가 function 키워드를 만났을때 함수 선언문으로 해석하지 않게하기 위함이다. 이를 위해서는 다음과 같은 방법도 활용가능하며 취향껏 선택할 수 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;로 감싸기&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void&lt;/code&gt; 등의 단항 연산자를 function 앞에 놓아 표현식으로 만들기&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsIIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{})()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsIIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsIIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsIIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thisIsIIFE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}()&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a3-호이스팅--함수와-변수&quot;&gt;A.3 호이스팅 : 함수와 변수&lt;/h2&gt;

&lt;p&gt;함수, 변수 호이스팅이 왜 유용하고 배워야하는지&lt;/p&gt;

&lt;h3 id=&quot;a31-함수-호이스팅&quot;&gt;A.3.1 함수 호이스팅&lt;/h3&gt;

&lt;p&gt;함수 선언문은 컴파일 단계에서 호이스팅 되기에 함수 식별자는 스코프 시작 부분에 함수 참조로 자동 초기화된다.&lt;/p&gt;

&lt;p&gt;이를 사용하면 함수 실행은 코드 위쪽에서하고 선언은 아래쪽에 배치할 수 있는데, 이러한 배치는 복잡한 함수 내부를 아래로 숨길 수 있기에 함수 세부 사항을 굳이 파악하지 않고도 코드의 작동을 파악하기 편하다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;getStudents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;whatever&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;whatever&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;a32-변수-호이스팅&quot;&gt;A.3.2 변수 호이스팅&lt;/h3&gt;

&lt;p&gt;함수 호이스팅과 다르게 변수 호이스팅은 가독성에 도움을 주지 않는다. 따라서 유용한 경우는 적은데 저자의 생각으로는 CommonJS에서 비공개 변수를 하단에 배치하는 경우에는 도움이 된다고 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;getStudents&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 비공개 구현&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;otherData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a4-var에-대한-변론&quot;&gt;A.4 var에 대한 변론&lt;/h2&gt;

&lt;p&gt;변수 호이스팅과 관련하여 JS 개발 중 발생하는 여러 이슈의 원인은 주로 var와 관련된다. 여기서 살펴볼 것은 다음과 같다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;var에 문제가 있는 것이 아니다&lt;/li&gt;
  &lt;li&gt;let은 우리들의 친구이다&lt;/li&gt;
  &lt;li&gt;const의 유용성은 제한적이다&lt;/li&gt;
  &lt;li&gt;var와 let을 사용하는 최선의 방법은 둘의 장점을 모두 취하는 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a41-var를-버리지-마세요&quot;&gt;A.4.1 var를 버리지 마세요.&lt;/h3&gt;

&lt;p&gt;var 에는 문제가 없고 var 만의 장점이 있다. 따라서 무조건 쓰지말자고 하는 것은 장점을 버리는 일이다.&lt;/p&gt;

&lt;h3 id=&quot;a42-혼란스러운-const&quot;&gt;A.4.2 혼란스러운 const&lt;/h3&gt;

&lt;p&gt;const 를 사용하면 얻을 수 있는 약간의 이점은 있지만, const를 사용하면서 겪는 혼란보다는 크지 않다.&lt;/p&gt;

&lt;p&gt;const는 변경할 수 없는 값을 만드는 것이 아니라, 재할당을 할 수 없도록 하는 것이다. 따라서 객체, 배열과 같이 변경할 수 있는 값에 const를 사용하면 나중에 수정이 발생할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentIds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;51&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;studentsIds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 동작함&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물론 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;41&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;name&quot;&lt;/code&gt;과 같은 원시값을 사용할 때는 변경할 수 없지만, 이런 이점을 취할 일은 거의 없다. const는 블록 스코프이고 블록은 짧아야한기에 실제로 const가 영향을 끼치는 범위는 작다.&lt;/p&gt;

&lt;h3 id=&quot;a43-var와-let&quot;&gt;A.4.3 var와 let&lt;/h3&gt;

&lt;p&gt;var를 사용할 때&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수의 최상위 스코프에서 사용 (처음, 중간, 끝 관계없이). 전역에서는 되도록 사용하지 않음&lt;/li&gt;
  &lt;li&gt;반복문 내에서 선언한 변수를 조건문에서도 보고 싶을때&lt;/li&gt;
  &lt;li&gt;의도하지 않은 블록 내에 선언이 있을때. (ex : try…catch)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;commitAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fromCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;학생&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;let을 사용할 때&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;블록 안에서만 사용하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이처럼 var의 함수스코프라는 특성과 여러번 안전하게 재선언이 가능하다는 특징은 잘 활용하면 유용하다.&lt;/p&gt;

&lt;h2 id=&quot;a5-tdz&quot;&gt;A.5 TDZ&lt;/h2&gt;

&lt;p&gt;TDZ가 필요한 이유에 대한 절&lt;/p&gt;

&lt;h3 id=&quot;a51-모든-일이-시작된-곳-const&quot;&gt;A.5.1 모든 일이 시작된 곳, const&lt;/h3&gt;

&lt;p&gt;TC39에서는 ES6 개발 초기에 const와 let을 호이스팅 해야할 지 여부를 결정해야했다. 결과적으로 아래와 코드에서 블록 내부에서 일관된 변수만 사용하도록 하기위해 호이스팅 하도록 결정하였다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 호이스팅 되지 않으면 블록 전반부에는 상위 스코프의 변수가, 후반은 새로 선언된 변수가 적용되는 혼란스러운 동작이 발생했을 것이다.&lt;/p&gt;

&lt;p&gt;let과 const가 var 처럼 undefined로 자동 초기화 되지 않는 이유 또한 이러한 호이스팅과 관련있다. 다음과 같은 경우, undefined로 초기화된다면 const는 상위에서는 undefined인데 아래에서는 값이 할당되고 그 이후에는 값이 재할당안되는 비직관적인 동작이 발생했을 것이다. (const는 상수라 변하면 안되는데 변경됨)&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;kevin&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 이유 때문에 let, const는 호이스팅 되지만 값이 없는 시간대가 있고 이 시간대에 변수에 접근할 경우 TDZ 오류를 발생시키자고 하였다&lt;/p&gt;

&lt;h3 id=&quot;a52-곁다리-let&quot;&gt;A.5.2 곁다리 let&lt;/h3&gt;

&lt;p&gt;TC39 는 let 에 const와 마찬가지로 TDZ를 도입하자고 결정하였다. 이는 개발자들로 하여금 변수를 신중하게 사용하고, 변수를 그 변수를 사용하는 코드의 상단에 선언하도록 하여 가독성을 높여 도움이 된다.&lt;/p&gt;

&lt;p&gt;다만 저자의 생각은 다른 것 같다. let은 var와 마찬가지로 동작하는 것이 직관적이라고 생각하는 것 같다&lt;/p&gt;

&lt;h2 id=&quot;a6-동기-콜백도-여전히-클로저일까&quot;&gt;A.6 동기 콜백도 여전히 클로저일까?&lt;/h2&gt;

&lt;h3 id=&quot;a61-콜백이란-a62-동기-콜백&quot;&gt;A.6.1 콜백이란, A.6.2 동기 콜백&lt;/h3&gt;

&lt;p&gt;콜백에는 비동기콜백, 동기 콜백이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;비동기 콜백 : 미래의 어느 시점에 되돌아와 다시 호출하는 함수.&lt;/li&gt;
  &lt;li&gt;동기 콜백 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array.map&lt;/code&gt;의 인자와 같이 당장 호출되는 함수로, 되돌아올 곳이 없음. 콜백보다는 DI, IoC라는 용어가 적합함.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a63-동기-클로저&quot;&gt;A.6.3 동기 클로저&lt;/h3&gt;

&lt;p&gt;동기 콜백의 경우 콜백이 실행되는 위치가 자신이 선언된 스코프이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printLabels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;labelsList&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;renderLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lebel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 동기 콜백에서 외부 스코프의 변수를 참조하더라도 이는 자신의 스코프에서 참조한 것이지 클로저를 통해 접근한 것이 아니다. 따라서 동기 콜백의 경우는 클로저가 형성된다고 보기 어렵다&lt;/p&gt;

&lt;h3 id=&quot;a64-클로저-지연&quot;&gt;A.6.4 클로저 지연&lt;/h3&gt;

&lt;p&gt;커링을 수동으로 적용하면 클로저를 사용할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printLabels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;labelsList&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;renderLabel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;renderTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;forEach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;renderLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;renderTo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createLabel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerText&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lebel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;a7-클래식-모듈-변형&quot;&gt;A.7 클래식 모듈 변형&lt;/h2&gt;

&lt;p&gt;클래식 모듈 패턴 예시&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;StudentList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defineModule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같은 패턴은 나중에 변형해서 사용할 수 있다. 어떤 모듈 로더를 사용하더라도 클래식 모듈의 변형일 뿐이다.&lt;/p&gt;

&lt;h3 id=&quot;a71-내-api는-어디에-있나요&quot;&gt;A.7.1 내 API는 어디에 있나요?&lt;/h3&gt;

&lt;p&gt;위 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;publicAPI&lt;/code&gt;는 따로 객체로 생성하지 않고 return 문에 직접 선언할 수도 있고 이러한 방식이 더 많이 쓰인다. 하지만 저자는 따로 객체로 생성하는걸 선호하는데 이유를 다음과 같이 들었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;publicAPI 라는 이름 자체가 객체의 목적을 명확하게 해주므로 가독성을 높인다&lt;/li&gt;
  &lt;li&gt;publicAPI를 따로 두면 모듈이 살아있는 동안 API에 접근하거나 수정할때 유용하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;a72-amd-비동기-모듈-정의&quot;&gt;A.7.2 AMD (비동기 모듈 정의)&lt;/h3&gt;

&lt;p&gt;RequireJS 를 쓰면 쉽게 구현 가능한 모듈 패턴으로, 몇 년전 인기를 끈 스타일의 모듈이다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;./Students.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;StudentList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;a73-umd&quot;&gt;A.7.3 UMD&lt;/h3&gt;

&lt;p&gt;UMD 는 구체적인 패턴이라기보다 비슷한 형식들의 모음에 가깝다. UMD는 브라우저, AMD 스타일 로더, Node.js 에서 모듈을 읽어올때, 별도의 변환도구 없이 더 나은 상호 운용성을 위해 설계되었다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UMD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// AMD 스타일일 경우&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;amd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
	&lt;span class=&quot;c1&quot;&gt;// Node.js 일 경우&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 독립형 브라우저 스크립트일 경우&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;nama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;definition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;StudentName&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DEF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elems&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;renderList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 15 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-Appendix/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-Appendix/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 8장 모듈 패턴</title>
        <description>&lt;h2 id=&quot;81-캡슐화와-최소-노출의-원칙pole&quot;&gt;8.1 캡슐화와 최소 노출의 원칙(POLE)&lt;/h2&gt;

&lt;p&gt;캡슐화의 목표는 정보(데이터)와 동작(함수)를 한데 묶거나 함께 배치에 공통의 목적을 달성하는 것이다. 이러한 캡슐화는 공통의 목적을 가진 코드 일부분을 별도의 파일로 옮기는 것만으로도 실현할 수 있다.&lt;/p&gt;

&lt;p&gt;캡슐화의 또 다른 목표는 캡슐화된 데이터와 함수의 특정 측면의 가시성을 제어하는 것이다. 캡슐화의 주요 아이디어는 비슷한 코드를 그룹화하고, 공개하고 싶지 않은 세부사항은 접근을 선택적으로 제한하는 것이다. (private, public 등)&lt;/p&gt;

&lt;p&gt;이런 노력을 기울이다보면 자연스럽게 코드를 체계화할 수 있다. 공개/비공개의 경계, 둘의 연결지점이 어딘지 알게되면 개발이 쉬워진다. 데이터와 함수의 과다 노출을 피할 수 있어 높은 품질의 코드도 유지할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;82-모듈이란&quot;&gt;8.2 모듈이란&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;모듈은 관련된 데이터와 함수의 모음이다.  이때 숨겨진 비공개 정보와 공개적으로 접근 가능한 정보가 있는데, 후자를 공개 API라고 한다&lt;/li&gt;
  &lt;li&gt;모듈도 상태를 유지한다. 일부 정보를 장기간 유지하며 해당 정보에 접근하고 이를 업데이트하는 기능도 제공한다.&lt;/li&gt;
  &lt;li&gt;모듈 패턴의 주요 관심사는 느슨한 결합을 통한 모듈화나 기타 프로그램 아키텍처 기술을 통해 시스템 수준의 모듈화를 완전히 수용하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 절에서는 모듈이 아닌 코드패턴과 모듈 패턴을 비교하여 모듈의 특성을 이해해보는 파트&lt;/p&gt;

&lt;h3 id=&quot;네임스페이스-무상태-그룹화&quot;&gt;네임스페이스 (무상태 그룹화)&lt;/h3&gt;

&lt;p&gt;데이터 없이 관련된 함수를 그룹으로 묶는 것은 모듈에서 얘기하는 캡슐화가 아니다. 이런 무상태 함수를 모아둔 것은 네임스페이스라고 한다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;utils&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;cancelEvnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;	
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터구조상태유지그룹화&quot;&gt;데이터구조(상태유지그룹화)&lt;/h3&gt;

&lt;p&gt;데이터와 상태를 묶어도 데이터의 가시성을 제한하지 않으면 POLE 관점에서 캡슐화가 아니다. 이런 경우 모듈보다는 데이터 구조의 인스턴스라고 하는 것이 적합하다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;asd&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;513&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;basd&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;모듈-상태를-가진-접근-제어&quot;&gt;모듈 (상태를 가진 접근 제어)&lt;/h3&gt;

&lt;p&gt;클래식 모듈 (노출식 모듈)로 변경한 모습&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;defineStudent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;asd&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;513&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;basd&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래식 모듈 패턴에서는 함수가 프로퍼티인 객체를 반환할 필요가 없다. 함수를 직접 반환하면 된다. 이로써 클래식 모듈의 정의를 충족한다.&lt;/p&gt;

&lt;p&gt;위처럼 IIFE를 사용하는 것은 모듈 인스턴스를 하나만 생성하는 것으로 싱글턴이라 불린다. 함수를 따로 빼면 모듈 팩토리로 불리며 다중 인스턴스를 생성할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;클래식-모듈-정의&quot;&gt;클래식 모듈 정의&lt;/h3&gt;

&lt;p&gt;클래식 모듈이 되기 위한 필요조건&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;적어도 한 번 이상 실행되는 모듈 팩토리 함수가 외부 스코프에 있어야함&lt;/li&gt;
  &lt;li&gt;모듈의 내부 스코프에는 해당 모듈의 상태를 나타내는 정보가 하나 이상 있어야하고, 이는 외부에서 접근할 수 없어야한다&lt;/li&gt;
  &lt;li&gt;모듈은 하나 이상의 함수를 공개 API로 반환해야한다. 이 함수는 내부 스코프의 숨겨진 상태를 클로저를 통해 보존, 관리한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;83-nodejs의-commonjs-모듈&quot;&gt;8.3 Node.js의 CommonJS 모듈&lt;/h2&gt;

&lt;p&gt;클래식 모듈은 모듈 팩토리 혹은 IIFE를 사용해 정의하고, 다른 코드나 모듈과 함께 하나의 파일에서 묶일 수 있다.
하지만 CommonJS 모듈은 파일 기반이여서 모듈을 만들 때 별도의 파일을 정의해야한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;asd&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;513&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;basd&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;records 와 getName이 모듈의 최상위 스코프에 있지만 전역 스코프는 아니다. 따라서 여기 있는 코드들은 기본적으로 바깥코드에 비공개이다.&lt;/li&gt;
  &lt;li&gt;CommonJS에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module.exports&lt;/code&gt; 를 통해 모듈의 공개 API를 정의한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일부 개발자는 exports 객체를 다음과 같이 바꾸는 습관이 있지만, 이러한 방식은 여러 모듈이 순환적으로 종속되는 경우 예기치 않은 동작이 발생하는 등 몇가지 특이점이 있기에 추천하지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여러개를 동시에 내보내고 싶으면 다음과 같은 방식이 권장된다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;assign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 내보낸 모듈의 인스턴스를 추가하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require()&lt;/code&gt; 메서드를 사용하라&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/path/to/student.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;82&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CommonJs 모듈은 IIFE 모듈 정의 방식과 유사하게 싱글턴 인스턴스처럼 작동한다. 동일한 모듈을 몇번이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require()&lt;/code&gt;로 불러와도 모두 같은 인스턴스에 대한 참조를 얻는다.&lt;/p&gt;

&lt;p&gt;이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require()&lt;/code&gt; 함수를 사용하면 지정된 모듈 파일의 전체 공개 API를 불러온다. 일부만 불러오려면 다음과 같이 해야한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/path/to/student.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/path/to/student.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래식 모듈처럼 CommonJs 모듈 API에서 공개적으로 내보내진 메서드는 내부 모듈 세부 사항에 대한 클로저를 유지한다. 이를 통해 프로그램이 살아있는 동안 모듈 싱글턴의 상태가 유지된다.&lt;/p&gt;

&lt;h2 id=&quot;84-최신-es-모듈&quot;&gt;8.4 최신 ES 모듈&lt;/h2&gt;

&lt;p&gt;기본적으로는 CommonJS와 유사하다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파일 기반&lt;/li&gt;
  &lt;li&gt;모듈 인스턴스는 싱글턴임&lt;/li&gt;
  &lt;li&gt;모든 것은 기본적으로 비공개.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;차이점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파일 상단에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;use strict&quot;&lt;/code&gt;가 없어도 엄격모드로 실행됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module.exports&lt;/code&gt;가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export&lt;/code&gt; 키워드를 사용해 모듈의 공개 API에 특정 내용을 노출함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require()&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt; 키워드를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내보내기를 할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;를 붙여 모듈을 노출하는 형태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기본 내보내기&lt;/code&gt;라고 하며 비교적 간단한 문법으로 import 가능하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;가 붙지 않은 내보내기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기명 내보내기&lt;/code&gt;라고 한다.&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-8%EC%9E%A5-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-8%EC%9E%A5-%EB%AA%A8%EB%93%88-%ED%8C%A8%ED%84%B4/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>State of frontend 2024</title>
        <description>&lt;p&gt;https://tsh.io/state-of-frontend/#data&lt;/p&gt;

&lt;h2 id=&quot;chapter-3-teams--technology&quot;&gt;Chapter 3. Teams &amp;amp; Technology&lt;/h2&gt;

&lt;h3 id=&quot;02-frameworks&quot;&gt;02. Frameworks&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;svelte 는 순풍중인거 같고 vue.js 는 생각보다 잘나가는듯&lt;/li&gt;
  &lt;li&gt;프레임워크는 Astro, Nuxt, Sveltekit, Remix 가 배울만 한거 같고, astro 가 생각보다 잘나가는듯&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;03-libraries&quot;&gt;03. Libraries&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;validation : zod 배워보자&lt;/li&gt;
  &lt;li&gt;date management : date-fns, Day.js, moment 많이 씀. moment는 성능상 단점이 있어 비선호도가 많음&lt;/li&gt;
  &lt;li&gt;state management : React context 를 가장 많이 씀. 그 외로는 zustand가 눈에띔&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;04-data&quot;&gt;04. Data&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;axios, fetch, TanStack Query 등 일반적으로 많이 쓰는게 순위가 높음&lt;/li&gt;
  &lt;li&gt;새로운 툴로는 tRPC 가 유망한듯
    &lt;h3 id=&quot;05-hosting&quot;&gt;05. Hosting&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Vercel이 AWS를 이김&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;07-micro-frontend&quot;&gt;07. Micro frontend&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;micro-frontend 자체를 많이 안쓰는 추세 인듯&lt;/li&gt;
  &lt;li&gt;지식만 갖고 있어보자&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;08-package-manager&quot;&gt;08. Package manager&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;npm 이 제일 많고, yarn/pnpm 이 동등&lt;/li&gt;
  &lt;li&gt;런타임으로 bun 을 사용하는 경우가 많아져서 bun도 많이 쓰는듯 (자체 패키지매니저 기능 탑재)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;09-javascript-runtime&quot;&gt;09. Javascript runtime&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Node가 지배적이고 그 다음이 Bun&lt;/li&gt;
  &lt;li&gt;일시적일 수 있으나 Bun이 생각보다 높은 수치를 보임&lt;/li&gt;
  &lt;li&gt;Deno는 나중에 오를수 있으나 현재는 Bun 보다도 현저히 낮은 수치&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-4-developer--user-experience&quot;&gt;Chapter 4. Developer &amp;amp; User Experience&lt;/h2&gt;

&lt;h3 id=&quot;01-typescript&quot;&gt;01. Typescript&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;대부분 사용중이고, 앞으로도 많이 사용할거라는 전망&lt;/li&gt;
  &lt;li&gt;JS를 대체할거라는 인식이 더 강해짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;03-progressive-web-apps&quot;&gt;03. Progressive Web Apps&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;현재 인기도 유지 ~ 약간 상승 정도로 보는듯&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;04-design-system&quot;&gt;04. Design system&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;shadcn/ui (with tailwind) 가 가장 많이 사용되고, 그 다음은 Material UI&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;05-styling-tools&quot;&gt;05. Styling tools&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Plain CSS &amp;gt; SCSS &amp;gt; Tailwind CSS &amp;gt; CSS Modules &amp;gt; Styled Component&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;06-testing&quot;&gt;06. Testing&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;80% 가까운 사람들이 테스트를 수행한 적이 있음.&lt;/li&gt;
  &lt;li&gt;유닛테스트를 제일 많이 하고, End-to-End UI test랑 Integration test 도 꽤 하는듯&lt;/li&gt;
  &lt;li&gt;테스팅 툴로는 Jest &amp;gt; Cypress &amp;gt; Vitest &amp;gt; Testing Library &amp;gt; Playwright 순으로 많이 사용함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;07-code-management&quot;&gt;07. Code management&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Cursor 써볼만 한듯&lt;/li&gt;
  &lt;li&gt;VSCode 에 copilot 이랑 연계해서 강화했다는데 한번 찾아볼 가치 있어보임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;09-building-tools&quot;&gt;09. Building tools&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;esbuild, vite 조사 + 사용해보기&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 10 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/State-of-frontend-2024/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/State-of-frontend-2024/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 7장 클로저 사용법</title>
        <description>&lt;p&gt;클로저는 최소 노출의 원칙 (POLE)을 기반으로 한다. 변수를 오랫동안 유지해야하는 경우 클로저를 사용하면 변수를 외부 스코프에 두는 대신 더 제한된 스코프로 캡슐화 할 수 있다.&lt;/p&gt;

&lt;p&gt;함수 내부에서 함수 밖 해당 변수에 계속 접근할 수 있어 변수를 더 넓은 범위에서 사용할 수 있는 이점이 있다.&lt;/p&gt;

&lt;h2 id=&quot;71-클로저-관찰하기&quot;&gt;7.1 클로저 관찰하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클로저는 함수에서만 일어나는 함수의 동작이다&lt;/li&gt;
  &lt;li&gt;클로저를 관찰하려면 함수를 반드시 호출해야한다&lt;/li&gt;
  &lt;li&gt;호출한 함수는 해당 함수를 정의한 스코프 체인이 아닌 다른 분기에서 호출되어야한다&lt;/li&gt;
  &lt;li&gt;클로저는 함수 인스턴스에 따라 다르게 생성된다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;seeCloser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printRandom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;님, &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;입니다.`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;seeCloser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;홍철&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 홍철님, 0.123213입니다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;print2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;seeCloser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;지후&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 지후님, 0.1242131입니다.&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 클로저가 없었다면 printRandom은 해당 함수 내 스코프에 있는 변수만 접근가능하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print&lt;/code&gt; 호출 시 ReferenceError가 발생했을 것임. 하지만 클로저가 있기에 에러가 발생하지 않음.&lt;/p&gt;

&lt;p&gt;이렇게 내부 함수가 외부 스코프에 있는 변수를 참조하는 것을 클로저라고 한다.&lt;/p&gt;

&lt;p&gt;이러한 클로저는 렉시컬 스코프에 기반을 두고 있고 컴파일 시 처리되긴 하지만, 실제로 클로저 동작은 실행 시점에 함수 인스턴스에 따라 달라지는 특성을 가진다.&lt;/p&gt;

&lt;h3 id=&quot;화살표-함수의-스코프&quot;&gt;화살표 함수의 스코프&lt;/h3&gt;

&lt;p&gt;화살표 함수에서도 마찬가지로 스코프가 형성되며 클로저가 만들어진다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;seeCloser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;님, &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;입니다.`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;seeCloser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;홍철&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 홍철님, 0.123213입니다.&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;스냅샷이-아닌-라이브-링크&quot;&gt;스냅샷이 아닌 라이브 링크&lt;/h3&gt;

&lt;p&gt;클로저는 값을 저장하는 스냅샷이 아닌 실시간으로 변수에 언제든 접근 가능하도록 관계를 맺어주는 라이브링크이다. 따라서 값을 읽을 뿐 아니라 수정도 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCurrent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hits&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클로저는 감싼 변수와 연결을 맺어주는 것이므로 아래와 같은 동작이 일어날 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;지수&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;님, &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;gret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;한주&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 한주님, hi&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같은 의도치 않은 동작도 일어날 수도 있다. 원래 의도는 각각 0,1,2 를 반환하는 것이었지만 var가 한번만 선언했기에 keeps에 생성된 모든 인스턴스들은 해당 변수와 연결된 것이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keeps&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;keeps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;keepI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;keeps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;keeps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;keeps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 의도치 않은 동작은 setTimeout 등 비동기 함수를 실행할 때 자주 일어난다&lt;/p&gt;

&lt;h3 id=&quot;쉽게-관찰할-수-있는-클로저--ajax-와-이벤트&quot;&gt;쉽게 관찰할 수 있는 클로저 : ajax 와 이벤트&lt;/h3&gt;

&lt;p&gt;이벤트 등 비동기 함수를 등록할때 보통 콜백과 함께 등록하는데, 이때 클로저를 자주 관찰할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;listeanForClicks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; 버튼을 클릭했습니다`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;관찰-가능성-관점에서-클로저의-정의&quot;&gt;관찰 가능성 관점에서 클로저의 정의&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;클로저는 함수가 외부 스코프의 변수를 사용하면서, 그 변수에 접근하지 않은 다른 스코프에서 실행될 때 관찰된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;72-클로저-생명주기와-가비지-컬렉션&quot;&gt;7.2 클로저 생명주기와 가비지 컬렉션&lt;/h2&gt;

&lt;p&gt;클로저는 본질적으로 함수의 인스턴스와 연결되므로, 이 함수를 참조하는 함수가 있는한 변수에 대한 클로저는 지속된다. 함수 참조가 삭제되면 변수에 대한 클로저가 사라지고 변수는 GC 처리된다.&lt;/p&gt;

&lt;p&gt;이러한 특성은 의도치 않은 메모리 사용을 급증시키는 요인이 될 수 있다. 따라서 더이상 필요하지 않은 함수참조를 삭제하는 것은 중요하다 (이벤트핸들러 제거 등)&lt;/p&gt;

&lt;h3 id=&quot;변수-혹은-스코프&quot;&gt;변수 혹은 스코프&lt;/h3&gt;

&lt;p&gt;개념만 따졌을때 클로저는 변수를 기준으로 동작하기에 클로저를 생성하는 함수 내에서 사용하지 않는 변수는 클로저에 포함되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;manageStudentGrades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentRecords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;grades&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentRecords&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getGrades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;addGrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getGrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;grade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sortAndTrimGradesList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;g1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;grades&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addGrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newGrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;newGrades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;sortAndTrimGradesList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;addNextGrade&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;manageStudentGrades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;grade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;grade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;grade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;54&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;addNextGrade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;92&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sortAndTrimGradesList&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addGrade&lt;/code&gt; 에서 사용함으로 클로저에 포함됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grades&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addGrade&lt;/code&gt; 에서 사용하여 클로저에 포함됨&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;studentRecords&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getGrade&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addGrade&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sortAndTrimGradesList&lt;/code&gt;  모두에서 사용하지 않아 클로저에 포함되지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 아래 코드와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt;을 사용하는 경우는 다르다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;storeStudentInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;grade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;witchValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;whichValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;val&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;storeStudentInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;72&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;지희&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;82&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;디버깅을 해보면 id, name, grade 모두 클로저에 포함된다. 이 이유는 아래와 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;클로저는 스코프를 기준으로 형성된다.&lt;/li&gt;
  &lt;li&gt;하지만 현대 JS 엔진 상당수는 최적화를 위해 함수에서 실제로 참조하지 않는 변수는 클로저에서 제외한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt;을 사용하는 경우에는 어떤 변수에 접근할지 결정할 수 없기에 이러한 최적화가 동작하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 최적화는 명세서에 언급도니 동작이 아니다. 따라서 최적화가 항상 동작할거라고 과신하면 안된다. 만약 어떤 큰 값이 클로저 스코프에 포함된다면 수동으로 값을 버리는 것이 안전하다.&lt;/p&gt;

&lt;h2 id=&quot;73-다른-관점&quot;&gt;7.3 다른 관점&lt;/h2&gt;

&lt;p&gt;현재 관점에서 스코프는 함수의 일급값이라는 특성을 기반으로, 함수가 어디로 이동하든 해당 함수를 외부 스코프에 있는 변수와 연결해주는 링크 역할을 한다고 이해할 수 있다&lt;/p&gt;

&lt;p&gt;하지만 여기서 JS는 함수를 참조에 의해 저장되고 참조/복사를 통해 할당/전달된다는 점을 강조하면 이해도가 높아진다.
&lt;img src=&quot;/assets/images/Pasted%20image%2020241211190534.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수 인스턴스는 자신이 생성된 위치에 그대로 있음. 반환된 것은 함수의 인스턴스의 참조.&lt;/li&gt;
  &lt;li&gt;반환된 함수 인스턴스 참조를 통해 다른 곳에 있는 함수를 호출한다고 생각하면, 단순히 렉시컬 스코프만으로 설명할 수 있음.&lt;/li&gt;
  &lt;li&gt;이 관점에서 클로저를 정의하면 클로저는 프로그램의 다른 부분에서 해당 함수 인스턴스 참조가 살아있으면, 그 함수 인스턴스와 전체 스코프 환경 및 스코프 체인을 살아있게 유지하는 마법이라 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기존 모델은 학문적인 관점에서 만들어진 모델이고, 새로운 관점은 실제로 구현할때 어떻게할지에 초점을 맞춘 관점이다. 어떤 모델을 선택하든 관찰가능한 결과는 같다.&lt;/p&gt;

&lt;h2 id=&quot;74-클로저를-사용하는-이유&quot;&gt;7.4 클로저를 사용하는 이유&lt;/h2&gt;

&lt;p&gt;클로저를 기반으로 하는 함수형 프로그래밍 패러다임의 대표적인 기법 두 가지는 “부분 적용”과 “커링”이다. 간략히는 여러 입력이 필요한 함수의 모양일 바꿔서 미리 입력하거나 나중에 입력하는 기법이다. 초기 입력은 클로저를 통해 기억된다.&lt;/p&gt;

&lt;p&gt;클로저를 통해 내부에 정보를 캡슐화하는 함수 인스턴스를 만들면 나중에 입력을 다시 제공할 필요 없이, 정보를 저장한 함수를 다시 사용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;75-정리&quot;&gt;7.5 정리&lt;/h2&gt;

&lt;p&gt;클로저를 이해하기 위한 두가지 모델&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;관찰 관점 : 클로저는 함수가 다른 스코프로 전달되거나 호출될 때에도 외부 변수를 기억하는 함수 인스턴스이다&lt;/li&gt;
  &lt;li&gt;구현 관점 : 클로저는 다른 스코프에서 참조가 전달되고 호출되는 동안 함수 인스턴스와 해당 스코프 환경을 제자리에 보존한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클로저를 사용했을때의 이점&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수 인스턴스가 매번 계산할 필요없이 이전에 결정된 정보를 기억해내어 함수의 효율성을 높인다&lt;/li&gt;
  &lt;li&gt;함수 인스턴스 안에 변수를 캡슐화해 코드 가독성을 개선하고 스코프 노출을 제한하는 동시에 나중에 변수에 있는 정보를 사용할 수 있도록 보장한다. 함수를 호출할때마다 정보를 전달할 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 09 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-7%EC%9E%A5-%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%82%AC%EC%9A%A9%EB%B2%95/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-7%EC%9E%A5-%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%82%AC%EC%9A%A9%EB%B2%95/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>빌드 시스템 없이 프런트엔드 자바스크립트 라이브러리 불러오기</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://junghan92.medium.com/%EB%B2%88-%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%97%86%EC%9D%B4-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-744dc965ece0&quot;&gt;번역&lt;/a&gt;, &lt;a href=&quot;https://jvns.ca/blog/2024/11/18/how-to-import-a-javascript-library/&quot;&gt;원문&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;세가지-종류의-자바스크립트-파일&quot;&gt;세가지 종류의 자바스크립트 파일&lt;/h2&gt;

&lt;p&gt;라이브러리가 제공할 수 있는 3가지 기본 자바스크립트 파일&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클래식 유형. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script src&amp;gt;&lt;/code&gt;로 추가해 바로 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;ES 모듈 (다른 파일에 의존할 수 있음)&lt;/li&gt;
  &lt;li&gt;CommonJS. 빌드 시스템 없이는 브라우저에서 사용할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 라이브러리들은 빌드를 생성해 보통 npm 에 업로드한다. 이 업로드된 파일들 중에 위 세가지 유형이 포함되어있다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클래식 JS 파일
    &lt;ul&gt;
      &lt;li&gt;식별 방법
        &lt;ul&gt;
          &lt;li&gt;가이드에 CDN으로 사용하라는 메세지가 있는 경우&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.umd.js&lt;/code&gt; 확장자&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script src&amp;gt;&lt;/code&gt; 태그에 넣어보고 작동 확인&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ES 모듈
    &lt;ul&gt;
      &lt;li&gt;사용방법
        &lt;ul&gt;
          &lt;li&gt;의존성이 없으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script type=&quot;module&quot; src=...&lt;/code&gt;에 넣고 코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import {...} from ...&lt;/code&gt; 로 불러오기&lt;/li&gt;
          &lt;li&gt;의존성이 있으면 importmap을 만들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import {...} from ...&lt;/code&gt; 사용
            &lt;ul&gt;
              &lt;li&gt;importmap 생성 도구로 JSPM 같은 것이 있음.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://simonwillison.net/2023/May/2/download-esm/&quot;&gt;download-esm&lt;/a&gt; 사용해서 importmap 필요성 제거&lt;/li&gt;
          &lt;li&gt;esbuild 나 다른 ES 모듈 번들러 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;식별방법
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export&lt;/code&gt; 문 찾기&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.mjs&lt;/code&gt; 확장자&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;package.json&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;type&quot;: &quot;module&quot;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CommonJS
    &lt;ul&gt;
      &lt;li&gt;사용방법
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esm.sh&lt;/code&gt; 사용해서 ES 모듈로 변환&lt;/li&gt;
          &lt;li&gt;빌드 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;식별 방법
        &lt;ul&gt;
          &lt;li&gt;코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require()&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module.exports&lt;/code&gt; 찾기&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cjs&lt;/code&gt; 확장자&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;package.json&lt;/code&gt;에서&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 05 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%97%86%EC%9D%B4-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/%EB%B9%8C%EB%93%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%97%86%EC%9D%B4-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>js</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 6장 스코프 노출 제한</title>
        <description>&lt;p&gt;어떻게, 왜 함수와 블록을 사용해 프로그램 내 변수를 다양한 스코프로 구성해야하는지&lt;/p&gt;

&lt;h2 id=&quot;61-최소-노출의-원칙-pole&quot;&gt;6.1 최소 노출의 원칙 (POLE)&lt;/h2&gt;

&lt;p&gt;정보보안분야의 최소 권한의 원칙(POLP)처럼, 변수를 최소한의 블록에만 노출해야한다는 최소 노출의 원칙(POLE)을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 모든 변수를 전역 스코프에 등록하게 되면 아래와 같은 문제가 발생한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이름 충돌&lt;/li&gt;
  &lt;li&gt;예기치 않은 동작 : 어떤 변수가 쓰이면 안되는 곳에서 쓰여져 의도치 않게 값을 변경하거나 사용하게 될 수 있음. 개인 정보를 담고 있는 변수나 함수가 제한을 뚫고 사용될 수도 있음.&lt;/li&gt;
  &lt;li&gt;의도하지 않은 종속성 : 변수/함수가 의도하지 않은 곳에서 사용되면 그 곳에서의 의존성이 생김. 추후 유지보수 시 그곳도 신경을 써야함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 아래와 같이 가능한 좁은 범위로 스코프를 제한 시키는 것이 좋음&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// var 대신 let을 사용해 if문 안에서만 쓰이도록 제한함&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;62-일반함수-스코프에-숨기기&quot;&gt;6.2 일반(함수) 스코프에 숨기기&lt;/h2&gt;

&lt;p&gt;var 나 함수 선언을 숨기기 위해서는 함수 스코프로 감싸는 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;숨기기 전 : cache라는 변수를 어디에서든 접근할 수 있음
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;숨긴 후 : 선언된 함수 스코프 안에서만 접근 가능함
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hideTheCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 표현식으로 감싸서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hideTheCache&lt;/code&gt;라는 이름도 재사용되도록 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hideTheCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})()&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;함수-표현식-즉시-호출하기&quot;&gt;함수 표현식 즉시 호출하기&lt;/h3&gt;

&lt;p&gt;IIFE : 즉시 실행 함수 표현식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;function 표현식 옆에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;을 사용하여 표현된 함수를 바로 실행하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hideTheCache&lt;/code&gt;와 같이 이름을 붙일 수 있고, 익명으로 지정할수도 있다 (익명이 훨씬 흔하다)&lt;/li&gt;
  &lt;li&gt;function 표현식을 단독으로 쓸 수도 있고, 무언가를 반환하여 다른 구문의 일부가 될 수 있지만, 단독으로 쓰일때는 function 표현식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;()&lt;/code&gt;로 감싸야한다. (일관성을 위해 항상 감싸는 것도 좋은 방법이다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IIFE는 온전한 함수이기에, IIFE를 사용하면 함수 경계가 변경되는데 이는 문이나 구조의 동작을 바꿀 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;화살표함수가 아닌 일반 함수 형태로 IIFE를 사용하면 this의 바인딩이 바꾸니다.&lt;/li&gt;
  &lt;li&gt;break, continue는 함수 경계를 넘지 않기에 제어문 안에서 IIFE를 사용하여 IIFE에서 break, continue를 사용한다고 IIFE 밖의 제어문을 통제할 수 있지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;63-블록으로-스코프-지정&quot;&gt;6.3 블록으로 스코프 지정&lt;/h2&gt;

&lt;p&gt;블록은 let, const 같은 블록 스코프 선언을 포함해야할 필요가 있을때만 스코프로 작용한다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// 아직 스코프 생성이 필요하지 않음&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// 이제 스코프가 필요하다고 인지함&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// let i를 위해 스코프를 생성함&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// 여기는 스코프가 아니라 블록일뿐이다.&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 모든 중괄호 쌍이 블록스코프를 생성하는 것은 아니다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체 리터럴 {}, class 정의 시 {}, switch 문의 {} 로는 블록이나 스코프를 정의할 수 없다&lt;/li&gt;
  &lt;li&gt;function의 본문을 감싸는 {}는 블록이 아니라 함수스코프를 생성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;블록 스코프를 지원하는 언어에서 명시적으로 블록스코프를 만드는 것은 POLE을 위해 일반적인 패턴이다. 기본 마인드셋으로 POLE을 따르면 의도치않은 버그를 줄이고, TDZ 위험을 최소화할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;somethingistrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
	
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;어떤 메세지&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;var와-let&quot;&gt;var와 let&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;함수 전체에 걸쳐 필요한 변수는 의도에따라 명확하게 var로 선언해야한다.&lt;/li&gt;
  &lt;li&gt;var을 블록 내에서 선언할수도 있지만, 예외적인 상황을 제외하면 함수 전체에 필요한 변수는 함수 최상위 스코프에서 var로 선언하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;var와 let은 함수/블록 스코프라는 목적에 맞게 사용하는 것이 좋다는게 저자의 의견&lt;/p&gt;

&lt;h3 id=&quot;let의-위치&quot;&gt;let의 위치&lt;/h3&gt;

&lt;p&gt;최상위 함수 스코프에서만 var를 사용하라는 조언을 따르면 다른 선언문에서는 let을 사용해야만 한다. 구체적으로 어디에 let을 사용해야하는지는 스스로 ‘이 변수를 최소한으로 노출시키면서 요구조건을 만족하는 위치는 어디지’하고 질문해보는 것이다.&lt;/p&gt;

&lt;p&gt;처음에는 블록스코프에 선언하였다가 나중에 함수 스코프에 선언해야한다고 알게되면 그때 선언 위치와 키워드를 바꾸면 된다.&lt;/p&gt;

&lt;h3 id=&quot;catch와-스코프&quot;&gt;catch와 스코프&lt;/h3&gt;

&lt;p&gt;catch 절에서 선언된 변수는 catch 절 밖에서 사용할 수 없다는 규칙이 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;outerVar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onlyHere&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;outerVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;123&quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ReferenceError: 'e' is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;catch 절로 선언한 e 변수는 해당 블록으로 블록 스코프가 지정된다.&lt;/li&gt;
  &lt;li&gt;ES2019 부터는 catch 절 선언시 매개변수를 선언하지 않아도 된다. 이때는 블록 스코프를 형성하지 않고 블록으로 처리된다. 이 패턴을 사용하면 불필요한 스코프를 줄여 약간의 성능 향상을 꾀할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;some err&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;64-블록-내-함수-선언-fib&quot;&gt;6.4 블록 내 함수 선언 (FiB)&lt;/h2&gt;

&lt;p&gt;블록 내 함수를 선언하는 패턴은 환경마다 다르게 동작한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;JS 명세서 : ask 는 블록 스코프 안이므로 외부/전역에서는 사용할 수 없어 ReferenceError 예외 발생&lt;/li&gt;
  &lt;li&gt;대부분의 브라우저 : ask 식별자가 존재하지만 if 구문이 실행되지 않아 정의가 되지 않았으므로 실행가능한 상태가 아니기에 TypeError 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이는 브라우저에서 과거에 사용하던 패턴을 지원하기 위해 만든 예외이다. 아래와 같은 패턴이 예시이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[object Array]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 이러한 FiB 패턴은 환경에따라 동작이 다르기에 사용하지 않는 것이 좋다. 함수 선언은 항당 함수의 최상위 스코프에서 하라.&lt;/p&gt;

&lt;p&gt;또한 성능이 약간 떨어지더라도 아래와 같은 패턴을 사용하는 것이 좋다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[object Array]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아니면 아래와 같이 함수 표현식을 블록안에 배치할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;[object Array]&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 02 Dec 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-6%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84-%EB%85%B8%EC%B6%9C-%EC%A0%9C%ED%95%9C/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-6%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84-%EB%85%B8%EC%B6%9C-%EC%A0%9C%ED%95%9C/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 5장 변수의 비밀 생명주기</title>
        <description>&lt;p&gt;변수 선언 위치에 따른 작동 방식의 차이와 사용 여부&lt;/p&gt;

&lt;h2 id=&quot;51-변수-사용-가능-시점&quot;&gt;5.1 변수 사용 가능 시점&lt;/h2&gt;

&lt;p&gt;모든 식별자는 컴파일 타임 때 각자의 스코프에 등록된다. 또 모든 식별자는 자신이 속한 스코프가 생성될 때 해당 스코프의 시작 부분에서 생성된다.&lt;/p&gt;

&lt;p&gt;이렇게 선언은 스코프 아래에 있더라도 스코프 시작부분에서 변수의 가시성이 확보되는 걸 &lt;strong&gt;호이스팅&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;하지만 가시성을 넘어 함수의 경우 실제로 실행이 되기도 하는데, 이는 &lt;strong&gt;함수 호이스팅&lt;/strong&gt; 때문이다. 함수 선언문으로 함수를 선언하면 함수 이름에 해당하는 식별자가 스코프 최상단에 등록되고, 함수 참조로 그 값이 자동으로 초기화된다. 따라서 함수는 스코프 어디서든 호출 가능해진다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 호이스팅, var 호이스팅 모두 블록 스코프가 아닌 가장 가까운 함수 스코프에 등록된다. (함수가 없으면 전역으로)&lt;/p&gt;

&lt;h3 id=&quot;선언문과-표현식에서의-호이스팅-차이&quot;&gt;선언문과 표현식에서의 호이스팅 차이&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TypeError&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;var로 선언한 변수는 호이스팅이 되지만, 스코프가 시작될 때 undefined로 초기화됨. 코드상 할당문에 도달하기 전까지 undefined로 계속 남아있음. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeError&lt;/code&gt;가 난다. (참조는 가능하기에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;는 나지 않음.)&lt;/li&gt;
  &lt;li&gt;함수 선언문의 경우 호이스팅이 되고 해당 함숫값으로 초기화되는 것과는 동작이 다르다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;변수-호이스팅&quot;&gt;변수 호이스팅&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// hi&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;var는 호이스팅되며 undefined로 초기화되기에, 첫번째줄에서부터 값을 할당할 수 있다ㅏ&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;52-호이스팅--비유일-뿐입니다&quot;&gt;5.2 호이스팅 : 비유일 뿐입니다&lt;/h2&gt;

&lt;p&gt;호이스팅은 아래처럼 코드를 재정렬하는 것으로 생각하기가 쉽다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 호이스팅됨&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// hi&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 실제 JS 엔진은 코드를 재정렬하지 않는다. JS 엔진은 앞을 내다보고 선언문을 찾지 못한다. 프로그램의 모든 스코프 경계와 선언문을 정확히 찾는 것은 파싱 과정이다.&lt;/p&gt;

&lt;p&gt;물론 호이스팅을 코드 재정렬로 생각할 수 있다. 이는 이해에 도움을 주지만, 호이스팅은 런타임이 아닌 컴파일 단계에서 일어나는 일임을 기억해야한다&lt;/p&gt;

&lt;h2 id=&quot;53-중복-선언-처리하기&quot;&gt;5.3 중복 선언 처리하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;var 중복 선언 : 두번째 선언이 무시됨&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot; &lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 이해할 수 있음.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 의미 없는 작업&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot; &lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var name;&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var name = undefined;&lt;/code&gt;는 큰 차이가 있다. 만약 후자처럼 선언하였으면 다음과 같이 동작한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 의미 없는 작업&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot; &lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수와 var의 중복선언 : 함수 호이스팅이 변수 호이스팅보다 우선순위가 높음.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 의미 없는 작업&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;function&quot;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;string&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;let 중복 선언 : SyntaxError 발생하며 실행이 안됨. (하나가 let이고 나머지가 var 인 경우도 안됨)
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;let 중복 선언은 기술적으로는 가능하지만 TC39에서 스타일 상 막아놓은 것이다.&lt;/p&gt;

&lt;h3 id=&quot;const-재선언&quot;&gt;const 재선언&lt;/h3&gt;

&lt;p&gt;const도 let과 마찬가지로 동일한 스코프 내 동일 식별자를 사용할 수 없다. 하지만 const는 let과 달리 재선언을 기술적인 이유로 막아놓은 것이다&lt;/p&gt;

&lt;p&gt;const는 변수를 선언할 때 할당도 필요하다. 만약 선언 시 할당을 빼놓으면 다음과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyntaxError&lt;/code&gt;가 발생한다. 또한 재할당도 불가능하다&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// SyntaxError&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 만약 const를 재선언하게 되면 어떤 형식이든 SyntaxError 가 발생한다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// SyntaxError&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// SyntaxError&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name3&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TypeError&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;SyntaxError vs TypeError
SyntaxError 는 프로그램 실행전에 발생하여 프로그램을 실행시키지 않지만, TypeError는 프로그럼 실행 중 발생한다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;반복문&quot;&gt;반복문&lt;/h3&gt;

&lt;p&gt;스코프 규칙 (let으로 생성한 변수 재선언 등)은 각 스코프 인스턴스마다 적용된다.&lt;/p&gt;

&lt;p&gt;반복문에서는 새로운 반복이 시작될 때마다 자체적인 새 스코프가 생성된다. 따라서 다음과 같은 케이스는 let 재선언이 일어나지 않고, 매번 새로운 let을 선언하는 것이고 에러가 발생하지 않는다. (let은 블록 스코프이기에)&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 만약 var로 선언한 경우, var는 함수 스코프이기에 전역스코프에 연결이 되어 재선언은 일어나지 않지만, 재할당이 매번 일어난다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;for문의 경우도 마찬가지인데, for 조건문 안에 있는 변수들도 매번 새로운 스코프에 연결되므로 에러가 발생하지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 조건문 속 let은 매번 새로운 인스턴스와 연결됨.&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;const의 경우도 마찬가지인데, 다만 특정 형태의 for 문에서는 문제가 발생한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 문제 없음&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;keepGoing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;students&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 조건문 속 const는 매번 새로운 스코프와 연결됨&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// TypeError 발생&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 반복문 종료 이후, const 로 선언한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i++&lt;/code&gt;라는 재할당이 발생하기에 에러가 발생하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;54-초기화되지-않은-변수와-tdz&quot;&gt;5.4 초기화되지 않은 변수와 TDZ&lt;/h2&gt;

&lt;p&gt;TDZ : 변수는 존재하지만 초기화되지 않아 어떤 방식으로도 해당 변수에 접근할 수 없는 시간대. 초기화가 이루어지면 TDZ는 종료되고 스코프 내에서 변수를 자유롭게 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;아래와 같은 코드는 프로그램 실행시 ReferenceError가 발생한다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;eil&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;let, const로 선언된 변수는 호이스팅은 되지만, 스코프 맨 위에서 초기화가 발생하지 않기에 에러가 발생하는 것이다. 컴파일러는 프로그램 중간에서 해당 선언을 초기화하는 명령을 내리기에, 이 초기화가 발생하기 전까지는 TDZ에 걸려 변수를 사용할 수 없다.  (엄밀히는 var도 TDZ가 있지만 길이가 0이다.)&lt;/p&gt;

&lt;p&gt;let, const로 선언된 변수도 호이스팅은 되지만, 자동 초기화가 이뤄지지 않는다는 것만 다르다. 호이스팅 되는 것은 아래 코드가 에러를 발생시킨다는 것으로 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;카일&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// TDZ 에러발생&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;지수&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 30 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-5%EC%9E%A5-%EB%B3%80%EC%88%98%EC%9D%98-%EB%B9%84%EB%B0%80-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-5%EC%9E%A5-%EB%B3%80%EC%88%98%EC%9D%98-%EB%B9%84%EB%B0%80-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/</guid>
        
        <category>#study</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 4장 전역 스코프</title>
        <description>&lt;p&gt;JS 프로그램에서 전역스코프는 우리 생각보다 많은 유용한 기능을 제공하며, 여타 스코프와는 다른 미묘한 차이가 있다.&lt;/p&gt;

&lt;p&gt;이번 장에서는 전역스코프가 어떻게 유용한지, JS 호스트 환경에서 전역 스코프는 어디에 있고 어떻게 접근하는지 알아보자&lt;/p&gt;

&lt;h2 id=&quot;41-전역-스코프를-배워야하는-이유&quot;&gt;4.1 전역 스코프를 배워야하는 이유&lt;/h2&gt;

&lt;p&gt;JS 엔진은 분리된 여러 개의 파일을 실행 시점에 하나로 연결시킨다. 이때 브라우저에서 실행되는 어플리케이션은 주로 세가지 방법을 사용한다&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;ES 모듈 : 파일을 하나씩 로딩하여, import 문으로 참조한다. 이때 각 모듈을 서로의 스코프를 공유하지 않고 베타적으로 협력한다&lt;/li&gt;
  &lt;li&gt;번들러 : 모든 파일을 하나로 묶고, 브라우저에는 하나의 파일만 전달한다.
    &lt;ul&gt;
      &lt;li&gt;이때 다양한 빌드 환경을 구축할 수 있는데, 그 중 파일 내용 전체를 래퍼 함수나 유니버셜 모듈 등으로 하나의 스코프 안에 묶도록 해주는 방법도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wrappingOuterScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;moduleOne&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{})()&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;moduleTwo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;two&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wrappingOuterScope()&lt;/code&gt;는 전역 스코프는 아니고 함수 스코프지만 애플리케이션 전체를 아우르는 스코프처럼 작동한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moduleOne&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moduleTwo&lt;/code&gt;는 모듈끼리 협력하기 위해 선언되었다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;전역 스코프 활용 : 파일을 각각 로딩하여 전역스코프를 통해 모듈끼리 협력한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;전역스코프는 이렇게 여러 파일을 모아 협력하는 것만이 아니라 다음 경우에도 사용되며, 프로그램을 풍성하게 하는 여러 기능을 포함한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JS 내장 기능&lt;/li&gt;
  &lt;li&gt;특정 호스팅 환경에서 제공하는 API 사용 시 : console, DOM, 타이머 등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 변수를 전역에 넣는 것은 안되지만, 모든 JS 프로그램이 전역 스코프를 접착제처럼 파일을 모으고 실행한다는 것은 부정할 수 없다&lt;/p&gt;

&lt;h2 id=&quot;42-전역-스코프의-위치&quot;&gt;4.2 전역 스코프의 위치&lt;/h2&gt;

&lt;p&gt;호스팅 환경에따라 전역스코프의 위치에는 차이가 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;브라우저의-창-window-객체&quot;&gt;브라우저의 창, window 객체&lt;/h3&gt;

&lt;p&gt;브라우저는 코드 침입을 최소화하고 전역 스코프가 작동할 때 간섭도 최대한 하지 않는다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 브라우저에 불러오면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;studentName&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello&lt;/code&gt;가 전역 스코프에 선언된다. == 전역 객체의 프로퍼티를 통해 해당 식별자에 접근할 수 있다&lt;/p&gt;

&lt;p&gt;JS 명세서를 근거로는 외부스코프가 전역 스코프이고, studentName은 전역변수가 된다.&lt;/p&gt;

&lt;p&gt;하지만 이런 작동방식이 모든 JS 호스팅 환경에서 보장되는게 아니다. 아래와 같은 예시에서는 전역 변수가 같은 이름의 전역 객체 프로퍼티를 섀도잉할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;카일&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 카일&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 42&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;let으로 변수를 선언하면 전역 변수에는 추가되지만 전역 객체의 프로퍼티엔 추가되지 않고, 이로인해 렉시컬 식별자가 something을 참조할때 전역변수 something을 참조한다.&lt;/p&gt;

&lt;p&gt;이러한 동작은 개발자에게 실수를 일으킬수 있다. 따라서 전역에서는 항상 var를 쓰고, 블록 스코프에서는 let, const를 쓰는 등의 규칙이 필요하다.&lt;/p&gt;

&lt;p&gt;브라우저 JS 전역스코프는 몇몇 순수하지 못한 동작 방식을 가진다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;DOM 요소에 id 속성을 추가하면 전역변수가 자동으로 생긴다. 하지만 이렇게 자동 등록된 변수는 되도록 사용하지 않는 것이 좋다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window.name&lt;/code&gt; 프로퍼티는 window 객체에 사전에 정의된 getter/setter 이다. setter는 어떤 값을 넣든 문자열로 변환시키는 규칙을 가진다. 따라서 아래 코드와 같은 동작이 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 42 string&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;웹-워커&quot;&gt;웹 워커&lt;/h3&gt;

&lt;p&gt;웹 플랫폼 확장 기능으로, JS 프로그램이 돌아가는 메인 스레드가 아닌 별도의 스레드에서 돌아갈 수 있게 해준다. 이때 레이스 컨디션을 방지하기 위해 메인 애플리케이션 스레드와 통신이 제한된다. 따라서 웹 워커 내에선 DOM에 접근할 수 없다.(navigator 등 몇몇 웹 API 제외)&lt;/p&gt;

&lt;p&gt;웹 워커는 메인 JS 프로그램과 다른 프로그램이기에 전역 스코프를 공유하지 않는다. 대신에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self&lt;/code&gt;를 사용하여 전역 객체를 참조할 수 있고, 메인 JS 프로그램과 마찬가지로 var, function 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self&lt;/code&gt;에 자동 등록된다.&lt;/p&gt;

&lt;h3 id=&quot;개발자-도구와-콘솔-repl&quot;&gt;개발자 도구와 콘솔, REPL&lt;/h3&gt;

&lt;p&gt;개발자 도구는 JS 환경을 완전히 재현하지 않는다. 일반 JS 프로그램보다 덜 업격하게 처리하는데, 따라서 일반 JS 프로그램에서는 오류가 났을 코드가 개발자 도구에서는 정상동작하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;이러한 경우 중 스코프와 관련된 예시는 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;전역 스코프의 작동 방식&lt;/li&gt;
  &lt;li&gt;호이스팅&lt;/li&gt;
  &lt;li&gt;가장 바깥 스코프에서 블록 스코프 선언을 할때, 전역 스코프에서 처리되는 것처럼 보이지만 그렇지 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;es-모듈&quot;&gt;ES 모듈&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ES 모듈 파일에서 선언된 최상위 변수는 전역에 추가되지 않는다. 대신 &lt;strong&gt;모듈 범위&lt;/strong&gt;(모듈 전역) 스코프가 된다.&lt;/li&gt;
  &lt;li&gt;모듈 최상위 레벨 스코프에서는 모듈 내 모든 컨텐츠가 함수에 래핑된 것처럼 묶여서 처리되며, 이는 전역 스코프의 하위 스코프가 된다. 따라서 모듈 내에서 전역 변수는 렉시컬 스코프를 통해 접근 가능하다.&lt;/li&gt;
  &lt;li&gt;다만 모듈 내에서 전역 변수, 객체에 접근은 할 수 있지만, 가능한 의존도를 최소화하는 것이 권장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nodejs&quot;&gt;Node.js&lt;/h3&gt;

&lt;p&gt;Node.js  에서는 엔트리 파일을 포함한 모든 JS 파일을 모듈(ES 모듈 혹은 CommonJS 모듈)로 처리한다. 이런 특징은 각 JS 파일이 자체 스코프를 갖도록 한다.&lt;/p&gt;

&lt;p&gt;Node.js 는 각 모듈을 함수로 감싸는데, var/function 선언이 전역 변수로 취급되는 것을 방지하고 함수 스코프에 포함시키기 위함이다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;__dirname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;카일&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 API 식별자는 전역에 있지 않고, 함수 Module에 있는 매개변수처럼 모든 모듈의 스코프에 자동으로 주입된다.&lt;/p&gt;

&lt;p&gt;node.js의 진짜 전역 변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global&lt;/code&gt;로 접근 가능하다. 객체 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global&lt;/code&gt;에 프로퍼티를 추가하면 일단 전역 변수에 접근하는 것처럼 쓸 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;global&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;카일&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;43-globalthis&quot;&gt;4.3 globalThis&lt;/h2&gt;

&lt;p&gt;여러 JS 호스팅 환경마다 전역 스코프 객체에 접근할 수 있는 방법은 다양하나, ES2020 에서 전역 스코프 객체 참조가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;globalThis&lt;/code&gt;로 표준화되었다. 따라서 요즘에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;globalThis&lt;/code&gt;를 참조하면 전역 스코프 객체를 참조할 수 있다. (폴리필을 사용하여 구식 환경도 대응가능함)&lt;/p&gt;

</description>
        <pubDate>Sat, 30 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-4%EC%9E%A5-%EC%A0%84%EC%97%AD%EC%8A%A4%EC%BD%94%ED%94%84/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-4%EC%9E%A5-%EC%A0%84%EC%97%AD%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 3장 스코프 체인</title>
        <description>&lt;p&gt;스코프 체인 : 스코프와 중첩 스코프 사이에 맺어진 연결. 변수 접근 시 사용할 경로가 스코프 체인을 통해 결정된다. 이때 체인은 변수 탐색 경로가 위 혹은 바깥으로만 향하도록 지시 받는다.&lt;/p&gt;

&lt;h2 id=&quot;31-탐색의-진실&quot;&gt;3.1 탐색의 진실&lt;/h2&gt;

&lt;p&gt;우리는 어떤 변수가 어느 스코프에 있는지 상위스코프로 탐색해나간다고 생각하지만, 실제 동작방식은 다르다. 실제로는 컴파일 초기에 이미 어떤 스코프에 있는 변수인지 결정된다. 렉시컬 스코프가 컴파일 초기에 확정되기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 프로그램 실행시 JS 엔진은 변수를 탐색할 필요가 없고, 이미 저장된 정보를 꺼내어 쓰면 되기에 최적화 측면에서 좋다.&lt;/p&gt;

&lt;p&gt;하지만 컴파일 중에 스코프가 결정되지 않는 경우가 있다. 만약 현재 파일에서 접근 가능한 렉시컬 스코프에서 참조가 불가능한 변수가 있을때, 런타임에 다른 파일이 해당 변수를 전역에 선언하였을 가능성도 있다. 따라서 접근 가능한 스코프에 원하는 변수가 선언되었는지 여부는 런타임에 완전히 확정된다.&lt;/p&gt;

&lt;p&gt;선언하지 않은 변수에 대한 참조는 해당 파일을 컴파일 하는 동안에는 스코프가 결정되지 않는다. 런타임에서 결정되는데, 이러한 과정은 변수당 최대 한번만 발생하며 이후 변경되지 않는다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 거친 후에도 스코프가 결정되지 않을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;가 발생한다&lt;/p&gt;

&lt;h2 id=&quot;32-변수-섀도잉&quot;&gt;3.2 변수 섀도잉&lt;/h2&gt;

&lt;p&gt;같은 스코프에 이름이 같은 두 개 이상의 변수가 있으면 안된다. 만약 변수들이 속한 스코프가 다르고 이름이 같은 경우 발생하는 것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;섀도잉&lt;/code&gt;이다. 섀도잉이 발생하면 하위 스코프의 변수가 같은 이름의 상위 스코프의 변수를 가릴수 있다.&lt;/p&gt;

&lt;h3 id=&quot;전역-언섀도잉&quot;&gt;전역 언섀도잉&lt;/h3&gt;

&lt;p&gt;(버그, 가독성 저하를 불러일으키는 코드이기에 사용을 권장하지 않는 방법)&lt;/p&gt;

&lt;p&gt;전역 스코프의 변수를 가린 스코프에서 가려진 전역 변수를 접근할 수 있는 방법이 있다. 렉시컬 식별자 참조가 아닌 다른 방법을 통하면 가능하다.&lt;/p&gt;

&lt;p&gt;전역 스코프에서는 &lt;strong&gt;var로 선언된 변수와 function 키워드로 선언한 함수&lt;/strong&gt;는 전역 객체의 프로퍼티를 통해 접근할 수 있다. 전역 객체는 본질적으로 전역 스코프를 객체로 나타낸 것으로 볼 수 있다. (ex : 브라우저에서 window 객체) (완전히 참인 정보는 아님.)&lt;/p&gt;

&lt;p&gt;따라서 아래와 같이 가려진 전역 스코프의 변수는 아래처럼 전역 객체를 통해 접근할 수 있다&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printStudent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// &quot;name2&quot;&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// &quot;name&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;printStudent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;전역스코프가 아니면 이러한 방법은 통하지 않는다. (+ var, function으로 선언되지 않았으면)&lt;/p&gt;

&lt;h3 id=&quot;복사와-접근은-다르다&quot;&gt;복사와 접근은 다르다&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;lookingFor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;another&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;na&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;keepLooking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;another&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

		&lt;span class=&quot;nx&quot;&gt;another&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;another&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nf&quot;&gt;keepLooking&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;lookingFor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1234&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 3.14&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 1234&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 3.16&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 1234&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keepLooking()&lt;/code&gt; 내부에서 참조한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;another.special&lt;/code&gt;은 매개변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;special&lt;/code&gt;의 복사본이다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keepLooking()&lt;/code&gt;에서 접근한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;special&lt;/code&gt;은 매개변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;special&lt;/code&gt;이 아닌 복사된 변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;special&lt;/code&gt;이다.&lt;/li&gt;
  &lt;li&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keepLooking()&lt;/code&gt;에서는 매개변수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;special&lt;/code&gt;을 재할당할 방법이 없고, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookingFor()&lt;/code&gt;을 호출할때 객체나 배열 등 참조를 넣어도 마찬가지이다. (재할당이 안되고, 객체 프로퍼티를 통해 변경은 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;금지된-섀도잉&quot;&gt;금지된 섀도잉&lt;/h3&gt;

&lt;p&gt;모든 선언 조합이 섀도잉을 만들지않는다. let은 var을 가릴수 있지만 var는 let을 가릴 수 없다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;자바스크립트&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 문제 없음&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;another&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;자바스크립트&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// SyntaxError 발생 &lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;syntaxError가 발생한 이유는 var가 같은 이름을 사용해 let으로 선언한 변수의 경계를 가로지르려고 했기 떄문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;경계 뛰어넘기 금지는 함수 경계를 만났을때는 효과를 발휘하지 못하기에 다음 코드는 정상 동작한다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;another&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;자바스크립트&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;function &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 섀도잉 됨&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;special&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 42&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;33-함수-이름-스코프&quot;&gt;3.3 함수 이름 스코프&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;함수 선언문 (function declaration) : 함수가 호이스팅 됨
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;askQuestion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 표현식 (function expression) : 함수 자체가 호이스팅 되지 않음
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;askQuestion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofTheTeacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 선언문과 함수 표현식의 두드러지는 차이점은 함수 이름 식별자 작동 방식이다. 다음은 기명 함수 표현식이다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;askQuestion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ofTheTeacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;use strict&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ofTheTeacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;ofTheTeacher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// TypeError&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;askQuestion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// function ofTheTeacher() ...&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ofTheTeacher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// ReferenceError&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;askQuestion은 외부 스코프이다&lt;/li&gt;
  &lt;li&gt;ofTheTeacher는 함수 안에 식별자 그 자체로 선언된다. (외부에서는 접근이 안된다)&lt;/li&gt;
  &lt;li&gt;ofTheTeacher는 읽기 전용으로 선언된다 (엄격모드에서는 에러를 발생 시킴)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다만 이는 기명함수표현식일때만이고, 익명 함수 표현식에서는 식별자가 애초에 없다.&lt;/p&gt;

&lt;h2 id=&quot;34-화살표-함수&quot;&gt;3.4 화살표 함수&lt;/h2&gt;

&lt;p&gt;화살표함수는 렉시컬 스코프 관점에서 익명으로 취급된다. 화살표함수는 함수를 참조하는 식별자와 직접 연결되어있지 않는다. 이름을 추론할 수 이지만 기명함수와 똑같이 작동하는 것은 아니다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;askQuestion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;askQuesion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// askQuestion&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스코프 관점에서 화살표함수는 렉시컬 스코프 측면에서 일반함수와 동일하게 동작한다. 익명이라는 특성 외에는 function으로 선언한 함수와 동일한 렉시컬 스코프 규칙을 적용받는다.&lt;/p&gt;

&lt;p&gt;함수 본문을 감싸는 대괄호가 있든 없든 화살표 함수는 별도의 내부 중첩 스코프를 형성하고, 이 중첩 스코프에 선언된 변수들은 일반 함수의 본문 내에 선언한 변수 스코프와 동일하게 작동한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-3%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-3%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 2장 렉시컬 스코프</title>
        <description>&lt;p&gt;컴파일 중 JS 엔진은 스코프의 지도를 완성한다. 이를 렉시컬 스코프라고하며 이때 렉시컬은 컴파일의 첫번째 단계인 렉싱을 의미한다.&lt;/p&gt;

&lt;p&gt;이번 장에서는 스코프를 더 잘 이해하고, 이를 위해 JS 엔진이 프로그램을 처리하는 방법을 살펴보자&lt;/p&gt;

&lt;h2 id=&quot;21-구슬과-양동이&quot;&gt;2.1 구슬과 양동이&lt;/h2&gt;

&lt;p&gt;변수가 어느 스코프에 들어가는지를 구슬이 어느 양동이에 들어가는지로 비유해서 설명함&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스코프는 부모 스코프에 온전히 포함되기에 한 스코프가 두 개의 바깥 스코프에 동시에 포함되는 일은 일어나지 않는다&lt;/li&gt;
  &lt;li&gt;각 변수는 어디에서 정의되었느냐에 따라 들어갈 곳이 결정되며, 어디서 접근가능한지에 따라 결정되지 않는다.&lt;/li&gt;
  &lt;li&gt;선언이 이뤄진 스코프와 동일한 스코프에 있는 변수 참조, 혹은 더 깊은 스코프에 있는 변수 참조는 해당 스코프와 동일한 색이 된다.&lt;/li&gt;
  &lt;li&gt;스코프에 있는 표현식은 자신과 그 위에 속한 스코프에만 접근이 가능하고, 안쪽 스코프는 접근이 안된다. 먼저 자신의 스코프를 먼저 찾고, 없으면 상위 스코프에서 찾는다.&lt;/li&gt;
  &lt;li&gt;이러한 분류는 컴파일 중 일어나며, 탐색또한 이미 컴파일 단계에서 마친 상태이기에 런타임에서 불필요한 탐색이 일어나지 않는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-js-엔진-구성원-간의-대화&quot;&gt;2.2 JS 엔진 구성원 간의 대화&lt;/h2&gt;

&lt;p&gt;컴파일러가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var students = [ ... ]&lt;/code&gt; 을 만났을때는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;스코프 매니저에 students 라는 변수가 있는지 물어봄. 있다고 하면 컴파일러는 선언을 무시함. 없다고 하면 프로그램이 실행될 때 스코프 매니저에게 해당 스코프에 students라는 이름의 변수를 생성해달라고 요청함&lt;/li&gt;
  &lt;li&gt;컴파일러는 프로그램 실행 시점에 엔진이 실행할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;students = []&lt;/code&gt; 할당문에 대한 코드를 생성함. 엔진은 실행시 이 코드를 보고 스코프 매니저에게 students 라는 변수가 있는지 물어봄. 없다고 하면 스코프를 타고 올라가며 찾는다. 이후 변수를 undefined로 초기화해 준비하고, 여기에 배열(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[...]&lt;/code&gt;)의 참조를 할당한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;추가적으로  컴파일러는 함수나 블록 스코프를 만나면 스코프 매니저에게 새로운 스코프를 준비하라고 알린다.&lt;/p&gt;

&lt;h2 id=&quot;23-중첩-스코프&quot;&gt;2.3 중첩 스코프&lt;/h2&gt;

&lt;p&gt;모든 스코프는 한번이든 여러번이든 실행될 때마다 스코프에 해당하는 스코프 매니저 인스턴스를 갖게 된다. 그리고 스코프가 실행될 때마다 자동으로 해당 스코프 내 모든 식별자가 스코프에 등록된다 ( = 호이스팅)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스코프 시작부분에 식별자가 function 선언과 함께 등장했으면 해당 변수는 연관된 함수 참조로 자동 초기화된다&lt;/li&gt;
  &lt;li&gt;식별자가 var로 선언되었다면 해당 변수는 자동으로 undefined로 초기화되어 바로 사용가능한 상태가 된다.&lt;/li&gt;
  &lt;li&gt;var로 선언되지 않았으면 초기화되지 않은 상태(TDZ)가 되어 엔진에 의해 선언 및 초기화가 완전히 끝날때까지 사용할 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 상위 스코프를 계속 탐색했지만 원하는 식별자를 찾지 못하면 오류 발생 상태가 조성된다. 이때는 프로그램이 엄격모드인지 아닌지와 변수의 역할에 따라 오류를 다르게 처리한다&lt;/p&gt;

&lt;h3 id=&quot;undefined에-관한-혼란&quot;&gt;undefined에 관한 혼란&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;변수가 소스 역할을 할때 식별자를 찾지 못하면 해당 변수는 선언되지 않은 변수로 간주되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;를 발생 시킨다.&lt;/li&gt;
  &lt;li&gt;변수가 타깃 역할을 하고 프로그램이 엄격모드일때 해당 변수는 선언되지 않은 변수로 간주되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이때 발생하는 에러는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceError: xxx is not defined&lt;/code&gt; 인데, JS에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not defined&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undefined&lt;/code&gt;는 전혀 다르다.&lt;/p&gt;

&lt;p&gt;undefined는 선언은 되어있는데 (변수는 발견하였는데) 해당 시점에 값이 없는 경우를 뜻하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;는 선언자체가 일어나지 않은 경우다&lt;/p&gt;

&lt;p&gt;하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typeof&lt;/code&gt; 연산자를 사용하면 둘다 똑같이 undefined를 반환하기에 이는 혼란스럽다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// &quot;undefined&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;notExist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// &quot;undefined&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;전역변수의-갑작스러운-등장&quot;&gt;전역변수의 갑작스러운 등장&lt;/h3&gt;

&lt;p&gt;선언되지 않은 변수가 타깃역할을 하고 엄격모드가 아닐때, 타깃 할당이라는 목적을 달성하기 위해 전역 스코프의 스코프 매니저가 돌발적으로 전역 변수를 만들어 버린다.&lt;/p&gt;

&lt;p&gt;이러한 동작은 버그가 발생할 확률이 높기에 엄격모드가 필요한 좋은 예시이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-2%EC%9E%A5-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-2%EC%9E%A5-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet 2부 - 1장 스코프</title>
        <description>&lt;p&gt;JS에서 함수는 일급값이기에 변수에 할당할 수 있고, 다른 곳에 넘길수도 있다. 그런데 다른 곳으로 넘어간 함수 내에서 외부 변수를 사용하는 경우, 해당 변수는 어딘가에 접근해야하므로 JS 에서는 함수를 프로그램 내 어디에서 실행하든 상관없이 함수 정의시 결정된 스코프를 유지한다. 이를 &lt;strong&gt;클로저&lt;/strong&gt;라고 한다&lt;/p&gt;

&lt;h2 id=&quot;12-컴파일-vs-인터프리트&quot;&gt;1.2 컴파일 vs 인터프리트&lt;/h2&gt;

&lt;p&gt;컴파일 : 텍스트 형식으로 작성한 코드를 처리해서 컴퓨터가 이해할 수 있는 작업 지시 목록으로 바꾸는 일련의 과정. 이 과정은 전체 소스코드에 걸쳐 한번만 발생한다.&lt;/p&gt;

&lt;p&gt;인터프린트 : 컴파일처럼 프로그램을 기계가 해석할 수 있는 명령으로 바꾸나, 컴파일과 달리 한줄씩 변환된다.&lt;/p&gt;

&lt;p&gt;JS는 인터프린트 언어로 생각하는 경우가 많고 인터프린트를 거치지만, 컴파일 과정 또한 거친다. 이는 JS 실행 전 필요한 한 과정을 담당한다. 따라서 인터프리터 언어이기도 하지만 컴파일 언어로도 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;13-코드-컴파일&quot;&gt;1.3 코드 컴파일&lt;/h2&gt;

&lt;p&gt;스코프는 주로 컴파일 중에 결정된다. 따라서 스코프를 정복하려면 컴파일과 실행이 어떻게 연관되는지 이해해야한다.&lt;/p&gt;

&lt;p&gt;고전 컴파일러 이론에서는 컴파일러는 주요 세 단계를 거친다고 정의한다&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;토크나이징 / 렉싱&lt;/li&gt;
  &lt;li&gt;파싱 : 토큰 배열을 문법 구조를 반영하는 AST로 바꾼다&lt;/li&gt;
  &lt;li&gt;코드 생성 : AST를 컴퓨터가 실행 가능한 코드로 변환한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;JS엔진은 더 복잡하게 돌아간다. 파싱과 코드 생성 단계에서 최적화를 위해 몇가지 추가작업을 하고, 프로그램 실행 중 컴파일이나 최적화를 다시 할 수도 있다.&lt;/p&gt;

&lt;p&gt;JS 컴파일은 실행 전에 일어나기에 매우 빠르게 완료되어야한다. 따라서 JS엔진은 레이지 컴파일, 핫 리컴파일같은 방법을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;필수-두-단계&quot;&gt;필수 두 단계&lt;/h3&gt;

&lt;p&gt;JS 에서는 파싱과 컴파일이 먼저 일어난 후 실행이 되어야한다. 그렇지 않으면 ECMA 명세서를 지킬 수가 없게 된다.&lt;/p&gt;

&lt;p&gt;만약 컴파일을 먼저하지 않으면 명세서에서 명시된 구문 오류, 초기 오류, 호이스팅을 대응할 수 없다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;구문 오류 : JS는 구문에 오류가 있을때 실행 전에 “SyntaxError”를 발생시킴. 이는 파싱이 실행 전 먼저 일어난다는 뜻&lt;/li&gt;
  &lt;li&gt;초기 오류 : ECMA 명세서에서는 엄격 모드에서 프로그램을 실행할 때, 가이드를 어긴 경우 초기 오류를 낸다. 이또한 파싱이 먼저 일어난다는 것을 알 수 있다&lt;/li&gt;
  &lt;li&gt;호이스팅 : let, const로 선언한 변수를 너무 빨리 접근하면 에러가 발생하며 실행되지 않는데, 이또한 파싱의 증거다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;물론 파싱이 일어나고 컴파일이 일어나지 않을 수는 있다. 하지만 JS 엔진이 파싱을 통해 AST를 만들어놓고, 이를 효율적인 바이너리 코드로 변경하는 컴파일을 하지 않는다는 것은 생각하기 어렵다.&lt;/p&gt;

&lt;p&gt;(저자에 따르면) JS는 일반적인 컴파일 언어와 달리 배포시 컴파일이 필요한 것은 아니지만 실행 전 컴파일이 필요한 것이라고 생각하면 된다&lt;/p&gt;

&lt;h2 id=&quot;14-컴파일러체&quot;&gt;1.4 컴파일러체&lt;/h2&gt;

&lt;p&gt;선언을 제외하고 모든 변수와 식별자는 할당의 타깃이나 값의 소스 중 하나이다. 만약 할당된 값이 있다면 변수는 할당의 타깃일 것이고, 그렇지 않으면 변수는 값의 소스가 된다.&lt;/p&gt;

&lt;p&gt;변수 처리를 위해 JS 엔진은 변수가 나타날때마다 변수 각각에 타깃과 소스라는 역할 이름을 붙인다.&lt;/p&gt;

&lt;h3 id=&quot;할당의-타깃-사례들&quot;&gt;할당의 타깃 사례들&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nx&quot;&gt;students&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1. 단순할당&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;students&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2. 루프가 돌때마다 할당됨&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3. 인자로 할당&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4. 스코프를 구성하는 시점에 할당&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드에서 식별자 getStudentName는 컴파일 타임에 선언되고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;= function(studentId)&lt;/code&gt; 도 컴파일 과정에서 처리된다. getStudentName와 함수의 관계는 할당문이 실행될 때 설정되지 않고, 스코프가 구성되는 시점에 자동으로 설정된다. (함수 호이스팅)&lt;/p&gt;

&lt;h3 id=&quot;값의-소스&quot;&gt;값의 소스&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;students&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1. students에서 값을 가져옴&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;getStudentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2. getStudentName을 참조함&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;studentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 3. 양쪽 다 참조함&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4. console, student 참조함&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-런타임에-스코프-변경하기&quot;&gt;1.5 런타임에 스코프 변경하기&lt;/h2&gt;

&lt;p&gt;스코프는 프로그램이 컴파일 될 때 결정되지만, 런타임 환경에는 영향을 받지 않는다. 하지만 비엄격모드에서는 런타임에서 스코프를 수정할 수 있는 방법이 두가지 있고, 이 두가지는 사용하면 안된다. (두 방법 모두 엄격모드에서는 사용이 불가능하다)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;eval() : eval 에 넘기는 소스코드에 var나 function 선언이 있을 경우 이 선언들은 evel()이 실행중인 스코프를 변경시킨다. eval에는 다른 문제도 있지만, 컴파일과 최적화가 끝난 스코프를 다시 수정하기에 성능 이슈도 있다.
    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;nf&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;var oops = '이런'&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;oops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 이런&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;with 키워드 : 특정 객체의 스코프를 지역 스코프로 동적으로 변환한다. 이 역시 가독성과 성능 측면에서 안좋으니 사용하지 않는 것이 좋다&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bad&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;oops&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;이런&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;with &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;oops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 이런&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;16-렉시컬-스코프&quot;&gt;1.6 렉시컬 스코프&lt;/h2&gt;

&lt;p&gt;이렇게 스코프가 컴파일 타임에 결정되면, 이 스코프를 렉시컬 스코프(어휘 스코프)라고 한다. 이때 렉시컬은 컴파일 과정 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;렉싱&lt;/code&gt;과 관계가 있다.&lt;/p&gt;

&lt;p&gt;이 렉시컬 스코프는 함수나 블록, 변수 선언의 스코프는 전적으로 코드 배치에 따라 제한된다.&lt;/p&gt;

&lt;p&gt;컴파일은 스코프와 변수의 메모리 예약 관점에서 실제로는 아무것도 하지 않는다. (스코프를 생성하지 않는다.) 대신 프로그램 실행에 필요한 모든 렉시컬 스코프가 들어간 지도가 만들어진다. 여기서 렉시컬 스코프가 정의되고, 각 스코프에 해당하는 식별자가 추가된다.&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-1%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EB%B6%80-1%EC%9E%A5-%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>Blob vs File 차이점 이해하기</title>
        <description>&lt;p&gt;https://jsdev.space/file-blob-js/&lt;/p&gt;

&lt;h2 id=&quot;blob&quot;&gt;Blob&lt;/h2&gt;

&lt;p&gt;Blob는 raw binary data (file, images, videos, non-text data 등)를 다루기 위해 주로 사용되는 자바스크립트 불변 객체이다&lt;/p&gt;

&lt;p&gt;특징&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;불변성 : 한번 만들면 수정이 불가능하다. 다른 데이터와 합쳐서 새로운 Blob를 만드는 것은 가능하다&lt;/li&gt;
  &lt;li&gt;Data Representation : 어떤 타입의 데이터도 다룰수 있다. 보통 웹 어플리케이션에서 이진 데이터를 다루기 위해 사용된다&lt;/li&gt;
  &lt;li&gt;size, type 이라는 두가지 속성이 존재한다
    &lt;ol&gt;
      &lt;li&gt;size : blob의 byte 크기&lt;/li&gt;
      &lt;li&gt;type : MIME type&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;다양한 Web API에 사용된다
    &lt;ol&gt;
      &lt;li&gt;File API : 유저가 업로드한 파일을 다룸&lt;/li&gt;
      &lt;li&gt;canvas API : canvas 요소에서 이미지를 생성할 때 사용함&lt;/li&gt;
      &lt;li&gt;Fetch API : 이진데이터를 송수신하는데 사용됨&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Blob 생성 : Blob 생성자로 생성가능
    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new Blob([&quot;hello world&quot;], { type: &quot;type/plain&quot; })&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;file&quot;&gt;File&lt;/h2&gt;

&lt;p&gt;유저의 파일 시스템에서 가져온 파일의 표현방식. Blob의 특수한 형태로 file에 대한 정보를 담고 있음 (name, size, type, mod date). 주로 웹에서 파일 업로드 등을 다룰때 사용한다&lt;/p&gt;

&lt;p&gt;특징&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Blob으로부터 상속됨. 따라서 Blob의 정보 및 파일에 관한 정보가 추가로 들어있음.&lt;/li&gt;
  &lt;li&gt;name, size, type, lastModified, webkitRelativePath 속성 포함
    &lt;ol&gt;
      &lt;li&gt;webkitRelativePath : 디렉터리까지의 상대경로. 보통 디렉터리 내 여러 파일을 선택했을때 사용됨&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;유저가 html input element로 파일을 선택했을때 주로 생성됨.&lt;/li&gt;
  &lt;li&gt;FileReader API 로 데이터를 다룰 수 있다&lt;/li&gt;
  &lt;li&gt;fetch 등을 통해 서버로 보낼 수도 있음.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 24 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/Blob-vs-File-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/Blob-vs-File-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet - 1권 부록</title>
        <description>&lt;h2 id=&quot;appendix&quot;&gt;Appendix&lt;/h2&gt;

&lt;h3 id=&quot;a1-값-vs-참조&quot;&gt;A.1 값 vs 참조&lt;/h3&gt;

&lt;p&gt;다른 언어에서는 값 자체를 할당, 전달할지 값의 참조를 할당, 전달할지 선택할 수 있게 하는 경우가 많다. 하지만 JS에서는 이 과정이 오로지 값의 타입으로만 결정된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원시타입 : 값이 복사됨&lt;/li&gt;
  &lt;li&gt;객체 (객체, 배열, 함수 등) : 참조로 처리됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 작동방식을 변경할 수 있는 방법은 없다&lt;/p&gt;

&lt;h3 id=&quot;a2-다양한-형태의-함수&quot;&gt;A.2 다양한 형태의 함수&lt;/h3&gt;

&lt;p&gt;다음과 같은 함수 표현식은 익명 함수 표현식이라고 한다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;someFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;someFunction&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;JS는 익명함수라 하더라도 자체적으로 이름을 추론한다. 위 예시처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.name&lt;/code&gt; 에 접근하면 추론된 이름을 볼 수 있다. 이를 통해 오류 발생 시 스택 트레이스에서 함수 이름을 통해 오류 위치를 찾을 수 있다&lt;/li&gt;
  &lt;li&gt;하지만 JS의 이름 추론은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt;을 통해 할당한 경우에만 발생하고, 인수를 통해 전달된 익명함수는 추론이 발생하지 않는다. 이때는 name은 빈문자열이 되고, 오류 발생 시 (anonymous function)이라고 뜬다.&lt;/li&gt;
  &lt;li&gt;또한 추론된 이름은 어디까지나 메타데이터일뿐이며 실제 해당 함수를 참조하는 식별자가 아니다. 따라서 익명 함수는 본문 안에서 자신을 참조할 수 있는 식별자를 갖지 못한다. 이는 재귀를 사용하거나, 등록된 이벤트를 해제할때 문제가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래는 기명 함수 표현식이다&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someFunction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;anyFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;someFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;anyFunction&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일 중에 식별자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;anyFunction&lt;/code&gt;과 함수 표현식에 직접적인 연관관계가 생긴다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;someFunction&lt;/code&gt;과의 연관관계는 런타임까지 발생하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대부분 익명함수표현식을 거부감없이 사용한다. 더 짧기 때문이다. 하지만 함수에 의미있는 이름을 붙이는 것이 가독성이 훨씬 더 좋아진다.&lt;/p&gt;

&lt;p&gt;함수 선언방식에는 다른 함수 선언 방식도 있다.&lt;/p&gt;

&lt;h3 id=&quot;a3-강제-조건부-비교&quot;&gt;A.3 강제 조건부 비교&lt;/h3&gt;

&lt;p&gt;조건에 맞는지 아닌지를 판단하기위해 강제 변환이 선행되어야하는 조건부 표현식에 대한 절&lt;/p&gt;

&lt;p&gt;if, 삼항연산자, while/for의 반복문 조건절은 암시적으로 값을 비교한다. 여기에는 타입이 같은지 확인하는 엄격비교가 있고, 강제로 타입을 전환해 비교하는 경우도 있다. 강제 조건부 비교는 이 둘다를 따른다.&lt;/p&gt;

&lt;p&gt;만약 아래와 같은 코드가 있으면&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우리가 생각해야할 멘탈모델은 다음과 같다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;중요한 것은 비교하기 전에 강제 변환이 일어나고, x 는 타입에 상관없이 불리언 값이 된다.&lt;/p&gt;

&lt;h3 id=&quot;a4-프로토타입-클래스&quot;&gt;A.4 프로토타입 클래스&lt;/h3&gt;

&lt;p&gt;3장에서 다룬 프로토타입과 프로토타입 체인을 사용해 객체를 연결하는 방법을, 프로토타입 클래스라고 부른다. ES6에서 클래스 시스템이 등장하기 전까지 프로토타입 클래스는 객체를 연결하는 역할을 했다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Classromm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mathClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Classroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mathClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;hi&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로토타입 클래스 패턴에서는 이러한 방식을 상속이라고 부른다. 이러한 상속은 다음과 같이 정의할 수도 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Classroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Classroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prototype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;welcome&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mathClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Classroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mathClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;hello&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모든 함수는 기본적으로 prototype 이라는 프로퍼티를 통해 빈 객체를 참조한다. 이 프로퍼티는 함수의 프로토타입(프로토타입을 통해 함수와 연결된 객체)과는 다르다. 이 프로퍼티 prototype은 new를 사용해 함수를 호출해 객체를 만들었을때 새롭게 만든 객체의 프로토타입을 설정할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;하지만 이러한 프로토타입 클래스 패턴보다는 ES6의 클래스 매커니즘이 클래스 지향 디자인 패턴에서는 훨씬 더 잘맞는다. (근본에는 동일한 프로토타입 연결장치로 설정되어있음.)&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Classroom&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nf&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;nf&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mathClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Classroom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;mathClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;hello&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 24 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-1%EA%B6%8C-%EB%B6%80%EB%A1%9D/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-1%EA%B6%8C-%EB%B6%80%EB%A1%9D/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet - 4장 더 큰 그림</title>
        <description>&lt;h2 id=&quot;41-첫-번째-기둥-스코프와-클로저&quot;&gt;4.1 첫 번째 기둥: 스코프와 클로저&lt;/h2&gt;

&lt;p&gt;렉시컬 스코프 모델 : 스코프의 기준과 그 경계, 경계 안에서 변수가 어떻게 구성되는지 프로그램을 파싱할때 결정되는 모델. (= 개발자가 스코프를 어디에 배치하냐에 따라 달라지는 모델)&lt;/p&gt;

&lt;p&gt;JS는 렉시컬 스코프 모델을 채택하고 있지만, 여타 언어와 다른 두 가지 특징을 더 갖는다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호이스팅&lt;/li&gt;
  &lt;li&gt;var 로 선언한 변수는 블록이 아닌 함수 기준으로 스코프가 만들어진다는 점&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 두가지 특징이 있지만 JS는 렉시컬 스코프 모델을 사용한다고 할수 있다. 클로저 또한 JS가 함수를 일급객체로 다루는 렉시컬 스코프 모델이기에 자연스레 나온 결과이다.&lt;/p&gt;

&lt;h2 id=&quot;42-두-번째-기둥-프로토타입&quot;&gt;4.2 두 번째 기둥: 프로토타입&lt;/h2&gt;

&lt;p&gt;JS는 클래스를 통해 사전에 구조를 정의하지 않아도 직접적이고 명시적으로 객체를 만들 수 있는 몇 안되는 언어 중 하나이다.&lt;/p&gt;

&lt;p&gt;프로토타입을 사용해 프로토타입 상속이라 불리는 클래스 디자인 패턴을 사용하던 것과 달리, ES6에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; 키워드를 통한 JS를 객체지향/클래스 스타일로 개발하자는 움직임이 생겼다.&lt;/p&gt;

&lt;p&gt;하지만 프로토타입을 사용하면 this 컨텍스트가 공유되면서 두 객체를 아주 간편하게 연결할 수 있고, 함수나 메서드가 실행되는 동안 두 객체를 동적으로 협력하게 할 수 있다. 이렇게 클래스 없이 프로토타입 체인으로 객체가 협력하게 하는 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작동 위임(behavior delegation)&lt;/code&gt;이라고 한다&lt;/p&gt;

&lt;p&gt;이렇게 클래스를 사용하지 않고도 객체만으로도 강력한 패턴을 만들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;43-세-번째-기둥-타입과-타입-강제-변환&quot;&gt;4.3 세 번째 기둥: 타입과 타입 강제 변환&lt;/h2&gt;

&lt;p&gt;최근에는 타입스크립트와 같은 정적 타입 개발을 많이 하지만, JS 에서의 타입과 타입 변환이 어떻게 이뤄지는지도 알아야한다. JS의 본질을 잘 따른다면 정적 타입 도구 없이도 목표한 바를 이룰 수 있다. (자세한 내용은 YDKJSY 4권을 참조하라고 되어있음)&lt;/p&gt;

&lt;h2 id=&quot;44-js의-본질-따르기&quot;&gt;4.4 JS의 본질 따르기&lt;/h2&gt;

&lt;p&gt;이 책 YDKJSY 은 일반적으로 널린 알려진 방식과는 다른 방식을 주장한다. 하지만 이 책에는 명세서를 토대로 가능한 한 사실인 정보를 담았다. 따라서 사실인 정보는 그대로 받아들이되, 필자의 의견인 내용은 잘 생각하고 자신만의 결론에 도달해야한다.&lt;/p&gt;

&lt;p&gt;다만 JS의 본질은 따라야한다. 언어 차원에서 JS가 어떻게 돌아가는지 이해해야 잘 동작하는 부분이 있기 때문이다. 따라서 먼저 JS 고유의 방식을 배우고 습득해야한다. JS에는 이미 성공한 수많은 패턴과 관용구가 있는데 이를 따르는 것이 최선이다.&lt;/p&gt;

&lt;p&gt;물론 이 책을 읽고 프로젝트를 한번에 바꾸려고는 하지마라. 팀원들과 공감대를 형성하고 조금씩 바꿔야한다.&lt;/p&gt;

&lt;p&gt;마지막으로 JS를 학습할때는 가독성 향상에 도움을 주는 방식이 있는지 항상 탐구하라.&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-4%EC%9E%A5-%EB%8D%94-%ED%81%B0-%EA%B7%B8%EB%A6%BC/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-4%EC%9E%A5-%EB%8D%94-%ED%81%B0-%EA%B7%B8%EB%A6%BC/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet - 3장 자바스크립트 뿌리 파헤치기</title>
        <description>&lt;h2 id=&quot;31-이터레이션&quot;&gt;3.1 이터레이션&lt;/h2&gt;

&lt;p&gt;이터레이터 패턴 : 데이터를 일정 단위로 쪼개고, 이 조각들을 차례로 순회하며 점진적으로 처리하는 표준화된 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;처리할 데이터를 참조하는 데이터 구조인 이터레이터가 정의되어야함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next()&lt;/code&gt; 메서드 : 데이터 조각을 차례로 반환하는 메서드
    &lt;ul&gt;
      &lt;li&gt;매 호출마다 value, done 프로퍼티를 제공함.&lt;/li&gt;
      &lt;li&gt;반복작업이 종료되었을 경우 done 은 true로 세팅됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이터레이터 소비자 (consumer)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next()&lt;/code&gt; 메서드 호출&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for...of&lt;/code&gt; 반복문 : ES6에서 추가된 문법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt; : spread syntax, rest parameter 에 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이터러블&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;이터레이터 소비 프로토콜은 순회 가능한 값인 이터러블을 소비하는 기술적인 방법이라고 정의 가능. 이터러블에서 이터레이터 인스턴스를 생성하고, 이 인스턴스를 소비해 연산한다.&lt;/li&gt;
  &lt;li&gt;ES6 에서 이터러블은 문자열, 배열, 맵, 셋 등이 있음&lt;/li&gt;
  &lt;li&gt;기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for...of&lt;/code&gt;로 값을 하나씩 가져와서 소비할수 있으나, JS 내장 인터러블로 조금 다르게 동작할수도 있음
    &lt;ul&gt;
      &lt;li&gt;맵은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for...of&lt;/code&gt; 시 키와 값이 같이 나옴
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for (let [btn, btnName] of buttonNames)&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;keys()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;values()&lt;/code&gt; 로 키 또는 값만 대상으로 소비할 수 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for (btn of buttonNames.keys())&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;배열과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;entries()&lt;/code&gt;를 함께 사용하면 인덱스와 값을 순회할 수 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for (let [idx, val] of arr.entries())&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그 외 이터레이션 프로토콜을 준수하는 자료구조를 직접 만들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for...of&lt;/code&gt; 문을 직접만든 자료구조에 사용하게 만들 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;32-클로저&quot;&gt;3.2 클로저&lt;/h2&gt;

&lt;p&gt;클로저 : 함수가 정의된 스코프가 아닌 다른 스코프에서 함수가 실행되더라도, 스코프 밖에 있는 변수를 기억하고 이 외부 변수에 계속 접근할 수 있는 경우&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수의 타코난 특징이다&lt;/li&gt;
  &lt;li&gt;클로저를 직접 보고 싶으면 함수를 해당 함수가 정의된 스코프가 아닌 다른 스코프에서 실행해야한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;who&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; 님, &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;안녕하세요&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;howdy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;잘 지내시나요&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;카일&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;howdy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;호진&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스코프는 인스턴스마다 생성된다 -&amp;gt; 위 예시에서는 hello, howdy에 각각의 클로저가 있음&lt;/li&gt;
  &lt;li&gt;클로저는 변수 자체와 직접적인 관계를 맺어 변수가 업데이트 되는 것을 관찰하고 최신 값을 가져온다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;클로저의 외부 스코프는 항상 함수여야하는 것은 아니다. 보통 내부 함수에서 하나이상의 외부 스코프 변수를 접근하려할 때 클로저를 볼 수 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buttons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;entries&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nx&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;번째&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;33-this-키워드&quot;&gt;3.3 this 키워드&lt;/h2&gt;

&lt;p&gt;this는 현재 함수의 실행 컨텍스트를 참조하는 키워드이다. 스코프와 달리 실행컨텍스트는 동적이며, 함수를 정의한 위치나 호출위치에 관계없이 호출 방식에 따라 호출할 때마다 결정된다.&lt;/p&gt;

&lt;p&gt;엄격모드에서 실행하지 않으면 컨텍스트를 지정하지 않고 함수를 실행할 경우, 기본 컨텍스트는 전역 객체 (브라우저에서는 window)가 된다.&lt;/p&gt;

&lt;p&gt;다음과 같이 객체의 프로퍼티로 함수를 정의하면 해당 함수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;는 해당 객체가 된다.&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;homework&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;JS&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;assignment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;function &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 다음처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.call&lt;/code&gt; 메서드와 함께 사용하여 컨텍스트를 직접 주입해줄수도 있다&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;homework&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;JS&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;assignment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;assignment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;homework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;34-프로토타입&quot;&gt;3.4 프로토타입&lt;/h2&gt;

&lt;p&gt;프로토타입은 두 객체를 연결하는 연결장치로, 객체가 생성될 때 만들어지고 이 연결장치를 통해 새롭게 생성된 객체는 기존에 존재하는 다른 객체에 연결된다. 프로토타입을 통해 연결된 일련의 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로토타입 체인&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;homework&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;JS&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;homework&lt;/code&gt; 객체에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;이라는 프로퍼티만 존재하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.prototype&lt;/code&gt; 객체를 연결하므로 해당 객체 내에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toString()&lt;/code&gt; 등의 메서드를 사용할수가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체-연결장치&quot;&gt;객체 연결장치&lt;/h3&gt;

&lt;p&gt;객체 프로토타입 연결 장치를 직접 정의하고 싶을 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.create()&lt;/code&gt;를 사용해 객체를 만들면 된다.&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;homework&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;JS&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;otherHomework&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;homework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;otherHomework&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &quot;JS&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;첫번째 인수에는 새롭게 생성할 객체를 어떤 객체와 연결할지 명시한다. 그러면 이 객체와 연결된 새로운 객체가 반환된다&lt;/li&gt;
  &lt;li&gt;위 관계에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;otherHomework&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;homework&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object.prototype&lt;/code&gt; 으로 프로토타입이 연결되어있다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;otherHomework.prototype&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;homework&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;이 상태에서 객체에 새로운 프로퍼티를 생성하면, 프로토타입에 관계 없이 바로 그 객체에 프로퍼티가 추가된다
```js
homework.topic; // “JS”
otherHomework.topic; // “JS”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;otherHomework.topic = “수학” // otherHomework 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt; 프로퍼티가 생성됨
otherHomework.topic; // “수학”&lt;/p&gt;

&lt;p&gt;homework.topic; // “JS”&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
### this 다시 보기

함수를 호출할 때 프로토타입을 통해 발생하는 위임과 this를 함께 다루면 진가가 드러난다

```js
var homework = {
	study() {
		console.log(this.topic)
	}
}

var jsHomework = Object.create(homework)
jsHomework.topic = &quot;JS&quot;
jsHomework.study(); // JS

var mathHomework = Object.create(homework)
mathHomework.topic = &quot;수학&quot;
mathHomework.study(); // 수학
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;homework&lt;/code&gt;가 각 객체와 연결되면서, 각 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;study()&lt;/code&gt; 메서드를 사용할 수 있음.&lt;/li&gt;
  &lt;li&gt;각 객체에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;을 설정해주어 각자의 실행컨텍스트에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;을 추가함.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;homework&lt;/code&gt; 였다면 위와 같은 코드는 불가능하였을 것이다. 상당수의 다른 언어들에서는 실제로 그렇다. 하지만 JS에서는 실행컨텍스트가 동적으로 결정되고, 이는 프로토타입을 통한 위임을 가능하게 만드는 중요한 요소이다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 17 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-3%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%BF%8C%EB%A6%AC-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-3%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%BF%8C%EB%A6%AC-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet - 2장 자바스크립트 조망하기</title>
        <description>&lt;h2 id=&quot;21-파일은-프로그램입니다&quot;&gt;2.1 파일은 프로그램입니다&lt;/h2&gt;

&lt;p&gt;웹사이트 하나, 애플리케이션 하나를 프로그램 하나로 생각하기 쉽지만, JS에서는 파일 각각이 별도의 프로그램이다. 이러한 관점은 오류 처리와 관련이 깊은데, JS는 파일을 프로그램으로 취급하기에 파일 하나에만 오류가 있어도 다음 파일이 처리되지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;독립적인 js 파일을 하나의 프로그램으로 작동시키는 방법은 전역 스코프를 사용해 파일간 상태를 공유하고 공통으로 사용하는 기능을 접근할 수 있도록 만드는 방법뿐이다. 이렇게 전역스코프에서 여러 .js 파일이 조합되면 이 파일들은 런타임에서 하나의 애플리케이션으로서 작동한다&lt;/p&gt;

&lt;p&gt;하지만 어떤 구성을 사용하든 js 파일 하나는 고유한 작은 프로그램이라고 생각해야한다.&lt;/p&gt;

&lt;h2 id=&quot;22-값&quot;&gt;2.2 값&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;JS에 값은 원시타입과 객체타입으로 구분된다. 원시타입과 객체타입은 변수에 할당하거나 넘길때 동작 차이가 있다. (값 vs 참조)&lt;/li&gt;
  &lt;li&gt;null, undefined를 구분없이 사용하는 경향이 있지만, 비어있는 값을 나타날때는 undefined를 사용하는 것이 가장 안전하다&lt;/li&gt;
  &lt;li&gt;원시타입으로는 심볼도 존재한다. 심볼은 사람이 추측할 수 없게 만든 특수한 숨김 값이며, 객체에서 특정한 키를 만들때 주로 사용한다. 하지만 보통 개발자가 직접 사용하는 일은 적고, 라이브러리 등 저차원 코드에서 주로 사용한다.
    &lt;ul&gt;
      &lt;li&gt;ex) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hitchhikerGuide[Symbol(&quot;삶의 의미&quot;)]&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;배열은 특수한 유형의 객체이며, 객체 내 정렬된 데이터에는 숫자 인덱스가 매겨진다.&lt;/li&gt;
  &lt;li&gt;배열에는 원시타입, 객체타입 상관없이 모든 타입의 값이 들어갈 수 있다. 함수도 값이기에 들어간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;객체&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;배열보다 일반적인 데이터 타입으로, 정렬되지 않은 키-값 쌍을 모아놓은 컬렉션이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;값의 타입&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typeof&lt;/code&gt; 키워드를 사용해 원시타입값과 객체 타입값을 구분한다&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typeof null&lt;/code&gt;은 “object”를 반환하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;typeof function(){}&lt;/code&gt; 은 “function”을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;23-변수-선언과-사용&quot;&gt;2.3 변수 선언과 사용&lt;/h2&gt;

&lt;p&gt;JS에서 값은 리터럴 값으로 표현하거나 변수에 담긴채로 다뤄진다.&lt;/p&gt;

&lt;p&gt;변수를 사용하려면 먼저 변수 선언(생성)이 선행되어야한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;var, let : var는 함수 스코프, let은 블록 스코프&lt;/li&gt;
  &lt;li&gt;const : 블록스코프, 선언하는 순간에 값 할당해야하며 값 재할당 불가능
    &lt;ul&gt;
      &lt;li&gt;다만 재할당이 안되지, 변경은 가능하다. 따라서 객체를 할당하면 그 객체 내 값들은 변경할 수 있어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;24-함수&quot;&gt;2.4 함수&lt;/h2&gt;

&lt;p&gt;JS 에서 함수는 프로시저를 프로그램에 녹여낼 수 있도록 해야한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로시저 : 한번 이상 호출할 수 있고, 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JS에서는 함수를 다음과 같이 만들 수 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수 선언문 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function someFunction(paramter) {...}&lt;/code&gt; 와 같은 형태로 생성
    &lt;ul&gt;
      &lt;li&gt;함수와 식별자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;someFunction&lt;/code&gt;)와의 관계는 컴파일 단계에서 맺어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 표현식 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var someFunction = function() {...}&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;함수 식별자와 함수가 코드를 실행하기 전까지 관계가 맺어지지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JS에서 함수는 할당 가능하고, 어디든 전달 가능한 값이다. 이는 함수형 프로그래밍을 지원하는 언어에서는 필수적인 스펙이다. 함수는 값이므로 객체의 프로퍼티로 사용할 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;25-비교&quot;&gt;2.5 비교&lt;/h2&gt;

&lt;p&gt;JS에서 같음을 비교할때는 “정확하게” 일치하는냐와 “아주 유사”, “교환 가능”을 비교할때도 있다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일치 비교&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동등 비교&lt;/code&gt;의 차이를 알고 있어야한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;===&lt;/code&gt;(일치연산자)은 대부분의 상황에서는 값과 타입을 함께 비교하여 예상 가능하게 동작한다. 하지만 다음 두 경우에서는 예상과 다르게 작용한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NaN === NaN = false&lt;/code&gt; : 대신 Number.isNaN() 사용&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 === -0 = true&lt;/code&gt; : 대신 Object.is() 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 원시 타입이 아닌 객체끼리 비교할때는 참조를 비교하기에 예상과 다르게 동작할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1,2,3] === [1,2,3] = false&lt;/code&gt;
참조는 독자성을 가지기에 객체 구조가 같은지 비교하는 방법은 직접 코드를 짜는 방법밖에 없다. 하지만 이경우에도 함수를 가진 객체끼리 비교할때, 함수끼리 비교할때는 난이도가 복잡해진다. (또한 클로저 등은 고려할 수 없음)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;강제변환&quot;&gt;강제변환&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt;(동등연산자)는 피연산자가 다른 타입일경우 비교 이전에 타입을 강제변환한 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;===&lt;/code&gt;와 동일하게 비교한다.(&lt;strong&gt;흔히들 오해하는 타입을 고려하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;===&lt;/code&gt;과는 다른 방식임&lt;/strong&gt;) 이때 타입 강제 변환은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 등에서도 일어난다.&lt;/p&gt;

&lt;p&gt;비교연산자의 강제 변환은 다음과 같이 이루어진다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;피연산자가 모두 문자열인 경우 : 알파벳순으로 문자열 비교&lt;/li&gt;
  &lt;li&gt;그 외 : 숫자 타입으로 변환해 비교 진행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;강제 조건부 비교 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삼항연산자&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; 등의 조건절에서 일어나는 비교&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if(x)&lt;/code&gt; =&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if(Boolean(x) === true)&lt;/code&gt;로 변환해서 비교됨. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = &quot;asdasd&quot;&lt;/code&gt; 인 상황에서는 해당 조건절이 실행된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;26-코드-구조화-패턴&quot;&gt;2.6 코드 구조화 패턴&lt;/h2&gt;

&lt;p&gt;JS 생태계에서 코드 구조화 패턴은 크게 클래스와 모듈이 있다.&lt;/p&gt;

&lt;h3 id=&quot;클래스&quot;&gt;클래스&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;클래스는 데이터와 해당 데이터를 조작하는 동작이 포함된다.&lt;/li&gt;
  &lt;li&gt;클래스는 구체적인 값이 아니며, 사용하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; 키워드를 통해 인스턴스를 만들어야한다.&lt;/li&gt;
  &lt;li&gt;상속과 다형성을 통해 데이터를 체계적으로 구성할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;모듈&quot;&gt;모듈&lt;/h3&gt;

&lt;p&gt;클래식 모듈&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최소한 한 번 이상 실행되는 외부 함수로, 모듈 인스턴스 내부의 숨겨진 데이터를 대상으로 작동하는 함수가 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인스턴스&lt;/code&gt;를 반환 한다.&lt;/li&gt;
  &lt;li&gt;모듈 팩토리라고 설명하기도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Publication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;pubDate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`제목 : &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, 저자 : &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;auhor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, 발행일 : &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pubDate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;publicAPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;클래스에서는 내부 데이터에 접근하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;를 사용해야하지만, 모듈에서는 스코프내 식별자 역할을 하는 변수를 사용해 메서드와 데이터에 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;(자바스크립트의) 클래스는 인스턴스의 메서드, 데이터가 모두 외부에 공개되지만, 모듈에서는 원하는 것만 객체에 담아 반환할 수 있다&lt;/li&gt;
  &lt;li&gt;현재도 AMD, UMD, CommonJS 를 사용해 작성한 JS 프로그램에서 흔하게 발견되지만 호환성이 떨어져 자주 사용되진 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ES 모듈&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ES6 에서 도입된 모듈 시스템&lt;/li&gt;
  &lt;li&gt;클래식 모듈과의 차이점
    &lt;ul&gt;
      &lt;li&gt;ES 모듈에는 모듈을 정의하는 래핑 함수가 없다. 파일이라는 맥락에서 구현된다. (ES 모듈 파일 하나가 모듈 하나)&lt;/li&gt;
      &lt;li&gt;ES 모듈을 사용할 때 모듈 API와 직접 상호작용하지 않는다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export&lt;/code&gt; 를 통해 원하는 메서드, 변수만 외부에 공개할 수 있다&lt;/li&gt;
      &lt;li&gt;인스턴스화하지 않아도 import 키워드를 통해 가져오면 단일 인스턴스처럼 사용할 수 있다
        &lt;ul&gt;
          &lt;li&gt;한번 import 해서 가져오면 인스턴스가 생기고, 다른 곳에서 다시 import 하면 만들어진 인스턴스의 참조만 가져온다. -&amp;gt; 사실상 싱글턴&lt;/li&gt;
          &lt;li&gt;여러개의 인스턴스를 만들고 싶다면 클래식 모듈이나 클래스를 export하면 됨. (클래식 모듈이 좀 더 권장됨)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 04 Nov 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A1%B0%EB%A7%9D%ED%95%98%EA%B8%B0/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-2%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A1%B0%EB%A7%9D%ED%95%98%EA%B8%B0/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>You don't know JS Yet - 1장 자바스크립트</title>
        <description>&lt;h2 id=&quot;12-자바스크립트-이름의-유래&quot;&gt;1.2 자바스크립트 이름의 유래&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자바스크립트는 마케팅 차원에서 지어진 이름으로, 당시 자바 개발자들에게 어필하기 위한 목적으로 “가벼운 프로그램”이라는 뜻으로 유행한 “스크립트”라는 단어를 합쳐 만들어짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;13-명세서&quot;&gt;1.3 명세서&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TC39 : JS를 관리하는 기술 운영 위원회로 JS의 공식 명세를 관리함&lt;/li&gt;
  &lt;li&gt;TC39는 정기적인 회의를 통해 명세 변경사항을 합의하고 ECMA에 제출한다&lt;/li&gt;
  &lt;li&gt;TC39의 제안은 5단계로 나뉘며, 누군가가 새로운 명세를 제안하면 TC39 위원 중 한명이 이를 0단계에 올리면서 시작된다&lt;/li&gt;
  &lt;li&gt;JS에는 버전이 없고, 표준 JS는 단 하나이다. 다만 브라우저 엔진별로 명세서 개정안을 반영하는 시기가 다를뿐, 규칙을 어겨서는 안된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;js를-지배하는-웹&quot;&gt;JS를 지배하는 웹&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;JS가 가장 많이 사용되는 분야는 웹이다&lt;/li&gt;
  &lt;li&gt;명세서가 개정되지만 이 개정안이 기존 브라우저 엔진에서 실행되던 JS의 작동방식과 다른 경우가 발생하기도 한다.&lt;/li&gt;
  &lt;li&gt;JS 엔진 제조사들이 오류없이 웹 콘텐츠를 보여주기위해 에지 케이스를 다루는 기능을 자체적으로 추가하였고, 브라우저 제조사들은 새로운 개정안이 엔진과 맞지 않을 경우 새로운 개정안을 반영하지 않는 경우가 있기 떄문이다&lt;/li&gt;
  &lt;li&gt;이러한 상황이 발생하면 TC39 위원회는 종종 기존 결정을 취소하고 새로운 명세서를 작성하여 웹에 맞춘다(ex : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contains()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;includes()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flatten()&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;flat()&lt;/code&gt;). 하지만 기존 결정을 유지하는 경우도 있다.&lt;/li&gt;
  &lt;li&gt;이러한 문제로 인해 실제 ECMAScript 명세서와 웹에서 돌아가는 JS 사이에 차이가 존재하는 경우가 있는데, 이는 이책의 부록 B에 실려있다
    &lt;ul&gt;
      &lt;li&gt;웹에서는 쓰이지만 명세서에는 등재되지 않는 JS, 모든 엔진에서 실행되지만 결과는 다른 문법 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;js지만-js는-아닌-웹-전용-문법&quot;&gt;JS지만 JS는 아닌 웹 전용 문법&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alert()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch()&lt;/code&gt; 등은  명세서에 등재된 문법이 아니라 웹 또는 엔진에서 자체적으로 추가한 API 이다.&lt;/p&gt;

&lt;h3 id=&quot;모든-코드가-js-인-것은-아니다&quot;&gt;모든 코드가 JS 인 것은 아니다&lt;/h3&gt;

&lt;p&gt;개발자 도구의 콘솔이나 Node.js의 REPL 은 JS 환경이라는 가정하에 사용되지만, JS의 프로그램 처리 방식을 항상 엄격하게 준수하지는 않는다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러 줄을 입력할때 호이스팅 작동 방식&lt;/li&gt;
  &lt;li&gt;“전역 스코프” 최상위 레벨에서 let, const로 변수 여러 개를 선언했을 때 작동 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;따라서 콘솔에 나타난 결과가 JS 문법을 지키더라도 결과를 신뢰하진 마라. 자세한 내용은 명세를 읽고, 개발자 도구는 JS에 우호적인 별도의 환경이라고 이해하라.&lt;/p&gt;

&lt;h2 id=&quot;14-js의-다양한-얼굴&quot;&gt;1.4 JS의 다양한 얼굴&lt;/h2&gt;

&lt;p&gt;프로그래밍에서 패러다임이란 코드를 어떻게 구조화할지에 대한 접근 방식과 사고방식을 의미한다. 하나의 패러다임에는 여러 스타일이나 형식이 있고 이는 프레임워크, 라이브러리로 나타난다.&lt;/p&gt;

&lt;p&gt;JS는 다중 패러다임언어로 절차적, 객체지향, 함수형 스타일 코드 모두를 작성할 수 있다. 심지어 한 프로그램 안에서 여러 패러다임을 사용할 수 있다&lt;/p&gt;

&lt;h2 id=&quot;15-하위-호환성과-상위-호환성&quot;&gt;1.5 하위 호환성과 상위 호환성&lt;/h2&gt;

&lt;p&gt;JS는 하위 호환성을 보장한다.&lt;/p&gt;

&lt;p&gt;하위 호환성은 한 번이라도 유효한 JS 문법으로 인정되면 명세서가 변경되더라도 절대 그 유효성이 깨지지않는 것을 의미한다. 따라서 1995년에 작성된 JS 코드는 현재도 무조건 작동하는 것을 보장받는다. 따라서 JS 개발자들은 브라우저 버전이 업데이트 되어도 자신의 코드가 동작한다고 믿을 수 있다&lt;/p&gt;

&lt;p&gt;하지만 하휘 호환성을 깨는 결정을 할때가 있는데, 이때는 브라우저로 수집한 정보를 바탕으로 하위 호환성을 깼을때 발생할 부수 효과를 판단하고, 그 근거로 투표를 통해 결정한다.&lt;/p&gt;

&lt;p&gt;상위호환성은 구형 엔진에서 새로운 명세서를 대응하는 것을 의미하며, JS는 상위 호환성은 보장하지 않는다. 하지만 이러한 상위 호환성을 갖추려는 노력은 지속되어, 바벨 등 트랜스파일러를 통해 과거 문법으로 변환하는 식으로 대응하거나 폴리필을 사용한다.&lt;/p&gt;

&lt;p&gt;이러한 트랜스파일러, 폴리필의 사용으로 개발자는 최신 문법을 사용한 클린한 코드를 짜는데 집중하고, 상위 호환성은 도구에 맡길 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;16-인터프리터-이해하기&quot;&gt;1.6 인터프리터 이해하기&lt;/h2&gt;

&lt;p&gt;인터프리터나 스크립트 언어로 작성된 프로그램은 위에서 한줄씩 코드가 실행되는 방식으로 만들어지며, 코드 실행 전에 거치는 단계가 없다. 또한 만약 다섯번째 줄에 에러가 있다면 네번째 줄을 실행할 때까지는 에러를 발견 못하고, 다섯번째 줄을 실행할 때 에러가 발생한다.&lt;/p&gt;

&lt;p&gt;반면에 컴파일 언어는 실행 전 파싱, 컴파일 단계를 거치며 이 단계에서 오류를 발견할 수 있다. 일반적으로 파싱을 거치는 언어는 컴파일 단계까지 수행 후 실행 가능한 파일을 생성한다.&lt;/p&gt;

&lt;p&gt;JS는 어떨까?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;JS는 실행 전에 파싱을 거친다. 명세서에서는 중복 매개변수 등 정적으로 탐지 가능한 초기 오류를 프로그램 실행 전에 찾아야한다고 작성되어있고, 실제로 파싱을 실행하여 이러한 오류를 잡는다.&lt;/li&gt;
  &lt;li&gt;또한 컴파일도 거치는데, 파싱이 완료되면 JS는 최적화된 이진 코드로 변형되어 JS VM에서 실행된다.&lt;/li&gt;
  &lt;li&gt;JS 엔진은 심지어 파싱 이후 생성된 코드를 다양한 방법으로 실행 전에 그때그때(JIT) 처리 및 최적화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면 JS는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;개발자가 작성한 코드를 바벨이 트랜스 파일하고, 번들링된 후 JS 엔진에 전달된다.&lt;/li&gt;
  &lt;li&gt;JS 엔진은 코드를 파싱해 추상 구문 트리(AST)로 바꾼다&lt;/li&gt;
  &lt;li&gt;이후 AST를 이진 바이트 코드로 바꾼다. 이 과정에서 JIT 컴파일러가 작동한다.&lt;/li&gt;
  &lt;li&gt;JS VM이 프로그램을 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이러한 과정을 거치기에 저자는 JS가 컴파일 언어로 생각한다. 따라서 개발자가 이상한 문법을 입력하는 등 실수가 있더라도 코드 실행 전에 미리 발견할 수 있다는 특징이 있다.&lt;/p&gt;

&lt;h3 id=&quot;웹-어셈블리&quot;&gt;웹 어셈블리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ASM.js : JS의 부분집합으로, 일반적인 JS 코드와 스타일과 달리 일관성있는 타입 시스템을 사용하기에 성능 최적화가 매우 뛰어남. C 등의 언어로 작성한 코드를 트랜스파일한 것이므로 생성 과정에서 타입 관련 주석이 자동으로 붙는다.&lt;/li&gt;
  &lt;li&gt;WASM (웹어셈블리) : JS가 주력이 아닌 개발자도 JS 엔진에서 돌아가는 코드를 쉽게 작성할 수 있게 해주는데 목적이 있고 이는 ASM.js 철학과 비슷하지만, ASM.js와 달리 파싱 및 컴파일 과정이 필요없다
    &lt;ul&gt;
      &lt;li&gt;성능 향상을 위해 만들어졌으며, JS가 아닌 언어로 만들어진 프로그램을 웹에서 실행시키고자 하는 움직임도 있다.&lt;/li&gt;
      &lt;li&gt;요즘은 웹하고는 직접적 연관이 없고, 프로그램을 컴파일 한 후 다양한 환경에서 실행할 수 있는 크로스플랫폼 가상 머신으로 발전하고 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;17-엄격모드&quot;&gt;1.7 엄격모드&lt;/h3&gt;

&lt;p&gt;ES5에서 추가된 메커니즘으로 파일 또는 함수의 시작부분에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;use strict&quot;;&lt;/code&gt;를 작성하여 표시할 수 있다.&lt;/p&gt;

&lt;p&gt;엄격모드는 비엄격모드에서 발생할 실수를 초기 오류의 형태로 미연에 찾아주는 등 이득이 크다, 하위호환성과 기존 코드에 기반한 관성때문에 아직 선택 사항으로 남아있다.&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Oct 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-1%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/You-don't-know-JS-Yet-1%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/</guid>
        
        <category>study</category>
        
        
        <category>study,</category>
        
        <category>YDKJSY</category>
        
      </item>
    
      <item>
        <title>나중에 볼 아티클들</title>
        <description>&lt;ul&gt;
  &lt;li&gt;https://frontendmasters.com/blog/patterns-for-memory-efficient-dom-manipulation/
    &lt;ul&gt;
      &lt;li&gt;dom 조작 시 성능 개선이 필요할때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 27 Oct 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/%EB%82%98%EC%A4%91%EC%97%90-%EB%B3%BC%EB%A7%8C%ED%95%9C-%EC%95%84%ED%8B%B0%ED%81%B4%EB%93%A4/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/%EB%82%98%EC%A4%91%EC%97%90-%EB%B3%BC%EB%A7%8C%ED%95%9C-%EC%95%84%ED%8B%B0%ED%81%B4%EB%93%A4/</guid>
        
        <category>#study</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>웹 페이지가 로드되기 전에 더 빠르게 만드는 방법</title>
        <description>&lt;p&gt;https://ykss.netlify.app/translation/how_to_make_your_web_page_faster_before_it_even_loads/&lt;/p&gt;

&lt;p&gt;보통 성능 개선을 할때는 FCP, LCP, INP 등 페이지가 로드 되고 난 이후의 성능을 고려한다.
이 아티클에서는 페이지가 로드되는 것까지 성능 개선을 어떻게 할 수 있을지에대해 다루었다&lt;/p&gt;

&lt;h2 id=&quot;웹-페이지가-로드되기-전에-하는-일&quot;&gt;웹 페이지가 로드되기 전에 하는 일&lt;/h2&gt;

&lt;p&gt;window.performance 를 통해 로드와 관련된 성능 지표를 확인할 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저 캐시 : HTTP GET 을 통해 리소스를 가져오면 브라우저는 먼저 HTTP 캐시를 확인한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;domainLookupStart&lt;/code&gt; -  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetchStart&lt;/code&gt;  가 캐시를 가져오는 시간이며 0이 아닌경우 느린 브라우저를 사용하거나 브라우저 캐시를 오랜 기간 지우지 않는 유저일 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;브라우저 DNS : IP 주소를 찾는데 걸리는 시간 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;domainLookupEnd&lt;/code&gt; - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;domainLookupStart&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;브라우저 연결 : 브라우저가 웹 서버에 연결하는 시간 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectEnd&lt;/code&gt; - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectStart&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;브라우저 TLS/SSL : HTTPS로 연결할 경우 암호화 연결을 맺는 시간. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectEnd&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectStart&lt;/code&gt; 사이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secureConnectionStart&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;HTTPS 미사용이거나 HTTP persistent connection 상태일경우 0일수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;브라우저 요청 : 리소스 요청을 공식적으로 시작하는 시간 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;requestStart&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;브라우저 응답 : 브라우저가 콘텐츠의 첫번째 바이트를 수신하는 시간&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;각-이벤트를-더-빠르게-할-수-있을까&quot;&gt;각 이벤트를 더 빠르게 할 수 있을까?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저 캐시 : 사용자가 스스로 브라우저 캐시를 관리해야하는 부분임. 개발자가 관여할 수는 없다&lt;/li&gt;
  &lt;li&gt;DNS 조회
    &lt;ul&gt;
      &lt;li&gt;전세계에 분산된 DNS 제공업체에 투자하거나, DNS 레코드의 TTL 시간을 최대한 높게 설정함으로써 빠르게 할 수 있음&lt;/li&gt;
      &lt;li&gt;다만 TTL 시간이 길면 메인 서버가 다운되고 백업 서버로 운영해야할때 TTL 시간만큼 변경이 늦어질 수 있다. DNS 조회는 일반적으로 빠르므로 이러한 단점을 감수할만큼 효과가 없을 수도 있다&lt;/li&gt;
      &lt;li&gt;서드파티 리소스의 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rel=&quot;dns-prefetch&quot;&lt;/code&gt; 속성을 주어 dns 를 미리 조회하게해서 속도를 개선할 수 있다. (자신의 도메인을 대상으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dns-prefetch&lt;/code&gt;를 사용하지마라)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;브라우저연결, TLS 연결
    &lt;ul&gt;
      &lt;li&gt;TLS 연결은 이미 잘 최적화가 되어있다. 다만 서드파티리소스에 대해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rel=&quot;preconnect&quot;&lt;/code&gt;를 사용하여 개선할 수는 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;브라우저 요청 및 응답
    &lt;ul&gt;
      &lt;li&gt;요청 워터폴을 줄여라
        &lt;ul&gt;
          &lt;li&gt;요청 워터폴 : 리소스를 요청하기 위해 다른 리소스 요청이 완료되기를 기다리는 상황&lt;/li&gt;
          &lt;li&gt;서버에서 요청을 받았을때 응답을 주기까지 DB 호출을 하거나 API 요청을 보내는 경우, 이를 병렬로 처리하거나 리액트 fetch 워터폴(Suspense) 등으로 개선할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;캐시 : CDN 으로 정적 리소스를 캐싱할 수 있음. 그외 많은 캐싱이 있다&lt;/li&gt;
      &lt;li&gt;HTML 스트리밍 : HTML 문서를 부분적으로 제공하는 방식으로, 유저에게 더 빠른 경험을 줄 수 있음.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Oct 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80-%EB%A1%9C%EB%93%9C%EB%90%98%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%8D%94-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/%EC%9B%B9-%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B0%80-%EB%A1%9C%EB%93%9C%EB%90%98%EA%B8%B0-%EC%A0%84%EC%97%90-%EB%8D%94-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>next.js 15 RC</title>
        <description>&lt;p&gt;https://nextjs.org/blog/next-15&lt;/p&gt;

&lt;p&gt;next.js 15의 스테이블버전이 나와 작성하였다&lt;/p&gt;

&lt;h2 id=&quot;async-request-apis-breaking-change&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#async-request-apis-breaking-change&quot;&gt;Async Request APIs (Breaking Change)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;전통적인 SSR 에서는 서버에서는 요청이 전부 완료될때까지 렌더링을 중지한다. 하지만 모든 컴포넌트가 요청이 필요한건 아니다. 따라서 가능한 많은 컴포넌트를 요청이 종료되기전에 준비하기위해, 몇몇 API를 비동기적으로 변경하였다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cookies, headers, draftMode&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;params&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;layout.js&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page.js&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;route.js&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default.js&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateMetadata&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generateViewport&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;searchParams&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마이그레이션을 위해 이러한 API를 동기적으로도 접근할 수 있지만, 다음 메이저 버전까지 경고를 발생시킨다. codemod 또는 upgrade guide를 통해 마이그레이션 가능하다&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;npx @next/codemod@canary next-async-request-api &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;caching-semantics&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#caching-semantics&quot;&gt;Caching Semantics&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;APP Router 에서는 여러 부분에 캐싱이 디폴트로 들어갔다. 하지만 이는 반발도 많아서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt; Route Handlers, Client Router Cache를 디폴트로 캐싱되지 않도록 변경하였다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Client Router Cache no longer caches Page components by default
    &lt;ul&gt;
      &lt;li&gt;Page 컴포넌트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staleTime&lt;/code&gt;을 0으로 설정하여 항상 다시 fetch 하도록 함&lt;/li&gt;
      &lt;li&gt;Shared layout data, back/forward navigation, loading.js 는 캐싱이 적용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;react-19&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#react-19&quot;&gt;React 19&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;여러 테스트를 걸친 결과 React 19가 안정적이라고 확신하기에 App Router에서는 React 19 RC를 사용하도록 하였다. 하지만 Pages Route 에서는 React 18 호환성을 제공한다. 추후 React 19가 준비되었을때 업그레이드할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;static-route-indicator&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#static-route-indicator&quot;&gt;Static Route Indicator&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;아래와 같은 인디케이터가 개발모드에서 나타나 어떤 라우트가 static 인지 dynamic 인지 확인할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Pasted%20image%2020241022121849.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;executing-code-after-a-response-withunstable_afterexperimental&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#executing-code-after-a-response-with-unstable_after-experimental&quot;&gt;Executing code after a response with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unstable_after&lt;/code&gt; (Experimental)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;로그를 남기거나 분석, 외부 스토리지 싱크 맞추기 등은 유저의 요청과 직접적으로 관련이 없다. 유저의 요청이 이 작업들을 처리하기 위해 기다리지 않도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;after()&lt;/code&gt;라는 실험적인 API를 추가하였다. 유저에게 응답이 가면 그 후 예약된 작업들을 수행한다&lt;/p&gt;

&lt;h2 id=&quot;instrumentationjsstable&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#instrumentationjs-stable&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instrumentation.js&lt;/code&gt; (Stable)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;instrumentation.js&lt;/code&gt; 내 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;register()&lt;/code&gt; API 가 이제 stable이다. 
추가적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onRequeestError()&lt;/code&gt; 를 추가하여 에러를 잡을 수 있도록 하였다&lt;/p&gt;

&lt;h2 id=&quot;formcomponent&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#form-component&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Form&amp;gt;&lt;/code&gt; Component&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;form 을 다양한 기능과 함께 다룰 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;Form&amp;gt;&lt;/code&gt; 컴포넌트를 추가하였다.&lt;/p&gt;

&lt;p&gt;layout, loading UI를 prefetch 하여 제출되었을때 Client-side Navigation을 수행한다. 만약 JS가 로드되지 않았다면 full-page navigation을 수행한다&lt;/p&gt;

&lt;h2 id=&quot;improvements-for-self-hosting&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#improvements-for-self-hosting&quot;&gt;Improvements for self-hosting&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt; 을 커스텀하게 설정할 수 있도록 변경되었다&lt;/p&gt;

&lt;h2 id=&quot;enhanced-security-for-server-actions&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#enhanced-security-for-server-actions&quot;&gt;Enhanced Security for Server Actions&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;기존에는 사용되지 않는 Server Action도 접근이 가능했다. 하지만 이제는 사용되지 않는 Server Action의 ID가 Client-side JS bundle에 포함되지 않도록 변경되었다.&lt;/p&gt;

&lt;p&gt;ID도 빌드할때마다 재계산되어 추측할 수 없도록 변경되었다.&lt;/p&gt;

&lt;h2 id=&quot;optimizing-bundling-of-external-packages-stable&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#optimizing-bundling-of-external-packages-stable&quot;&gt;Optimizing bundling of external packages (Stable)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;외부 패키지를 번들링하는 것은 어플리케이션 cold start 성능을 향상 시킬수 있다&lt;/p&gt;

&lt;p&gt;App Router 에서 외부 패키지는 디폴트로 번들되며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serverExternalPackages&lt;/code&gt; 옵션으로 몇몇 패키지를 뺄수 있다. Pages Router에서는 디폴트로 번들되지 않는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;transpilePackages&lt;/code&gt; 옵션으로 번들할 패키지를 선택할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 차이를 없애기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundlePagesRouterDependencies&lt;/code&gt; 옵션을 추가해서 Page Router에서 디폴트로 번들링하도록 하였다. 이후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;serverExternalPackages&lt;/code&gt;로 제외하고 싶은 패키지를 추가할 수 있다&lt;/p&gt;

&lt;h2 id=&quot;eslint-9-support&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#eslint-9-support&quot;&gt;ESLint 9 Support&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;ESLint 8의 EOL이 지나 ESlint 9 을 지원한다. 하위 호환성을 맞추었기에 ESLint 8 사용은 계속 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;development-and-build-improvements&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#development-and-build-improvements&quot;&gt;Development and Build Improvements&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Server Components HMR
    &lt;ul&gt;
      &lt;li&gt;save 시 서버컴포넌트를 재요청하여 API 요청이 발생하는 것을 개선하여, HMR 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch&lt;/code&gt; 응답을 재사용하도록 수정하였다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Faster Static Generation for the App Router
    &lt;ul&gt;
      &lt;li&gt;빌드과정에서 Static Generation 속도를 네트워크 요청과 관련하여 개선하였다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Advanced Static Generation Control
    &lt;ul&gt;
      &lt;li&gt;더 다양한 요구사항에 대응하기 위해 Static Generation 를 컨트롤할 수 있는 옵션을 추가하였다.&lt;/li&gt;
      &lt;li&gt;특수한 요구사항이 없다면 그대로 유지하는 것이 좋다. (잠재적으로 OOM, 리소스 과다사용이 발생할 수 있음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;other-changes&quot;&gt;&lt;a href=&quot;https://nextjs.org/blog/next-15#other-changes&quot;&gt;Other Changes&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[Breaking] The minimum required Node.js version has been updated to 18.18.0&lt;/li&gt;
  &lt;li&gt;[Improvement] If a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next/dynamic&lt;/code&gt; component is used during SSR, the chunk will be prefetched&lt;/li&gt;
  &lt;li&gt;[Improvement] The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;experimental.allowDevelopmentBuild&lt;/code&gt; option can be used to allow &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NODE_ENV=development&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next build&lt;/code&gt; for debugging purposes&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Oct 2024 19:00:00 +0900</pubDate>
        <link>https://seongil-shin.github.io/posts/next.js-15-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD/</link>
        <guid isPermaLink="true">https://seongil-shin.github.io/posts/next.js-15-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EB%8A%A5-%EC%9A%94%EC%95%BD/</guid>
        
        <category>#study</category>
        
        
        <category>study,</category>
        
        <category>article</category>
        
      </item>
    
  </channel>
</rss>