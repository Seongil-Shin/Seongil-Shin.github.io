<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="Keep-Alive" /><meta name="author" content="신성일" /><meta property="og:locale" content="ko" /><meta name="description" content="아래와 같이 http 헤더를 보다보면 keep-alive라고 명시된 부분이 보일 때가 있다. connection : keep-alive Keep-Alive:timeout=5, max=1000 이 keep-alive는 무슨 뜻일까 궁금하여 찾아보았다. keep-alive connection : keep-alive connection은 네트워크 연결을 현재 요청이 종료된 이후에도 유지할 것인가를 설정하는 헤더이다. 다음과 같은 값을 지정할 수 있음 close : 한 요청이 종료되면 연결을 끊음. 디폴트 keep-alive : 요청이 종료되어도 연결을 유지한다. Keep-Alive:timeout=5, max=1000 송신자가 연결에 대한 타임아웃과 요청 최대 갯수를 어떻게 정했는지 알려주는 헤더 timeout : 연결이 idle한 채로 얼마동안 유지할 것인가 max : 최대 몇개의 요청을 주고 close없이 처리할 것인가 Keep-alive를 사용하는 이유 http 프로토콜은 tcp을 기반으로 만들어져있다. 그리고 tcp에서 두 호스트가 통신을 할 때는 연결을 맺는 과정이 필요하다. 이 연결을 맺는 과정은 3-way handshaking으로 진행되며 총 세번 두 호스트가 통신을 해야 연결이 맺어지며 본래 원하는 통신이 가능해진다. 이렇게 세 번 통신하는 과정은 낭비가 있다. keep-alive를 설정해주면 요청이 종료되어도 connection을 끊지 않아 다음 요청 때 한번 맺은 연결을 재사용할 수 있어 서버 요청/응답이 빨라진다. 단점 만약 서버가 많은 클라이언트로부터 요청을 받아야하고, 모든 클라이언트가 keep-alive라면 서버는 모든 요청마다 연결을 유지해야하기에 프로세스 수가 기하급수적으로 늘어나 MaxClient 값을 초과하게 된다. 따라서 서버에서는 keep-alive를 지원할 때는 적절히 maxClient나 KeepAliveTimeout을 설정해줘야한다. http 버전별 차이 http 1.0에서 기본적으로 비연결지향으로 한번 통신을 하면 연결을 끊는다. http 1.1에서 connection : keep-alive가 디폴트로 설정되어있다. http/2에서 http/2에서는 keep-alive 기능을 사용할 필요가 없다. 그 이유는 다음과 같다. http/2에서는 http body가 binary로 전송된다.(과거엔 text로 전송됨). 동시에 이전에는 header-body를 묶은 http message가 전송 최소단위였다면, http/2에서는 binary frame 이 전송 최소 단위가 된다. 이렇게 변화한 이유에는 기존 http 1.x가 가진 다음과 같은 단점 때문이다. http 1.x가 가진 단점들 본문은 압축이 되지만 헤더는 압축이 되지 않는다. 연속된 메세지는 비슷한 헤더구조를 가지는데, 그래도 매번 헤더를 전송해야함 다중전송(Multiplexing)이 불가능하다. multiplexing : 하나의 연결에 여러 요청/응답을 병렬적으로 실어 보내는 것. 병렬적이라는 것은 요청을 보내고 응답을 기다리지 않고 또 다른 요청을 보내는 것을 의미 이는 keep-alive를 사용하더라도 [요청-응답] [요청-응답]으로 이루어지지, [요청-요청-요청-응답-응답-응답]으로 이루어지지 않는다. 이를 해결하기 위해 http/2에서는 하나의 연결에 여러 스트림을 사용하여 multiplexing이 가능하도록 했다. 이것이 가능한 이유는 http/2 패킷을 binary frame 단위로 세분화하여 순서에 상관없이 받는 쪽에서 조립할 수 있도록 설계하였기 때문이다. 이러한 multiplexing 덕분에 http/2 에서는 연결을 유지하기 위한 설정인 keep-alive가 더이상 필요없어지게 되었다. 이외에도 http/2에서는 다음과 같은 성능 향상 기법이 적용되었다. 헤더 압축 http/1.x에서 매 요청마다 헤더를 보내야했던 것과 다르게, http/2에서는 중복되는 헤더를 압축하여 사용한다. 서버 푸쉬 http/1.x에서는 클라이언트가 요청을 하고 서버가 그에 응답을 하는 것이 일반적이었다. 하지만 http/2에서는 서버 푸쉬 기능을 통해 클라이언트가 요청하지 않은 데이터를 서버가 스스로 전송해줄 수 있다. 따라서 만약 index.html안에 style.css, script.js, image.jpg가 있다면 http/1.x에서는 매번 [요청-응답]을 반복하며 받아와야했지만, http/2에서는 한번에 내려주어 성능을 개선해준다. 우선순위 응답에 대한 우선순위를 정하여 먼저 전송처리 해줄 수 있다. ex) css는 브라우저 렌더링을 막는데, 이를 최대한 빨리 내보내줘서 브라우저 렌더링을 진행함. 참고문서 참고문서 2 참고문서 3 참고문서 4" /><meta property="og:description" content="아래와 같이 http 헤더를 보다보면 keep-alive라고 명시된 부분이 보일 때가 있다. connection : keep-alive Keep-Alive:timeout=5, max=1000 이 keep-alive는 무슨 뜻일까 궁금하여 찾아보았다. keep-alive connection : keep-alive connection은 네트워크 연결을 현재 요청이 종료된 이후에도 유지할 것인가를 설정하는 헤더이다. 다음과 같은 값을 지정할 수 있음 close : 한 요청이 종료되면 연결을 끊음. 디폴트 keep-alive : 요청이 종료되어도 연결을 유지한다. Keep-Alive:timeout=5, max=1000 송신자가 연결에 대한 타임아웃과 요청 최대 갯수를 어떻게 정했는지 알려주는 헤더 timeout : 연결이 idle한 채로 얼마동안 유지할 것인가 max : 최대 몇개의 요청을 주고 close없이 처리할 것인가 Keep-alive를 사용하는 이유 http 프로토콜은 tcp을 기반으로 만들어져있다. 그리고 tcp에서 두 호스트가 통신을 할 때는 연결을 맺는 과정이 필요하다. 이 연결을 맺는 과정은 3-way handshaking으로 진행되며 총 세번 두 호스트가 통신을 해야 연결이 맺어지며 본래 원하는 통신이 가능해진다. 이렇게 세 번 통신하는 과정은 낭비가 있다. keep-alive를 설정해주면 요청이 종료되어도 connection을 끊지 않아 다음 요청 때 한번 맺은 연결을 재사용할 수 있어 서버 요청/응답이 빨라진다. 단점 만약 서버가 많은 클라이언트로부터 요청을 받아야하고, 모든 클라이언트가 keep-alive라면 서버는 모든 요청마다 연결을 유지해야하기에 프로세스 수가 기하급수적으로 늘어나 MaxClient 값을 초과하게 된다. 따라서 서버에서는 keep-alive를 지원할 때는 적절히 maxClient나 KeepAliveTimeout을 설정해줘야한다. http 버전별 차이 http 1.0에서 기본적으로 비연결지향으로 한번 통신을 하면 연결을 끊는다. http 1.1에서 connection : keep-alive가 디폴트로 설정되어있다. http/2에서 http/2에서는 keep-alive 기능을 사용할 필요가 없다. 그 이유는 다음과 같다. http/2에서는 http body가 binary로 전송된다.(과거엔 text로 전송됨). 동시에 이전에는 header-body를 묶은 http message가 전송 최소단위였다면, http/2에서는 binary frame 이 전송 최소 단위가 된다. 이렇게 변화한 이유에는 기존 http 1.x가 가진 다음과 같은 단점 때문이다. http 1.x가 가진 단점들 본문은 압축이 되지만 헤더는 압축이 되지 않는다. 연속된 메세지는 비슷한 헤더구조를 가지는데, 그래도 매번 헤더를 전송해야함 다중전송(Multiplexing)이 불가능하다. multiplexing : 하나의 연결에 여러 요청/응답을 병렬적으로 실어 보내는 것. 병렬적이라는 것은 요청을 보내고 응답을 기다리지 않고 또 다른 요청을 보내는 것을 의미 이는 keep-alive를 사용하더라도 [요청-응답] [요청-응답]으로 이루어지지, [요청-요청-요청-응답-응답-응답]으로 이루어지지 않는다. 이를 해결하기 위해 http/2에서는 하나의 연결에 여러 스트림을 사용하여 multiplexing이 가능하도록 했다. 이것이 가능한 이유는 http/2 패킷을 binary frame 단위로 세분화하여 순서에 상관없이 받는 쪽에서 조립할 수 있도록 설계하였기 때문이다. 이러한 multiplexing 덕분에 http/2 에서는 연결을 유지하기 위한 설정인 keep-alive가 더이상 필요없어지게 되었다. 이외에도 http/2에서는 다음과 같은 성능 향상 기법이 적용되었다. 헤더 압축 http/1.x에서 매 요청마다 헤더를 보내야했던 것과 다르게, http/2에서는 중복되는 헤더를 압축하여 사용한다. 서버 푸쉬 http/1.x에서는 클라이언트가 요청을 하고 서버가 그에 응답을 하는 것이 일반적이었다. 하지만 http/2에서는 서버 푸쉬 기능을 통해 클라이언트가 요청하지 않은 데이터를 서버가 스스로 전송해줄 수 있다. 따라서 만약 index.html안에 style.css, script.js, image.jpg가 있다면 http/1.x에서는 매번 [요청-응답]을 반복하며 받아와야했지만, http/2에서는 한번에 내려주어 성능을 개선해준다. 우선순위 응답에 대한 우선순위를 정하여 먼저 전송처리 해줄 수 있다. ex) css는 브라우저 렌더링을 막는데, 이를 최대한 빨리 내보내줘서 브라우저 렌더링을 진행함. 참고문서 참고문서 2 참고문서 3 참고문서 4" /><link rel="canonical" href="https://seongil-shin.github.io/posts/web-keep-alive/" /><meta property="og:url" content="https://seongil-shin.github.io/posts/web-keep-alive/" /><meta property="og:site_name" content="디피의 개발일지" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-05T18:51:26+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Keep-Alive" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"신성일"},"dateModified":"2023-05-30T23:18:27+09:00","datePublished":"2022-11-05T18:51:26+09:00","description":"아래와 같이 http 헤더를 보다보면 keep-alive라고 명시된 부분이 보일 때가 있다. connection : keep-alive Keep-Alive:timeout=5, max=1000 이 keep-alive는 무슨 뜻일까 궁금하여 찾아보았다. keep-alive connection : keep-alive connection은 네트워크 연결을 현재 요청이 종료된 이후에도 유지할 것인가를 설정하는 헤더이다. 다음과 같은 값을 지정할 수 있음 close : 한 요청이 종료되면 연결을 끊음. 디폴트 keep-alive : 요청이 종료되어도 연결을 유지한다. Keep-Alive:timeout=5, max=1000 송신자가 연결에 대한 타임아웃과 요청 최대 갯수를 어떻게 정했는지 알려주는 헤더 timeout : 연결이 idle한 채로 얼마동안 유지할 것인가 max : 최대 몇개의 요청을 주고 close없이 처리할 것인가 Keep-alive를 사용하는 이유 http 프로토콜은 tcp을 기반으로 만들어져있다. 그리고 tcp에서 두 호스트가 통신을 할 때는 연결을 맺는 과정이 필요하다. 이 연결을 맺는 과정은 3-way handshaking으로 진행되며 총 세번 두 호스트가 통신을 해야 연결이 맺어지며 본래 원하는 통신이 가능해진다. 이렇게 세 번 통신하는 과정은 낭비가 있다. keep-alive를 설정해주면 요청이 종료되어도 connection을 끊지 않아 다음 요청 때 한번 맺은 연결을 재사용할 수 있어 서버 요청/응답이 빨라진다. 단점 만약 서버가 많은 클라이언트로부터 요청을 받아야하고, 모든 클라이언트가 keep-alive라면 서버는 모든 요청마다 연결을 유지해야하기에 프로세스 수가 기하급수적으로 늘어나 MaxClient 값을 초과하게 된다. 따라서 서버에서는 keep-alive를 지원할 때는 적절히 maxClient나 KeepAliveTimeout을 설정해줘야한다. http 버전별 차이 http 1.0에서 기본적으로 비연결지향으로 한번 통신을 하면 연결을 끊는다. http 1.1에서 connection : keep-alive가 디폴트로 설정되어있다. http/2에서 http/2에서는 keep-alive 기능을 사용할 필요가 없다. 그 이유는 다음과 같다. http/2에서는 http body가 binary로 전송된다.(과거엔 text로 전송됨). 동시에 이전에는 header-body를 묶은 http message가 전송 최소단위였다면, http/2에서는 binary frame 이 전송 최소 단위가 된다. 이렇게 변화한 이유에는 기존 http 1.x가 가진 다음과 같은 단점 때문이다. http 1.x가 가진 단점들 본문은 압축이 되지만 헤더는 압축이 되지 않는다. 연속된 메세지는 비슷한 헤더구조를 가지는데, 그래도 매번 헤더를 전송해야함 다중전송(Multiplexing)이 불가능하다. multiplexing : 하나의 연결에 여러 요청/응답을 병렬적으로 실어 보내는 것. 병렬적이라는 것은 요청을 보내고 응답을 기다리지 않고 또 다른 요청을 보내는 것을 의미 이는 keep-alive를 사용하더라도 [요청-응답] [요청-응답]으로 이루어지지, [요청-요청-요청-응답-응답-응답]으로 이루어지지 않는다. 이를 해결하기 위해 http/2에서는 하나의 연결에 여러 스트림을 사용하여 multiplexing이 가능하도록 했다. 이것이 가능한 이유는 http/2 패킷을 binary frame 단위로 세분화하여 순서에 상관없이 받는 쪽에서 조립할 수 있도록 설계하였기 때문이다. 이러한 multiplexing 덕분에 http/2 에서는 연결을 유지하기 위한 설정인 keep-alive가 더이상 필요없어지게 되었다. 이외에도 http/2에서는 다음과 같은 성능 향상 기법이 적용되었다. 헤더 압축 http/1.x에서 매 요청마다 헤더를 보내야했던 것과 다르게, http/2에서는 중복되는 헤더를 압축하여 사용한다. 서버 푸쉬 http/1.x에서는 클라이언트가 요청을 하고 서버가 그에 응답을 하는 것이 일반적이었다. 하지만 http/2에서는 서버 푸쉬 기능을 통해 클라이언트가 요청하지 않은 데이터를 서버가 스스로 전송해줄 수 있다. 따라서 만약 index.html안에 style.css, script.js, image.jpg가 있다면 http/1.x에서는 매번 [요청-응답]을 반복하며 받아와야했지만, http/2에서는 한번에 내려주어 성능을 개선해준다. 우선순위 응답에 대한 우선순위를 정하여 먼저 전송처리 해줄 수 있다. ex) css는 브라우저 렌더링을 막는데, 이를 최대한 빨리 내보내줘서 브라우저 렌더링을 진행함. 참고문서 참고문서 2 참고문서 3 참고문서 4","headline":"Keep-Alive","mainEntityOfPage":{"@type":"WebPage","@id":"https://seongil-shin.github.io/posts/web-keep-alive/"},"url":"https://seongil-shin.github.io/posts/web-keep-alive/"}</script><title>Keep-Alive | 디피의 개발일지</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-HC9W0NGRV0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-HC9W0NGRV0'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">디피의 개발일지</a></div><div class="site-subtitle font-italic">개인 학습 및 프로젝트 기록</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Seongil-Shin" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['callmeshin75','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/%EC%84%B1%EC%9D%BC-%EC%8B%A0-a9411b237/" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Keep-Alive</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Keep-Alive</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 신성일 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Nov 5, 2022, 6:51 PM +0900" prep="on" > Nov 5, 2022 <i class="unloaded">2022-11-05T18:51:26+09:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, May 30, 2023, 11:18 PM +0900" prefix="Updated " > May 30, 2023 <i class="unloaded">2023-05-30T23:18:27+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1320 words">7 min</span></div></div><div class="post-content"><p>아래와 같이 http 헤더를 보다보면 keep-alive라고 명시된 부분이 보일 때가 있다.</p><ul><li><code class="language-plaintext highlighter-rouge">connection : keep-alive</code><li><code class="language-plaintext highlighter-rouge">Keep-Alive:timeout=5, max=1000</code></ul><p>이 <code class="language-plaintext highlighter-rouge">keep-alive</code>는 무슨 뜻일까 궁금하여 찾아보았다.</p><p><br /></p><h2 id="keep-alive"><code class="language-plaintext highlighter-rouge">keep-alive</code></h2><p><code class="language-plaintext highlighter-rouge">connection : keep-alive</code></p><ul><li>connection은 네트워크 연결을 현재 요청이 종료된 이후에도 유지할 것인가를 설정하는 헤더이다.<li>다음과 같은 값을 지정할 수 있음<ul><li>close : 한 요청이 종료되면 연결을 끊음. 디폴트<li>keep-alive : 요청이 종료되어도 연결을 유지한다.</ul></ul><p><code class="language-plaintext highlighter-rouge">Keep-Alive:timeout=5, max=1000</code></p><ul><li>송신자가 연결에 대한 타임아웃과 요청 최대 갯수를 어떻게 정했는지 알려주는 헤더<ul><li>timeout : 연결이 idle한 채로 얼마동안 유지할 것인가<li>max : 최대 몇개의 요청을 주고 close없이 처리할 것인가</ul></ul><h2 id="keep-alive를-사용하는-이유"><strong>Keep-alive를 사용하는 이유</strong></h2><ul><li>http 프로토콜은 tcp을 기반으로 만들어져있다. 그리고 tcp에서 두 호스트가 통신을 할 때는 연결을 맺는 과정이 필요하다. 이 연결을 맺는 과정은 <code class="language-plaintext highlighter-rouge">3-way handshaking</code>으로 진행되며 총 세번 두 호스트가 통신을 해야 연결이 맺어지며 본래 원하는 통신이 가능해진다. 이렇게 세 번 통신하는 과정은 낭비가 있다.<li><code class="language-plaintext highlighter-rouge">keep-alive</code>를 설정해주면 요청이 종료되어도 connection을 끊지 않아 다음 요청 때 한번 맺은 연결을 재사용할 수 있어 서버 요청/응답이 빨라진다.</ul><h2 id="단점"><strong>단점</strong></h2><ul><li>만약 서버가 많은 클라이언트로부터 요청을 받아야하고, 모든 클라이언트가 <code class="language-plaintext highlighter-rouge">keep-alive</code>라면 서버는 모든 요청마다 연결을 유지해야하기에 프로세스 수가 기하급수적으로 늘어나 MaxClient 값을 초과하게 된다.<li>따라서 서버에서는 keep-alive를 지원할 때는 적절히 maxClient나 KeepAliveTimeout을 설정해줘야한다.</ul><p><br /></p><h2 id="http-버전별-차이">http 버전별 차이</h2><p><strong>http 1.0에서</strong></p><p>기본적으로 비연결지향으로 한번 통신을 하면 연결을 끊는다.</p><p><strong>http 1.1에서</strong></p><p><code class="language-plaintext highlighter-rouge">connection : keep-alive</code>가 디폴트로 설정되어있다.</p><p><strong>http/2에서</strong></p><p>http/2에서는 keep-alive 기능을 사용할 필요가 없다. 그 이유는 다음과 같다.</p><p>http/2에서는 http body가 binary로 전송된다.(과거엔 text로 전송됨). 동시에 이전에는 header-body를 묶은 http message가 전송 최소단위였다면, http/2에서는 <strong>binary frame</strong> 이 전송 최소 단위가 된다. 이렇게 변화한 이유에는 기존 <code class="language-plaintext highlighter-rouge">http 1.x</code>가 가진 다음과 같은 단점 때문이다.</p><p>http 1.x가 가진 단점들</p><ul><li>본문은 압축이 되지만 헤더는 압축이 되지 않는다.<li>연속된 메세지는 비슷한 헤더구조를 가지는데, 그래도 매번 헤더를 전송해야함<li>다중전송(Multiplexing)이 불가능하다.<ul><li>multiplexing : 하나의 연결에 여러 요청/응답을 병렬적으로 실어 보내는 것. 병렬적이라는 것은 요청을 보내고 응답을 기다리지 않고 또 다른 요청을 보내는 것을 의미<li>이는 keep-alive를 사용하더라도 [요청-응답] [요청-응답]으로 이루어지지, [요청-요청-요청-응답-응답-응답]으로 이루어지지 않는다.</ul></ul><p>이를 해결하기 위해 http/2에서는 하나의 연결에 여러 스트림을 사용하여 multiplexing이 가능하도록 했다. 이것이 가능한 이유는 http/2 패킷을 binary frame 단위로 세분화하여 순서에 상관없이 받는 쪽에서 조립할 수 있도록 설계하였기 때문이다. 이러한 multiplexing 덕분에 http/2 에서는 연결을 유지하기 위한 설정인 <code class="language-plaintext highlighter-rouge">keep-alive</code>가 더이상 필요없어지게 되었다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://d34smkdb128qfi.cloudfront.net/images/kemptechnologieslibraries/illustrations/loadmasterhttp2multiplexing.png?sfvrsn=4fbe5470_0" alt="multiplexing" /></p><p>이외에도 http/2에서는 다음과 같은 성능 향상 기법이 적용되었다.</p><ul><li>헤더 압축<ul><li>http/1.x에서 매 요청마다 헤더를 보내야했던 것과 다르게, http/2에서는 중복되는 헤더를 압축하여 사용한다.</ul><li>서버 푸쉬<ul><li>http/1.x에서는 클라이언트가 요청을 하고 서버가 그에 응답을 하는 것이 일반적이었다.<li>하지만 http/2에서는 서버 푸쉬 기능을 통해 클라이언트가 요청하지 않은 데이터를 서버가 스스로 전송해줄 수 있다.<li>따라서 만약 <code class="language-plaintext highlighter-rouge">index.html</code>안에 <code class="language-plaintext highlighter-rouge">style.css</code>, <code class="language-plaintext highlighter-rouge">script.js</code>, <code class="language-plaintext highlighter-rouge">image.jpg</code>가 있다면 http/1.x에서는 매번 [요청-응답]을 반복하며 받아와야했지만, http/2에서는 한번에 내려주어 성능을 개선해준다.</ul><li>우선순위<ul><li>응답에 대한 우선순위를 정하여 먼저 전송처리 해줄 수 있다.<li>ex) css는 브라우저 렌더링을 막는데, 이를 최대한 빨리 내보내줘서 브라우저 렌더링을 진행함.</ul></ul><p><a href="https://goodgid.github.io/HTTP-Keep-Alive/">참고문서</a></p><p><a href="https://taetaetae.github.io/2017/08/28/apache-keep-alive/">참고문서 2</a></p><p><a href="https://jins-dev.tistory.com/entry/HTTP2-%ED%8A%B9%EC%A7%95%EB%93%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC">참고문서 3</a></p><p><a href="https://withbundo.blogspot.com/2021/08/httphttp2-http2.html">참고문서 4</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>study</a>, <a href='/categories/web/'>web</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/web/" class="post-tag no-text-decoration" >web</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Keep-Alive - 디피의 개발일지&url=https://seongil-shin.github.io/posts/web-keep-alive/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Keep-Alive - 디피의 개발일지&u=https://seongil-shin.github.io/posts/web-keep-alive/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Keep-Alive - 디피의 개발일지&url=https://seongil-shin.github.io/posts/web-keep-alive/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/You-don't-know-JS-Yet-1%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">You don't know JS Yet - 1장 자바스크립트</a><li><a href="/posts/why-nextjs-sucks/">why-nextjs-sucks</a><li><a href="/posts/the-state-of-es5-on-the-web/">the state of es5 on the web</a><li><a href="/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-3%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EB%B2%95-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EA%B8%B0/">프로그래머의 뇌 3장 프로그래밍 문법 빠르게 배우기</a><li><a href="/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-4%EC%9E%A5-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%9D%BD%EB%8A%94-%EB%B0%A9%EB%B2%95/">프로그래머의 뇌 4장 복잡한 코드 읽는 방법</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/study/">#study</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/next-js/">next.js</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/db/">db</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/java/">java</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/web-Headless-CMS/"><div class="card-body"> <span class="timeago small" > Mar 10, 2023 <i class="unloaded">2023-03-10T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Headless CMS</h3><div class="text-muted small"><p> Headless CMS 란? 웹사이트를 만들 때는 반드시 컨텐츠(데이터)가 필요하다. Headless CMS는 컨텐츠를 보여줄 수단인 Head와 컨텐츠를 분리한 구조로, 컨텐츠가 Head에 독립적으로 동작할 수 있도록 하는 구조이다. ![1E3qz8MZ8zR7Y3NRghFOvJQ](https://miro.medium.com/v2/resize:fit...</p></div></div></a></div><div class="card"> <a href="/posts/deep-link/"><div class="card-body"> <span class="timeago small" > May 19, 2023 <i class="unloaded">2023-05-19T22:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>딥링크</h3><div class="text-muted small"><p> 딥링크는 웹사이트에서 사용자 기기에 설치된 앱을 URI로 실행시킬 수 있도록하는 기술이다. 딥링크의 세가지 유형 이러한 딥링크에는 세가지 유형이 있다. URI Scheme (초기 형태) 보완 Universal Link (IOS) App Link (Android) URI Scheme 앱...</p></div></div></a></div><div class="card"> <a href="/posts/opengraph/"><div class="card-body"> <span class="timeago small" > Sep 11, 2022 <i class="unloaded">2022-09-11T16:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Open Graph(OG) 프로토콜</h3><div class="text-muted small"><p> Open Graph 프로토콜 HTML문서의 head에는 &lt;meta&gt; 태그로 사이트의 정보가 표기되어있는 경우가 많다. 이는 크롤러가 무엇이 제목이고, 무엇이 내용인지 파악하기 쉽도록 하기 위해서 표기한 것이다. 페이스북의 Open Graph 프로토콜은 이러한 메타태그의 표기 방법은 통일한 것이다. 이 Open Graph 프로토콜이 우리가...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/web-CORS/" class="btn btn-outline-primary" prompt="Older"><p>CORS</p></a> <a href="/posts/design-pattern-%EC%9C%A0%EB%8B%9B%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B5%AC%ED%98%84-%EA%B2%80%EC%A6%9D%EC%9D%B4%EB%9E%80/" class="btn btn-outline-primary" prompt="Newer"><p>유닛테스트 구현 검증이란?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Keep-Alive'; this.page.url = 'https://seongil-shin.github.io/posts/web-keep-alive/'; this.page.identifier = '/posts/web-keep-alive/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#main > div.row:first-child > div:first-child img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/Seongil-Shin">ShinSeongil</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/study/">#study</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/next-js/">next.js</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/db/">db</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/java/">java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://seongil-shin.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
