<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="쿠키 인증 vs 세션 vs JWT" /><meta name="author" content="신성일" /><meta property="og:locale" content="ko" /><meta name="description" content="쿠키 사용자가 로그인하면, 사용자 식별자를 암호화 또는 평문으로 쿠키에 담는 방식. 요청이 오면 쿠키에 담긴 식별자를 보고 유저를 구분한다. 장점 유효한 쿠키인지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 암호화를 하면 brute force 대응 가능(특정 횟수 이상 인증 실패시 ip 잠금) 간단히 구현 가능 단점 쿠키가 탈취되면 위장 가능 세션 인증이 완료되면 사용자 식별자를 서버(DB 등)에 저장하고 그 저장한 곳에 접근하기 위한 해시 값을 세션 ID로 지정. 이후 세션 ID를 쿠키에 담아 보내주고, 사용자로부터 요청이 오면 세션id로 사용자 식별자를 가져온다. 장점 세션id가 노출되어도 유의미한 정보를 가지고 있지 않음. 같은 유저가 다른 곳에서 로그인할 시, 누가 로그인 되어있는지 저장하고 있기에, 하나를 막을 수 있음. 단점 쿠키가 탈취되면 위장 가능 요청이 많아지면 서버에 부하가 심해져, 세션 DB와 서버를 확장해야 한다. 세션 관리 시스템에 문제가 생기면 시스템 전체에 문제가 생긴다. JWT 인증이 되면, JWT 토큰(access token)을 클라이언트로 보내줌. 클라이언트는 헤더에 JWT를 적용하여 서버로 요청을 보내면 서버는 JWT을 디코딩하여 유저를 식별함. 장점 토큰이 유효한지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 단점 탈취에 취약하다. 따라서 refresh token을 만들고, access token에 만료기간을 설정함. XSS 공격, CSRF 공격에 대비해야함. refresh token도 탈취될 수 있지만 서버가 방어할 수 있는 방법을 제공함. 쿠키/세션 다룰 때 주의점 httponly을 통해 XSS 공격 막기 secure 옵션을 통해 패킷 탈취에 대비 식별자는 암호화하여, brute force 막기. 특정 횟수 이상 인증 실패 시 ip 차단 CSRF 에 대비하기 위해 게시글에 html 입력 불가능하도록 하기.(sanitize) 쿠키 탈취에 대비하기 위해 너무 동떨어진 위치에서 요청 시 차단 암호화 시에는 레인보우 테이블 공격 방어로 salt를 섞고 한번 더 암호화하는 기법(bcrypt 등) 사용 만료기간 설정 or 브라우저 닫을 시 만료 JWT 다룰 때 주의점 refresh token 탈취 시에 대응하기 위해, 같은 refresh token 사용이 두 번 감지되면 그 refresh token 이후 발급 된 모든 refresh token을 폐기 https://developer-ping9.tistory.com/239 다만 이 경우에도 access token만 계속 탈취하거나, 공격자가 먼저 reissue 했을 땐, 감지 할 수 없다. access token 만료 전에 reissue 시 탈취된 것으로 판단하여 access token을 폐기시킬 수 있음 이 경우에도 access token 만료 후 리이슈해서 접근하면 감지할 수 없음. 쿠키 vs 세션 장단점만 보면 쿠키가 서버 확장에도 대응이 돼서 쿠키가 더 좋아보인다. 그런데 왜 사람들은 세션이 좋다고 하는 것일까? 로그인 상태를 저장하기에 동시 로그인 시 하나를 막을 수 있다지만, 서비스에 따라서는 동시로그인을 허용해야하는 경우가 많다. 정확히 어떤 차이점이 있을까? Session ID in cookies vs. Encrypted cookie 쿠키 암호화가 세션에 비해 단점인 것 복잡한 암호화 알고리즘 필요, secret key 관리 필요, 비중앙화됨(동시로그인 못막음) 신뢰할 수 있는 암호화 알고리즘을 사용해야함 크기가 커서 네트워크 비용 발생 (바이트 수준 차이라 크게 문제는 안될듯) 글을 읽었을 때 게임과 같이 동시로그인을 꼭 막아야하는 경우가 아니면, 쿠키 암호화가 성능상/구현상 더 좋은 거 같음. 암호화 알고리즘도 라이브러리화 된 신뢰성 있는 것이 많기에 글에서 본 단점도 상쇄된다. secret key 관리만 개발자가 주의하면 될 거 같음. 물리적 해킹일 땐 어떻게? ex) PC방에서 A유저가 로그인 하고 자리를 떴는데, B가 와서 그대로 사용할 경우 쿠키 / 세션의 경우 : 만료기간 두기가 최선일 거 같음. JWT : refresh token 사용 + refresh token 탈취 대비책은 위에서 “주의점”에 적은 대로. 네이버 로그인 방식 NID_AUT, NID_SES 사용 링크에 나온대로 두 쿠키를 복사한 후 다른 브라우저에 넣어봤는데, 로그인이 되었다. 그런데 다른 페이지로 이동하려니 로그인이 막힘. 다른 쿠키도 차례대로 넣어봤는데 동작하지 않음 네이버에 접속하자마자 바로 JSESSIONID란 쿠키가 생성됨. 이름이나 값이 단순 숫자인것으로 보아 세션은 사용하는거 같은데, 로그인 후 새로 생기는 것들은 암호화 되어있고 기존 JSESSIONID와는 독립되어보임. 서비스 형태, 위에서 나온 현상을 봤을때 SSO을 네이버에서도 사용하는 것 같음. 그런데 SSO를 어떤 방식으로 인증하는 걸까? 찾기가 어려움.. 다만 쿠키를 봤을때, JWT는 사용하지 않는 것으로 보임. 그리고 SSO는 큰 규모의 서비스를 대상으로 하는데, 세션을 사용하면 성능에 한계가 있어보임. 그럼 쿠키/세션/JWT 중에 있다면, 쿠키를 암호화하여 사용하는 것으로 보이는데 구체적인 내부 방식은 모르겠음. Redis를 사용하면 세션 성능 문제를 해결할 수 있지만, 그렇게까지 세션을 고집할 이유는 없어보임." /><meta property="og:description" content="쿠키 사용자가 로그인하면, 사용자 식별자를 암호화 또는 평문으로 쿠키에 담는 방식. 요청이 오면 쿠키에 담긴 식별자를 보고 유저를 구분한다. 장점 유효한 쿠키인지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 암호화를 하면 brute force 대응 가능(특정 횟수 이상 인증 실패시 ip 잠금) 간단히 구현 가능 단점 쿠키가 탈취되면 위장 가능 세션 인증이 완료되면 사용자 식별자를 서버(DB 등)에 저장하고 그 저장한 곳에 접근하기 위한 해시 값을 세션 ID로 지정. 이후 세션 ID를 쿠키에 담아 보내주고, 사용자로부터 요청이 오면 세션id로 사용자 식별자를 가져온다. 장점 세션id가 노출되어도 유의미한 정보를 가지고 있지 않음. 같은 유저가 다른 곳에서 로그인할 시, 누가 로그인 되어있는지 저장하고 있기에, 하나를 막을 수 있음. 단점 쿠키가 탈취되면 위장 가능 요청이 많아지면 서버에 부하가 심해져, 세션 DB와 서버를 확장해야 한다. 세션 관리 시스템에 문제가 생기면 시스템 전체에 문제가 생긴다. JWT 인증이 되면, JWT 토큰(access token)을 클라이언트로 보내줌. 클라이언트는 헤더에 JWT를 적용하여 서버로 요청을 보내면 서버는 JWT을 디코딩하여 유저를 식별함. 장점 토큰이 유효한지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 단점 탈취에 취약하다. 따라서 refresh token을 만들고, access token에 만료기간을 설정함. XSS 공격, CSRF 공격에 대비해야함. refresh token도 탈취될 수 있지만 서버가 방어할 수 있는 방법을 제공함. 쿠키/세션 다룰 때 주의점 httponly을 통해 XSS 공격 막기 secure 옵션을 통해 패킷 탈취에 대비 식별자는 암호화하여, brute force 막기. 특정 횟수 이상 인증 실패 시 ip 차단 CSRF 에 대비하기 위해 게시글에 html 입력 불가능하도록 하기.(sanitize) 쿠키 탈취에 대비하기 위해 너무 동떨어진 위치에서 요청 시 차단 암호화 시에는 레인보우 테이블 공격 방어로 salt를 섞고 한번 더 암호화하는 기법(bcrypt 등) 사용 만료기간 설정 or 브라우저 닫을 시 만료 JWT 다룰 때 주의점 refresh token 탈취 시에 대응하기 위해, 같은 refresh token 사용이 두 번 감지되면 그 refresh token 이후 발급 된 모든 refresh token을 폐기 https://developer-ping9.tistory.com/239 다만 이 경우에도 access token만 계속 탈취하거나, 공격자가 먼저 reissue 했을 땐, 감지 할 수 없다. access token 만료 전에 reissue 시 탈취된 것으로 판단하여 access token을 폐기시킬 수 있음 이 경우에도 access token 만료 후 리이슈해서 접근하면 감지할 수 없음. 쿠키 vs 세션 장단점만 보면 쿠키가 서버 확장에도 대응이 돼서 쿠키가 더 좋아보인다. 그런데 왜 사람들은 세션이 좋다고 하는 것일까? 로그인 상태를 저장하기에 동시 로그인 시 하나를 막을 수 있다지만, 서비스에 따라서는 동시로그인을 허용해야하는 경우가 많다. 정확히 어떤 차이점이 있을까? Session ID in cookies vs. Encrypted cookie 쿠키 암호화가 세션에 비해 단점인 것 복잡한 암호화 알고리즘 필요, secret key 관리 필요, 비중앙화됨(동시로그인 못막음) 신뢰할 수 있는 암호화 알고리즘을 사용해야함 크기가 커서 네트워크 비용 발생 (바이트 수준 차이라 크게 문제는 안될듯) 글을 읽었을 때 게임과 같이 동시로그인을 꼭 막아야하는 경우가 아니면, 쿠키 암호화가 성능상/구현상 더 좋은 거 같음. 암호화 알고리즘도 라이브러리화 된 신뢰성 있는 것이 많기에 글에서 본 단점도 상쇄된다. secret key 관리만 개발자가 주의하면 될 거 같음. 물리적 해킹일 땐 어떻게? ex) PC방에서 A유저가 로그인 하고 자리를 떴는데, B가 와서 그대로 사용할 경우 쿠키 / 세션의 경우 : 만료기간 두기가 최선일 거 같음. JWT : refresh token 사용 + refresh token 탈취 대비책은 위에서 “주의점”에 적은 대로. 네이버 로그인 방식 NID_AUT, NID_SES 사용 링크에 나온대로 두 쿠키를 복사한 후 다른 브라우저에 넣어봤는데, 로그인이 되었다. 그런데 다른 페이지로 이동하려니 로그인이 막힘. 다른 쿠키도 차례대로 넣어봤는데 동작하지 않음 네이버에 접속하자마자 바로 JSESSIONID란 쿠키가 생성됨. 이름이나 값이 단순 숫자인것으로 보아 세션은 사용하는거 같은데, 로그인 후 새로 생기는 것들은 암호화 되어있고 기존 JSESSIONID와는 독립되어보임. 서비스 형태, 위에서 나온 현상을 봤을때 SSO을 네이버에서도 사용하는 것 같음. 그런데 SSO를 어떤 방식으로 인증하는 걸까? 찾기가 어려움.. 다만 쿠키를 봤을때, JWT는 사용하지 않는 것으로 보임. 그리고 SSO는 큰 규모의 서비스를 대상으로 하는데, 세션을 사용하면 성능에 한계가 있어보임. 그럼 쿠키/세션/JWT 중에 있다면, 쿠키를 암호화하여 사용하는 것으로 보이는데 구체적인 내부 방식은 모르겠음. Redis를 사용하면 세션 성능 문제를 해결할 수 있지만, 그렇게까지 세션을 고집할 이유는 없어보임." /><link rel="canonical" href="https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/" /><meta property="og:url" content="https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/" /><meta property="og:site_name" content="디피의 개발일지" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-30T18:19:26+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="쿠키 인증 vs 세션 vs JWT" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"신성일"},"dateModified":"2023-05-30T21:53:32+09:00","datePublished":"2022-09-30T18:19:26+09:00","description":"쿠키 사용자가 로그인하면, 사용자 식별자를 암호화 또는 평문으로 쿠키에 담는 방식. 요청이 오면 쿠키에 담긴 식별자를 보고 유저를 구분한다. 장점 유효한 쿠키인지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 암호화를 하면 brute force 대응 가능(특정 횟수 이상 인증 실패시 ip 잠금) 간단히 구현 가능 단점 쿠키가 탈취되면 위장 가능 세션 인증이 완료되면 사용자 식별자를 서버(DB 등)에 저장하고 그 저장한 곳에 접근하기 위한 해시 값을 세션 ID로 지정. 이후 세션 ID를 쿠키에 담아 보내주고, 사용자로부터 요청이 오면 세션id로 사용자 식별자를 가져온다. 장점 세션id가 노출되어도 유의미한 정보를 가지고 있지 않음. 같은 유저가 다른 곳에서 로그인할 시, 누가 로그인 되어있는지 저장하고 있기에, 하나를 막을 수 있음. 단점 쿠키가 탈취되면 위장 가능 요청이 많아지면 서버에 부하가 심해져, 세션 DB와 서버를 확장해야 한다. 세션 관리 시스템에 문제가 생기면 시스템 전체에 문제가 생긴다. JWT 인증이 되면, JWT 토큰(access token)을 클라이언트로 보내줌. 클라이언트는 헤더에 JWT를 적용하여 서버로 요청을 보내면 서버는 JWT을 디코딩하여 유저를 식별함. 장점 토큰이 유효한지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다. 서버를 무상태(stateless)로 만들어줌. 단점 탈취에 취약하다. 따라서 refresh token을 만들고, access token에 만료기간을 설정함. XSS 공격, CSRF 공격에 대비해야함. refresh token도 탈취될 수 있지만 서버가 방어할 수 있는 방법을 제공함. 쿠키/세션 다룰 때 주의점 httponly을 통해 XSS 공격 막기 secure 옵션을 통해 패킷 탈취에 대비 식별자는 암호화하여, brute force 막기. 특정 횟수 이상 인증 실패 시 ip 차단 CSRF 에 대비하기 위해 게시글에 html 입력 불가능하도록 하기.(sanitize) 쿠키 탈취에 대비하기 위해 너무 동떨어진 위치에서 요청 시 차단 암호화 시에는 레인보우 테이블 공격 방어로 salt를 섞고 한번 더 암호화하는 기법(bcrypt 등) 사용 만료기간 설정 or 브라우저 닫을 시 만료 JWT 다룰 때 주의점 refresh token 탈취 시에 대응하기 위해, 같은 refresh token 사용이 두 번 감지되면 그 refresh token 이후 발급 된 모든 refresh token을 폐기 https://developer-ping9.tistory.com/239 다만 이 경우에도 access token만 계속 탈취하거나, 공격자가 먼저 reissue 했을 땐, 감지 할 수 없다. access token 만료 전에 reissue 시 탈취된 것으로 판단하여 access token을 폐기시킬 수 있음 이 경우에도 access token 만료 후 리이슈해서 접근하면 감지할 수 없음. 쿠키 vs 세션 장단점만 보면 쿠키가 서버 확장에도 대응이 돼서 쿠키가 더 좋아보인다. 그런데 왜 사람들은 세션이 좋다고 하는 것일까? 로그인 상태를 저장하기에 동시 로그인 시 하나를 막을 수 있다지만, 서비스에 따라서는 동시로그인을 허용해야하는 경우가 많다. 정확히 어떤 차이점이 있을까? Session ID in cookies vs. Encrypted cookie 쿠키 암호화가 세션에 비해 단점인 것 복잡한 암호화 알고리즘 필요, secret key 관리 필요, 비중앙화됨(동시로그인 못막음) 신뢰할 수 있는 암호화 알고리즘을 사용해야함 크기가 커서 네트워크 비용 발생 (바이트 수준 차이라 크게 문제는 안될듯) 글을 읽었을 때 게임과 같이 동시로그인을 꼭 막아야하는 경우가 아니면, 쿠키 암호화가 성능상/구현상 더 좋은 거 같음. 암호화 알고리즘도 라이브러리화 된 신뢰성 있는 것이 많기에 글에서 본 단점도 상쇄된다. secret key 관리만 개발자가 주의하면 될 거 같음. 물리적 해킹일 땐 어떻게? ex) PC방에서 A유저가 로그인 하고 자리를 떴는데, B가 와서 그대로 사용할 경우 쿠키 / 세션의 경우 : 만료기간 두기가 최선일 거 같음. JWT : refresh token 사용 + refresh token 탈취 대비책은 위에서 “주의점”에 적은 대로. 네이버 로그인 방식 NID_AUT, NID_SES 사용 링크에 나온대로 두 쿠키를 복사한 후 다른 브라우저에 넣어봤는데, 로그인이 되었다. 그런데 다른 페이지로 이동하려니 로그인이 막힘. 다른 쿠키도 차례대로 넣어봤는데 동작하지 않음 네이버에 접속하자마자 바로 JSESSIONID란 쿠키가 생성됨. 이름이나 값이 단순 숫자인것으로 보아 세션은 사용하는거 같은데, 로그인 후 새로 생기는 것들은 암호화 되어있고 기존 JSESSIONID와는 독립되어보임. 서비스 형태, 위에서 나온 현상을 봤을때 SSO을 네이버에서도 사용하는 것 같음. 그런데 SSO를 어떤 방식으로 인증하는 걸까? 찾기가 어려움.. 다만 쿠키를 봤을때, JWT는 사용하지 않는 것으로 보임. 그리고 SSO는 큰 규모의 서비스를 대상으로 하는데, 세션을 사용하면 성능에 한계가 있어보임. 그럼 쿠키/세션/JWT 중에 있다면, 쿠키를 암호화하여 사용하는 것으로 보이는데 구체적인 내부 방식은 모르겠음. Redis를 사용하면 세션 성능 문제를 해결할 수 있지만, 그렇게까지 세션을 고집할 이유는 없어보임.","headline":"쿠키 인증 vs 세션 vs JWT","mainEntityOfPage":{"@type":"WebPage","@id":"https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/"},"url":"https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/"}</script><title>쿠키 인증 vs 세션 vs JWT | 디피의 개발일지</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-HC9W0NGRV0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-HC9W0NGRV0'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">디피의 개발일지</a></div><div class="site-subtitle font-italic">개인 학습 및 프로젝트 기록</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Seongil-Shin" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['callmeshin75','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/%EC%84%B1%EC%9D%BC-%EC%8B%A0-a9411b237/" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>쿠키 인증 vs 세션 vs JWT</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>쿠키 인증 vs 세션 vs JWT</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 신성일 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Sep 30, 2022, 6:19 PM +0900" prep="on" > Sep 30, 2022 <i class="unloaded">2022-09-30T18:19:26+09:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, May 30, 2023, 9:53 PM +0900" prefix="Updated " > May 30, 2023 <i class="unloaded">2023-05-30T21:53:32+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1674 words">9 min</span></div></div><div class="post-content"><h1 id="쿠키">쿠키</h1><p>사용자가 로그인하면, 사용자 식별자를 암호화 또는 평문으로 쿠키에 담는 방식. 요청이 오면 쿠키에 담긴 식별자를 보고 유저를 구분한다.</p><ul><li>장점<ul><li>유효한 쿠키인지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다.<li>서버를 무상태(stateless)로 만들어줌.<li>암호화를 하면 brute force 대응 가능(특정 횟수 이상 인증 실패시 ip 잠금)<li>간단히 구현 가능</ul><li>단점<ul><li>쿠키가 탈취되면 위장 가능</ul></ul><h1 id="세션">세션</h1><p>인증이 완료되면 사용자 식별자를 서버(DB 등)에 저장하고 그 저장한 곳에 접근하기 위한 해시 값을 세션 ID로 지정. 이후 세션 ID를 쿠키에 담아 보내주고, 사용자로부터 요청이 오면 세션id로 사용자 식별자를 가져온다.</p><ul><li>장점<ul><li>세션id가 노출되어도 유의미한 정보를 가지고 있지 않음.<li>같은 유저가 다른 곳에서 로그인할 시, 누가 로그인 되어있는지 저장하고 있기에, 하나를 막을 수 있음.</ul><li>단점<ul><li>쿠키가 탈취되면 위장 가능<li>요청이 많아지면 서버에 부하가 심해져, 세션 DB와 서버를 확장해야 한다.<li>세션 관리 시스템에 문제가 생기면 시스템 전체에 문제가 생긴다.</ul></ul><h1 id="jwt">JWT</h1><p>인증이 되면, JWT 토큰(access token)을 클라이언트로 보내줌. 클라이언트는 헤더에 JWT를 적용하여 서버로 요청을 보내면 서버는 JWT을 디코딩하여 유저를 식별함.</p><ul><li>장점<ul><li>토큰이 유효한지만 확인하면 되기에 서버자원과 비용을 아낄 수 있다.<li>서버를 무상태(stateless)로 만들어줌.</ul><li>단점<ul><li>탈취에 취약하다. 따라서 refresh token을 만들고, access token에 만료기간을 설정함.<ul><li>XSS 공격, CSRF 공격에 대비해야함.<li><a href="https://okky.kr/articles/1007579">refresh token도 탈취될 수 있지만 서버가 방어할 수 있는 방법을 제공함.</a></ul></ul></ul><hr /><h1 id="쿠키세션-다룰-때-주의점">쿠키/세션 다룰 때 주의점</h1><ul><li>httponly을 통해 XSS 공격 막기<li>secure 옵션을 통해 패킷 탈취에 대비<li>식별자는 암호화하여, brute force 막기.<li>특정 횟수 이상 인증 실패 시 ip 차단<li>CSRF 에 대비하기 위해 게시글에 html 입력 불가능하도록 하기.(sanitize)<li>쿠키 탈취에 대비하기 위해 너무 동떨어진 위치에서 요청 시 차단<li>암호화 시에는 레인보우 테이블 공격 방어로 salt를 섞고 한번 더 암호화하는 기법(bcrypt 등) 사용<li>만료기간 설정 or 브라우저 닫을 시 만료</ul><h1 id="jwt-다룰-때-주의점">JWT 다룰 때 주의점</h1><ul><li>refresh token 탈취 시에 대응하기 위해, 같은 refresh token 사용이 두 번 감지되면 그 refresh token 이후 발급 된 모든 refresh token을 폐기<ul><li>https://developer-ping9.tistory.com/239<li>다만 이 경우에도 access token만 계속 탈취하거나, 공격자가 먼저 reissue 했을 땐, 감지 할 수 없다.</ul><li>access token 만료 전에 reissue 시 탈취된 것으로 판단하여 access token을 폐기시킬 수 있음<ul><li>이 경우에도 access token 만료 후 리이슈해서 접근하면 감지할 수 없음.</ul></ul><hr /><h1 id="쿠키-vs-세션">쿠키 vs 세션</h1><p>장단점만 보면 쿠키가 서버 확장에도 대응이 돼서 쿠키가 더 좋아보인다. 그런데 왜 사람들은 세션이 좋다고 하는 것일까? 로그인 상태를 저장하기에 동시 로그인 시 하나를 막을 수 있다지만, 서비스에 따라서는 동시로그인을 허용해야하는 경우가 많다. 정확히 어떤 차이점이 있을까?</p><p><a href="https://security.stackexchange.com/questions/174334/better-security-session-id-in-cookies-vs-encrypted-cookie">Session ID in cookies vs. Encrypted cookie</a></p><ul><li>쿠키 암호화가 세션에 비해 단점인 것<ul><li>복잡한 암호화 알고리즘 필요, secret key 관리 필요, 비중앙화됨(동시로그인 못막음)<li>신뢰할 수 있는 암호화 알고리즘을 사용해야함<li>크기가 커서 네트워크 비용 발생 (바이트 수준 차이라 크게 문제는 안될듯)</ul></ul><p>글을 읽었을 때 게임과 같이 동시로그인을 꼭 막아야하는 경우가 아니면, 쿠키 암호화가 성능상/구현상 더 좋은 거 같음. 암호화 알고리즘도 라이브러리화 된 신뢰성 있는 것이 많기에 글에서 본 단점도 상쇄된다. secret key 관리만 개발자가 주의하면 될 거 같음.</p><hr /><h1 id="물리적-해킹일-땐-어떻게">물리적 해킹일 땐 어떻게?</h1><p>ex) PC방에서 A유저가 로그인 하고 자리를 떴는데, B가 와서 그대로 사용할 경우</p><ul><li>쿠키 / 세션의 경우 : 만료기간 두기가 최선일 거 같음.<li>JWT : refresh token 사용 + refresh token 탈취 대비책은 위에서 “주의점”에 적은 대로.</ul><hr /><h1 id="네이버-로그인-방식">네이버 로그인 방식</h1><ul><li><a href="https://iwantadmin.tistory.com/250"><code class="language-plaintext highlighter-rouge">NID_AUT</code>, <code class="language-plaintext highlighter-rouge">NID_SES</code></a> 사용<ul><li>링크에 나온대로 두 쿠키를 복사한 후 다른 브라우저에 넣어봤는데, 로그인이 되었다.<li>그런데 다른 페이지로 이동하려니 로그인이 막힘. 다른 쿠키도 차례대로 넣어봤는데 동작하지 않음</ul><li>네이버에 접속하자마자 바로 <code class="language-plaintext highlighter-rouge">JSESSIONID</code>란 쿠키가 생성됨. 이름이나 값이 단순 숫자인것으로 보아 세션은 사용하는거 같은데, 로그인 후 새로 생기는 것들은 암호화 되어있고 기존 <code class="language-plaintext highlighter-rouge">JSESSIONID</code>와는 독립되어보임.<li>서비스 형태, 위에서 나온 현상을 봤을때 <a href="https://m.blog.naver.com/sehyunfa/221767776133">SSO</a>을 네이버에서도 사용하는 것 같음. 그런데 SSO를 어떤 방식으로 인증하는 걸까?<ul><li>찾기가 어려움..<li>다만 쿠키를 봤을때, JWT는 사용하지 않는 것으로 보임. 그리고 SSO는 큰 규모의 서비스를 대상으로 하는데, 세션을 사용하면 성능에 한계가 있어보임. 그럼 쿠키/세션/JWT 중에 있다면, 쿠키를 암호화하여 사용하는 것으로 보이는데 구체적인 내부 방식은 모르겠음.<li>Redis를 사용하면 세션 성능 문제를 해결할 수 있지만, 그렇게까지 세션을 고집할 이유는 없어보임.</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/study/'>study</a>, <a href='/categories/web/'>web</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/web/" class="post-tag no-text-decoration" >web</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=쿠키 인증 vs 세션 vs JWT - 디피의 개발일지&url=https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=쿠키 인증 vs 세션 vs JWT - 디피의 개발일지&u=https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=쿠키 인증 vs 세션 vs JWT - 디피의 개발일지&url=https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/You-don't-know-JS-Yet-1%EC%9E%A5-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">You don't know JS Yet - 1장 자바스크립트</a><li><a href="/posts/why-nextjs-sucks/">why-nextjs-sucks</a><li><a href="/posts/the-state-of-es5-on-the-web/">the state of es5 on the web</a><li><a href="/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-3%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AC%B8%EB%B2%95-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EA%B8%B0/">프로그래머의 뇌 3장 프로그래밍 문법 빠르게 배우기</a><li><a href="/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%9D%98-%EB%87%8C-4%EC%9E%A5-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%9D%BD%EB%8A%94-%EB%B0%A9%EB%B2%95/">프로그래머의 뇌 4장 복잡한 코드 읽는 방법</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/study/">#study</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/next-js/">next.js</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/db/">db</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/java/">java</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/web-Headless-CMS/"><div class="card-body"> <span class="timeago small" > Mar 10, 2023 <i class="unloaded">2023-03-10T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Headless CMS</h3><div class="text-muted small"><p> Headless CMS 란? 웹사이트를 만들 때는 반드시 컨텐츠(데이터)가 필요하다. Headless CMS는 컨텐츠를 보여줄 수단인 Head와 컨텐츠를 분리한 구조로, 컨텐츠가 Head에 독립적으로 동작할 수 있도록 하는 구조이다. ![1E3qz8MZ8zR7Y3NRghFOvJQ](https://miro.medium.com/v2/resize:fit...</p></div></div></a></div><div class="card"> <a href="/posts/deep-link/"><div class="card-body"> <span class="timeago small" > May 19, 2023 <i class="unloaded">2023-05-19T22:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>딥링크</h3><div class="text-muted small"><p> 딥링크는 웹사이트에서 사용자 기기에 설치된 앱을 URI로 실행시킬 수 있도록하는 기술이다. 딥링크의 세가지 유형 이러한 딥링크에는 세가지 유형이 있다. URI Scheme (초기 형태) 보완 Universal Link (IOS) App Link (Android) URI Scheme 앱...</p></div></div></a></div><div class="card"> <a href="/posts/opengraph/"><div class="card-body"> <span class="timeago small" > Sep 11, 2022 <i class="unloaded">2022-09-11T16:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Open Graph(OG) 프로토콜</h3><div class="text-muted small"><p> Open Graph 프로토콜 HTML문서의 head에는 &lt;meta&gt; 태그로 사이트의 정보가 표기되어있는 경우가 많다. 이는 크롤러가 무엇이 제목이고, 무엇이 내용인지 파악하기 쉽도록 하기 위해서 표기한 것이다. 페이스북의 Open Graph 프로토콜은 이러한 메타태그의 표기 방법은 통일한 것이다. 이 Open Graph 프로토콜이 우리가...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EB%B3%80%ED%99%94/" class="btn btn-outline-primary" prompt="Older"><p>프론트 아키텍쳐 흐름</p></a> <a href="/posts/spring-%EC%84%9C%EB%B8%94%EB%A6%BF-%ED%95%84%ED%84%B0/" class="btn btn-outline-primary" prompt="Newer"><p>서블릿 필터</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//.disqus.com/embed.js', disqusConfig: function() { this.page.title = '쿠키 인증 vs 세션 vs JWT'; this.page.url = 'https://seongil-shin.github.io/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/'; this.page.identifier = '/posts/web-%EC%BF%A0%ED%82%A4-%EC%9D%B8%EC%A6%9D-vs-%EC%84%B8%EC%85%98-vs-JWT/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/Seongil-Shin">ShinSeongil</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/study/">#study</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/next-js/">next.js</a> <a class="post-tag" href="/tags/web/">web</a> <a class="post-tag" href="/tags/db/">db</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag" href="/tags/architecture/">architecture</a> <a class="post-tag" href="/tags/java/">java</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://seongil-shin.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
